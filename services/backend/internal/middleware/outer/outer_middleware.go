// GENERATED CODE - DO NOT EDIT!
// @generated
//
// Generated by:
//
//   go run gen_middleware.go
//
// Called via:
//
//   go generate
//

package outer

import (
	"runtime"

	"golang.org/x/net/context"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"sourcegraph.com/sourcegraph/sourcegraph/api/sourcegraph"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/inventory"
	"sourcegraph.com/sourcegraph/sourcegraph/pkg/vcs"
	"sourcegraph.com/sourcegraph/sourcegraph/services/svc"
	"sourcegraph.com/sourcegraph/srclib/store/pb"
	"sourcegraph.com/sqs/pbtypes"
)

// Services returns a full set of services with an implementation of each service method that lets you customize the initial context.Context and map Go errors to gRPC error codes. It is similar to HTTP handler middleware, but for gRPC servers.
func Services(ctxFunc ContextFunc, services svc.Services) svc.Services {
	s := svc.Services{
		MultiRepoImporter: wrappedMultiRepoImporter{ctxFunc, services},
		Accounts:          wrappedAccounts{ctxFunc, services},
		Annotations:       wrappedAnnotations{ctxFunc, services},
		Auth:              wrappedAuth{ctxFunc, services},
		Builds:            wrappedBuilds{ctxFunc, services},
		Channel:           wrappedChannel{ctxFunc, services},
		Defs:              wrappedDefs{ctxFunc, services},
		Deltas:            wrappedDeltas{ctxFunc, services},
		Meta:              wrappedMeta{ctxFunc, services},
		MirrorRepos:       wrappedMirrorRepos{ctxFunc, services},
		Notify:            wrappedNotify{ctxFunc, services},
		Orgs:              wrappedOrgs{ctxFunc, services},
		People:            wrappedPeople{ctxFunc, services},
		RepoStatuses:      wrappedRepoStatuses{ctxFunc, services},
		RepoTree:          wrappedRepoTree{ctxFunc, services},
		Repos:             wrappedRepos{ctxFunc, services},
		Search:            wrappedSearch{ctxFunc, services},
		Users:             wrappedUsers{ctxFunc, services},
	}
	return s
}

type wrappedMultiRepoImporter struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMultiRepoImporter) Import(ctx context.Context, v1 *pb.ImportOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.Import: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.Import(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMultiRepoImporter) CreateVersion(ctx context.Context, v1 *pb.CreateVersionOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.CreateVersion: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.CreateVersion(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMultiRepoImporter) Index(ctx context.Context, v1 *pb.IndexOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MultiRepoImporter.Index: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MultiRepoImporterOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MultiRepoImporter")
	}

	rv, err := innerSvc.Index(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAccounts struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAccounts) Create(ctx context.Context, v1 *sourcegraph.NewAccount) (returnedResult *sourcegraph.CreatedAccount, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) RequestPasswordReset(ctx context.Context, v1 *sourcegraph.PersonSpec) (returnedResult *sourcegraph.PendingPasswordReset, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.RequestPasswordReset: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.RequestPasswordReset(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) ResetPassword(ctx context.Context, v1 *sourcegraph.NewPassword) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.ResetPassword: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.ResetPassword(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) Update(ctx context.Context, v1 *sourcegraph.User) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAccounts) Delete(ctx context.Context, v1 *sourcegraph.PersonSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Accounts.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AccountsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Accounts")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAnnotations struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAnnotations) List(ctx context.Context, v1 *sourcegraph.AnnotationsListOptions) (returnedResult *sourcegraph.AnnotationList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Annotations.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AnnotationsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Annotations")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedAuth struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedAuth) GetAccessToken(ctx context.Context, v1 *sourcegraph.AccessTokenRequest) (returnedResult *sourcegraph.AccessTokenResponse, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.GetAccessToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.GetAccessToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) Identify(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.AuthInfo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.Identify: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.Identify(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) GetExternalToken(ctx context.Context, v1 *sourcegraph.ExternalTokenSpec) (returnedResult *sourcegraph.ExternalToken, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.GetExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.GetExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) SetExternalToken(ctx context.Context, v1 *sourcegraph.ExternalToken) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.SetExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.SetExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedAuth) DeleteAndRevokeExternalToken(ctx context.Context, v1 *sourcegraph.ExternalTokenSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Auth.DeleteAndRevokeExternalToken: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.AuthOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Auth")
	}

	rv, err := innerSvc.DeleteAndRevokeExternalToken(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedBuilds struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedBuilds) Get(ctx context.Context, v1 *sourcegraph.BuildSpec) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) List(ctx context.Context, v1 *sourcegraph.BuildListOptions) (returnedResult *sourcegraph.BuildList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) Create(ctx context.Context, v1 *sourcegraph.BuildsCreateOp) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) Update(ctx context.Context, v1 *sourcegraph.BuildsUpdateOp) (returnedResult *sourcegraph.Build, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) ListBuildTasks(ctx context.Context, v1 *sourcegraph.BuildsListBuildTasksOp) (returnedResult *sourcegraph.BuildTaskList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.ListBuildTasks: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.ListBuildTasks(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) CreateTasks(ctx context.Context, v1 *sourcegraph.BuildsCreateTasksOp) (returnedResult *sourcegraph.BuildTaskList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.CreateTasks: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.CreateTasks(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) UpdateTask(ctx context.Context, v1 *sourcegraph.BuildsUpdateTaskOp) (returnedResult *sourcegraph.BuildTask, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.UpdateTask: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.UpdateTask(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) GetTaskLog(ctx context.Context, v1 *sourcegraph.BuildsGetTaskLogOp) (returnedResult *sourcegraph.LogEntries, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.GetTaskLog: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.GetTaskLog(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedBuilds) DequeueNext(ctx context.Context, v1 *sourcegraph.BuildsDequeueNextOp) (returnedResult *sourcegraph.BuildJob, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Builds.DequeueNext: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.BuildsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Builds")
	}

	rv, err := innerSvc.DequeueNext(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedChannel struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedChannel) Send(ctx context.Context, v1 *sourcegraph.ChannelSendOp) (returnedResult *sourcegraph.ChannelSendResult, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Channel.Send: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ChannelOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Channel")
	}

	rv, err := innerSvc.Send(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedDefs struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedDefs) Get(ctx context.Context, v1 *sourcegraph.DefsGetOp) (returnedResult *sourcegraph.Def, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) List(ctx context.Context, v1 *sourcegraph.DefListOptions) (returnedResult *sourcegraph.DefList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListRefs(ctx context.Context, v1 *sourcegraph.DefsListRefsOp) (returnedResult *sourcegraph.RefList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListRefs: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListRefs(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListRefLocations(ctx context.Context, v1 *sourcegraph.DefsListRefLocationsOp) (returnedResult *sourcegraph.RefLocationsList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListRefLocations: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListRefLocations(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListExamples(ctx context.Context, v1 *sourcegraph.DefsListExamplesOp) (returnedResult *sourcegraph.RefLocationsList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListExamples: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListExamples(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) ListAuthors(ctx context.Context, v1 *sourcegraph.DefsListAuthorsOp) (returnedResult *sourcegraph.DefAuthorList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.ListAuthors: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.ListAuthors(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDefs) RefreshIndex(ctx context.Context, v1 *sourcegraph.DefsRefreshIndexOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Defs.RefreshIndex: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DefsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Defs")
	}

	rv, err := innerSvc.RefreshIndex(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedDeltas struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedDeltas) Get(ctx context.Context, v1 *sourcegraph.DeltaSpec) (returnedResult *sourcegraph.Delta, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedDeltas) ListFiles(ctx context.Context, v1 *sourcegraph.DeltasListFilesOp) (returnedResult *sourcegraph.DeltaFiles, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Deltas.ListFiles: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.DeltasOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Deltas")
	}

	rv, err := innerSvc.ListFiles(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedMeta struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMeta) Status(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.ServerStatus, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Meta.Status: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MetaOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Meta")
	}

	rv, err := innerSvc.Status(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedMeta) Config(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.ServerConfig, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Meta.Config: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MetaOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Meta")
	}

	rv, err := innerSvc.Config(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedMirrorRepos struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedMirrorRepos) RefreshVCS(ctx context.Context, v1 *sourcegraph.MirrorReposRefreshVCSOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in MirrorRepos.RefreshVCS: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.MirrorReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "MirrorRepos")
	}

	rv, err := innerSvc.RefreshVCS(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedNotify struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedNotify) GenericEvent(ctx context.Context, v1 *sourcegraph.NotifyGenericEvent) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Notify.GenericEvent: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.NotifyOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Notify")
	}

	rv, err := innerSvc.GenericEvent(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedOrgs struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedOrgs) Get(ctx context.Context, v1 *sourcegraph.OrgSpec) (returnedResult *sourcegraph.Org, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Orgs.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.OrgsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Orgs")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedOrgs) List(ctx context.Context, v1 *sourcegraph.OrgsListOp) (returnedResult *sourcegraph.OrgList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Orgs.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.OrgsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Orgs")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedOrgs) ListMembers(ctx context.Context, v1 *sourcegraph.OrgsListMembersOp) (returnedResult *sourcegraph.UserList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Orgs.ListMembers: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.OrgsOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Orgs")
	}

	rv, err := innerSvc.ListMembers(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedPeople struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedPeople) Get(ctx context.Context, v1 *sourcegraph.PersonSpec) (returnedResult *sourcegraph.Person, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in People.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.PeopleOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "People")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepoStatuses struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepoStatuses) GetCombined(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *sourcegraph.CombinedStatus, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.GetCombined: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.GetCombined(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoStatuses) GetCoverage(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.RepoStatusList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.GetCoverage: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.GetCoverage(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoStatuses) Create(ctx context.Context, v1 *sourcegraph.RepoStatusesCreateOp) (returnedResult *sourcegraph.RepoStatus, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoStatuses.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoStatusesOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoStatuses")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepoTree struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepoTree) Get(ctx context.Context, v1 *sourcegraph.RepoTreeGetOp) (returnedResult *sourcegraph.TreeEntry, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoTree) Search(ctx context.Context, v1 *sourcegraph.RepoTreeSearchOp) (returnedResult *sourcegraph.VCSSearchResultList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.Search: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.Search(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepoTree) List(ctx context.Context, v1 *sourcegraph.RepoTreeListOp) (returnedResult *sourcegraph.RepoTreeListResult, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in RepoTree.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.RepoTreeOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "RepoTree")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedRepos struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedRepos) Get(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.Repo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Resolve(ctx context.Context, v1 *sourcegraph.RepoResolveOp) (returnedResult *sourcegraph.RepoResolution, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Resolve: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Resolve(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) List(ctx context.Context, v1 *sourcegraph.RepoListOptions) (returnedResult *sourcegraph.RepoList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListRemote(ctx context.Context, v1 *sourcegraph.ReposListRemoteOptions) (returnedResult *sourcegraph.RemoteRepoList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListRemote: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListRemote(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Create(ctx context.Context, v1 *sourcegraph.ReposCreateOp) (returnedResult *sourcegraph.Repo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Create: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Create(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Update(ctx context.Context, v1 *sourcegraph.ReposUpdateOp) (returnedResult *sourcegraph.Repo, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Update: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Update(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) Delete(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.Delete: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.Delete(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetConfig(ctx context.Context, v1 *sourcegraph.RepoSpec) (returnedResult *sourcegraph.RepoConfig, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetConfig: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetConfig(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetCommit(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *vcs.Commit, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetCommit: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetCommit(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ResolveRev(ctx context.Context, v1 *sourcegraph.ReposResolveRevOp) (returnedResult *sourcegraph.ResolvedRev, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ResolveRev: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ResolveRev(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListCommits(ctx context.Context, v1 *sourcegraph.ReposListCommitsOp) (returnedResult *sourcegraph.CommitList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListCommits: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListCommits(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListBranches(ctx context.Context, v1 *sourcegraph.ReposListBranchesOp) (returnedResult *sourcegraph.BranchList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListBranches: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListBranches(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListTags(ctx context.Context, v1 *sourcegraph.ReposListTagsOp) (returnedResult *sourcegraph.TagList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListTags: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListTags(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ListCommitters(ctx context.Context, v1 *sourcegraph.ReposListCommittersOp) (returnedResult *sourcegraph.CommitterList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ListCommitters: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ListCommitters(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetSrclibDataVersionForPath(ctx context.Context, v1 *sourcegraph.TreeEntrySpec) (returnedResult *sourcegraph.SrclibDataVersion, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetSrclibDataVersionForPath: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetSrclibDataVersionForPath(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ConfigureApp(ctx context.Context, v1 *sourcegraph.RepoConfigureAppOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ConfigureApp: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ConfigureApp(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) GetInventory(ctx context.Context, v1 *sourcegraph.RepoRevSpec) (returnedResult *inventory.Inventory, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.GetInventory: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.GetInventory(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) ReceivePack(ctx context.Context, v1 *sourcegraph.ReceivePackOp) (returnedResult *sourcegraph.Packet, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.ReceivePack: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.ReceivePack(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedRepos) UploadPack(ctx context.Context, v1 *sourcegraph.UploadPackOp) (returnedResult *sourcegraph.Packet, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Repos.UploadPack: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.ReposOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Repos")
	}

	rv, err := innerSvc.UploadPack(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedSearch struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedSearch) Search(ctx context.Context, v1 *sourcegraph.SearchOp) (returnedResult *sourcegraph.SearchResultsList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Search.Search: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.SearchOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Search")
	}

	rv, err := innerSvc.Search(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedSearch) RefreshIndex(ctx context.Context, v1 *sourcegraph.SearchRefreshIndexOp) (returnedResult *pbtypes.Void, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Search.RefreshIndex: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.SearchOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Search")
	}

	rv, err := innerSvc.RefreshIndex(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

type wrappedUsers struct {
	ctxFunc  ContextFunc
	services svc.Services
}

func (s wrappedUsers) Get(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *sourcegraph.User, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.Get: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.Get(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) GetWithEmail(ctx context.Context, v1 *sourcegraph.EmailAddr) (returnedResult *sourcegraph.User, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.GetWithEmail: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.GetWithEmail(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) ListEmails(ctx context.Context, v1 *sourcegraph.UserSpec) (returnedResult *sourcegraph.EmailAddrList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.ListEmails: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.ListEmails(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) List(ctx context.Context, v1 *sourcegraph.UsersListOptions) (returnedResult *sourcegraph.UserList, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.List: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.List(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}

func (s wrappedUsers) Count(ctx context.Context, v1 *pbtypes.Void) (returnedResult *sourcegraph.UserCount, returnedError error) {
	defer func() {
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			returnedError = grpc.Errorf(codes.Internal, "panic in Users.Count: %v\n\n%s", err, buf)
			returnedResult = nil
		}
	}()

	var err error
	ctx, err = initContext(ctx, s.ctxFunc, s.services)
	if err != nil {
		return nil, wrapErr(err)
	}

	innerSvc := svc.UsersOrNil(ctx)
	if innerSvc == nil {
		return nil, grpc.Errorf(codes.Unimplemented, "Users")
	}

	rv, err := innerSvc.Count(ctx, v1)
	if err != nil {
		return nil, wrapErr(err)
	}

	return rv, nil
}
