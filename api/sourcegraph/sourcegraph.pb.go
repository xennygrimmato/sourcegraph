// Code generated by protoc-gen-gogo.
// source: sourcegraph.proto
// DO NOT EDIT!

/*
	Package sourcegraph is a generated protocol buffer package.

	It is generated from these files:
		sourcegraph.proto

	It has these top-level messages:
		Origin
		CombinedStatus
		ListOptions
		ListResponse
		StreamResponse
		RepoConfig
		Repo
		RepoListOptions
		RepoRevSpec
		RepoSpec
		RepoStatus
		RepoStatusList
		RepoStatusesCreateOp
		RepoList
		ReposResolveRevOp
		ResolvedRev
		ReceivePackOp
		UploadPackOp
		Packet
		RepoResolveOp
		RepoResolution
		ReposListRemoteOptions
		RemoteRepoList
		SrclibDataVersion
		RepoConfigureAppOp
		ReposCreateOp
		ReposUpdateOp
		ReposListCommitsOp
		RepoListCommitsOptions
		CommitList
		ReposListBranchesOp
		RepoListBranchesOptions
		BranchList
		ReposListTagsOp
		ReposListCommittersOp
		RepoListCommittersOptions
		CommitterList
		RepoListTagsOptions
		TagList
		MirrorReposRefreshVCSOp
		VCSCredentials
		RemoteRepo
		Build
		BuildConfig
		BuildJob
		BuildGetLogOptions
		BuildListOptions
		BuildSpec
		BuildTask
		BuildTaskListOptions
		BuildUpdate
		BuildList
		BuildsCreateOp
		BuildsUpdateOp
		BuildsListBuildTasksOp
		BuildTaskList
		BuildsCreateTasksOp
		BuildsUpdateTaskOp
		BuildsGetTaskLogOp
		BuildsDequeueNextOp
		EmailAddr
		LogEntries
		Org
		OrgListMembersOptions
		OrgSpec
		OrgsListMembersOp
		UserList
		UserCount
		Person
		PersonSpec
		TaskSpec
		TaskUpdate
		User
		UserSpec
		UsersListOptions
		OrgsListOp
		EmailAddrList
		OrgList
		CreatedAccount
		PasswordResetToken
		PendingPasswordReset
		NewPassword
		NewAccount
		LoginCredentials
		GitHubAuthCode
		AccessTokenRequest
		AccessTokenResponse
		GitHubUser
		AuthInfo
		ExternalTokenSpec
		ExternalToken
		Def
		DefGetOptions
		DefListOptions
		DefListRefsOptions
		DefSpec
		DefsGetOp
		DefList
		DefsListRefsOp
		RefList
		DefListRefLocationsOptions
		DefsListRefLocationsOp
		DefsListExamplesOp
		RefLocationsList
		DefRepoRef
		DefFileRef
		Delta
		FileDiff
		DeltaFiles
		DeltaFilter
		DeltaListFilesOptions
		DeltaSpec
		DeltasListFilesOp
		RepoTreeGetOptions
		GetFileOptions
		RepoTreeSearchOptions
		RepoTreeSearchResult
		RepoTreeGetOp
		RepoTreeSearchOp
		RepoTreeListOp
		RepoTreeListResult
		VCSSearchResultList
		TreeEntry
		BasicTreeEntry
		TreeEntrySpec
		FileRange
		DefsRefreshIndexOp
		AsyncRefreshIndexesOp
		AuthorshipInfo
		DefAuthor
		DefAuthorship
		DefListAuthorsOptions
		DefsListAuthorsOp
		DefAuthorList
		Checklist
		FileToken
		ServerStatus
		ServerConfig
		UserEvent
		Event
		EventList
		NotifyGenericEvent
		Annotation
		AnnotationList
		AnnotationsListOptions
		SearchOptions
		SearchOp
		RepoSearchResult
		DefSearchResult
		SearchResultsList
		SearchRefreshIndexOp
		ChannelListenOp
		ChannelAction
		ChannelSendOp
		ChannelSendResult
*/
package sourcegraph

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import diff "sourcegraph.com/sourcegraph/go-diff/diff"
import vcs "sourcegraph.com/sourcegraph/sourcegraph/pkg/vcs"
import graph "sourcegraph.com/sourcegraph/srclib/graph"
import graph1 "sourcegraph.com/sourcegraph/srclib/graph"
import pbtypes "sourcegraph.com/sqs/pbtypes"
import pbtypes1 "sourcegraph.com/sqs/pbtypes"
import pbtypes2 "sourcegraph.com/sqs/pbtypes"
import inventory "sourcegraph.com/sourcegraph/sourcegraph/pkg/inventory"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type TreeEntryType int32

const (
	FileEntry      TreeEntryType = 0
	DirEntry       TreeEntryType = 1
	SymlinkEntry   TreeEntryType = 2
	SubmoduleEntry TreeEntryType = 3
)

var TreeEntryType_name = map[int32]string{
	0: "FileEntry",
	1: "DirEntry",
	2: "SymlinkEntry",
	3: "SubmoduleEntry",
}
var TreeEntryType_value = map[string]int32{
	"FileEntry":      0,
	"DirEntry":       1,
	"SymlinkEntry":   2,
	"SubmoduleEntry": 3,
}

func (x TreeEntryType) String() string {
	return proto.EnumName(TreeEntryType_name, int32(x))
}
func (TreeEntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{0} }

// ServiceType indicates which service is running on an origin. A
// repo whose origin service is GitHub, for example, should be
// accessed using a GitHub API client.
//
// If there are multiple API versions for a service, separate
// entries may be added per API version. In that case, the
// APIBaseURL may need to differ as well. The API client code is
// responsible for handling these cases.
type Origin_ServiceType int32

const (
	// GitHub indicates that the origin is GitHub.com or a GitHub
	// Enterprise server. If the latter, the origin base URL indicates
	// the URL to the GitHub Enterprise server's API.
	Origin_GitHub Origin_ServiceType = 0
)

var Origin_ServiceType_name = map[int32]string{
	0: "GitHub",
}
var Origin_ServiceType_value = map[string]int32{
	"GitHub": 0,
}

func (x Origin_ServiceType) String() string {
	return proto.EnumName(Origin_ServiceType_name, int32(x))
}
func (Origin_ServiceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{0, 0}
}

type ReposUpdateOp_BoolType int32

const (
	ReposUpdateOp_NONE  ReposUpdateOp_BoolType = 0
	ReposUpdateOp_TRUE  ReposUpdateOp_BoolType = 1
	ReposUpdateOp_FALSE ReposUpdateOp_BoolType = 2
)

var ReposUpdateOp_BoolType_name = map[int32]string{
	0: "NONE",
	1: "TRUE",
	2: "FALSE",
}
var ReposUpdateOp_BoolType_value = map[string]int32{
	"NONE":  0,
	"TRUE":  1,
	"FALSE": 2,
}

func (x ReposUpdateOp_BoolType) String() string {
	return proto.EnumName(ReposUpdateOp_BoolType_name, int32(x))
}
func (ReposUpdateOp_BoolType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{26, 0}
}

// Origin represents the origin of a resource that canonically lives
// on an external service (e.g., a repo hosted on GitHub).
type Origin struct {
	// ID is an identifier for the resource on its origin
	// service. Although numeric IDs are used on many services (GitHub
	// and Bitbucket, for example), this field is a string so that it
	// supports non-numeric IDs (which are used on Google Cloud
	// Platform and probably other services that Sourcegraph might
	// support in the future).
	//
	// If the ID is numeric, this string is the base-10 string
	// representation of the numeric ID (e.g., "1234"), with no
	// leading 0s.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Service is the type service that the resource canonically lives
	// on. It is used to determine which API client should be used to
	// access it on the origin service (e.g., GitHub vs. Bitbucket).
	Service Origin_ServiceType `protobuf:"varint,2,opt,name=Service,proto3,enum=sourcegraph.Origin_ServiceType" json:""`
	// APIBaseURL is the base URL to the API of the origin service for
	// the resource. (E.g., "https://api.github.com" for
	// GitHub.com-hosted repos.)
	APIBaseURL string `protobuf:"bytes,3,opt,name=APIBaseURL,proto3" json:"APIBaseURL,omitempty"`
}

func (m *Origin) Reset()                    { *m = Origin{} }
func (m *Origin) String() string            { return proto.CompactTextString(m) }
func (*Origin) ProtoMessage()               {}
func (*Origin) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{0} }

// CombinedStatus is the combined status (i.e., incorporating statuses from all
// contexts) of the repository at a specific rev.
type CombinedStatus struct {
	// Rev is the revision that this status describes. It is set mutually exclusive with CommitID.
	Rev string `protobuf:"bytes,4,opt,name=Rev,proto3" json:"Rev,omitempty"`
	// CommitID is the full commit ID of the commit this status describes. It is set mutually exclusively with Rev.
	CommitID string `protobuf:"bytes,1,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	// State is the combined status of the repository. Possible values are: failure,
	// pending, or success.
	State string `protobuf:"bytes,2,opt,name=State,proto3" json:"State,omitempty"`
	// Statuses are the statuses for each context.
	Statuses []*RepoStatus `protobuf:"bytes,3,rep,name=Statuses" json:"Statuses,omitempty"`
}

func (m *CombinedStatus) Reset()                    { *m = CombinedStatus{} }
func (m *CombinedStatus) String() string            { return proto.CompactTextString(m) }
func (*CombinedStatus) ProtoMessage()               {}
func (*CombinedStatus) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{1} }

// ListOptions specifies general pagination options for fetching a list of results.
type ListOptions struct {
	PerPage int32 `protobuf:"varint,1,opt,name=PerPage,proto3" json:"PerPage,omitempty" url:",omitempty"`
	Page    int32 `protobuf:"varint,2,opt,name=Page,proto3" json:"Page,omitempty" url:",omitempty"`
}

func (m *ListOptions) Reset()                    { *m = ListOptions{} }
func (m *ListOptions) String() string            { return proto.CompactTextString(m) }
func (*ListOptions) ProtoMessage()               {}
func (*ListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{2} }

// ListResponse specifies a general paginated response when fetching a list of results.
type ListResponse struct {
	// Total is the total number of results in the list.
	Total int32 `protobuf:"varint,1,opt,name=Total,proto3" json:"Total,omitempty" url:",omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{3} }

// StreamResponse specifies a paginated response where the total number of results
// that can be returned is too expensive to compute, unbounded, or unknown.
type StreamResponse struct {
	// HasMore is true if there are more results available after the returned page.
	HasMore bool `protobuf:"varint,1,opt,name=HasMore,proto3" json:"HasMore,omitempty" url:",omitempty"`
}

func (m *StreamResponse) Reset()                    { *m = StreamResponse{} }
func (m *StreamResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()               {}
func (*StreamResponse) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{4} }

// RepoConfig describes a repository's config. This config is
// Sourcegraph-specific and is persisted locally.
type RepoConfig struct {
	// Apps is a list of app IDs denoting the applications that are
	// enabled for this repository.
	Apps []string `protobuf:"bytes,1,rep,name=Apps" json:"Apps,omitempty"`
}

func (m *RepoConfig) Reset()                    { *m = RepoConfig{} }
func (m *RepoConfig) String() string            { return proto.CompactTextString(m) }
func (*RepoConfig) ProtoMessage()               {}
func (*RepoConfig) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{5} }

// Repo represents a source code repository.
type Repo struct {
	// ID is the unique numeric ID for this repository.
	ID int32 `protobuf:"varint,18,opt,name=ID,proto3" json:"ID,omitempty"`
	// URI is a normalized identifier for this repository based on its primary clone
	// URL. E.g., "github.com/user/repo".
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	// Owner is the repository owner (user or organizatin) of the repository. (For
	// example, for "github.com/user/repo", the owner is "user".)
	Owner string `protobuf:"bytes,2,opt,name=Owner,proto3" json:"Owner,omitempty"`
	// Name is the base name (the final path component) of the repository, typically
	// the name of the directory that the repository would be cloned into. (For
	// example, for git://example.com/foo.git, the name is "foo".)
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	// Description is a brief description of the repository.
	Description string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	// HTTPCloneURL is the HTTPS clone URL of the repository (or the HTTP clone URL, if
	// no HTTPS clone URL is available).
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=HTTPCloneURL,proto3" json:"HTTPCloneURL,omitempty"`
	// SSHCloneURL is the SSH clone URL if the repository, if any.
	SSHCloneURL string `protobuf:"bytes,6,opt,name=SSHCloneURL,proto3" json:"SSHCloneURL,omitempty"`
	// HomepageURL is the URL to the repository's homepage, if any.
	HomepageURL string `protobuf:"bytes,7,opt,name=HomepageURL,proto3" json:"HomepageURL,omitempty"`
	// HTMLURL is the URL to the repository's main page on the
	// Sourcegraph server.
	HTMLURL string `protobuf:"bytes,22,opt,name=HTMLURL,proto3" json:"HTMLURL,omitempty"`
	// DefaultBranch is the default git branch used (typically "master").
	DefaultBranch string `protobuf:"bytes,8,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Language is the primary programming language used in this repository.
	Language string `protobuf:"bytes,9,opt,name=Language,proto3" json:"Language,omitempty"`
	// Blocked is whether this repo has been blocked by an admin (and
	// will not be returned via the external API).
	Blocked bool `protobuf:"varint,10,opt,name=Blocked,proto3" json:"Blocked,omitempty"`
	// Deprecated repositories are labeled as such and hidden from global search
	// results.
	Deprecated bool `protobuf:"varint,11,opt,name=Deprecated,proto3" json:"Deprecated,omitempty"`
	// Fork is whether this repository is a fork.
	Fork bool `protobuf:"varint,12,opt,name=Fork,proto3" json:"Fork,omitempty"`
	// Mirror indicates whether this repo's canonical location is on
	// another server. Mirror repos track their upstream. If this repo
	// canonically lives on a repo hosting that can supply additional
	// metadata (such as GitHub), the Origin field should be set.
	Mirror bool `protobuf:"varint,13,opt,name=Mirror,proto3" json:"Mirror,omitempty"`
	// Private is whether this repository is private.
	Private bool `protobuf:"varint,14,opt,name=Private,proto3" json:"Private,omitempty"`
	// CreatedAt is when this repository was created. If it represents an externally
	// hosted (e.g., GitHub) repository, the creation date is when it was created at
	// that origin.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,15,opt,name=CreatedAt" json:"CreatedAt,omitempty"`
	// UpdatedAt is when this repository's metadata was last updated (on its origin if
	// it's an externally hosted repository).
	UpdatedAt *pbtypes.Timestamp `protobuf:"bytes,16,opt,name=UpdatedAt" json:"UpdatedAt,omitempty"`
	// PushedAt is when this repository's was last (VCS-)pushed to.
	PushedAt *pbtypes.Timestamp `protobuf:"bytes,17,opt,name=PushedAt" json:"PushedAt,omitempty"`
	// Origin describes the repo's canonical location. It is only
	// populated for mirror repos; for non-mirror repos, it is null.
	Origin *Origin `protobuf:"bytes,19,opt,name=Origin" json:"Origin,omitempty"`
}

func (m *Repo) Reset()                    { *m = Repo{} }
func (m *Repo) String() string            { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()               {}
func (*Repo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{6} }

type RepoListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty" url:",omitempty"`
	// Specifies a search query for repositories. If specified, then the Sort and
	// Direction options are ignored
	Query       string   `protobuf:"bytes,2,opt,name=Query,proto3" json:"Query,omitempty" url:",omitempty"`
	URIs        []string `protobuf:"bytes,3,rep,name=URIs" json:"URIs,omitempty" url:",comma,omitempty"`
	Sort        string   `protobuf:"bytes,5,opt,name=Sort,proto3" json:"Sort,omitempty" url:",omitempty"`
	Direction   string   `protobuf:"bytes,6,opt,name=Direction,proto3" json:"Direction,omitempty" url:",omitempty"`
	NoFork      bool     `protobuf:"varint,7,opt,name=NoFork,proto3" json:"NoFork,omitempty" url:",omitempty"`
	Type        string   `protobuf:"bytes,8,opt,name=Type,proto3" json:"Type,omitempty" url:",omitempty"`
	Owner       string   `protobuf:"bytes,10,opt,name=Owner,proto3" json:"Owner,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListOptions) Reset()                    { *m = RepoListOptions{} }
func (m *RepoListOptions) String() string            { return proto.CompactTextString(m) }
func (*RepoListOptions) ProtoMessage()               {}
func (*RepoListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{7} }

// RepoRevSpec specifies a repository at a specific commit.
type RepoRevSpec struct {
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// CommitID is the 40-character SHA-1 of the Git commit ID.
	//
	// Revision specifiers are not allowed here. To resolve a revision
	// specifier (such as a branch name or "master~7"), call
	// Repos.GetCommit.
	CommitID string `protobuf:"bytes,2,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
}

func (m *RepoRevSpec) Reset()                    { *m = RepoRevSpec{} }
func (m *RepoRevSpec) String() string            { return proto.CompactTextString(m) }
func (*RepoRevSpec) ProtoMessage()               {}
func (*RepoRevSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{8} }

// RepoSpec specifies a repository.
type RepoSpec struct {
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *RepoSpec) Reset()                    { *m = RepoSpec{} }
func (m *RepoSpec) String() string            { return proto.CompactTextString(m) }
func (*RepoSpec) ProtoMessage()               {}
func (*RepoSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{9} }

// RepoStatus is the status of the repository at a specific rev (in a single
// context).
type RepoStatus struct {
	// State is the current status of the repository. Possible values are: pending,
	// success, error, or failure.
	State string `protobuf:"bytes,2,opt,name=State,proto3" json:"State,omitempty"`
	// TargetURL is the URL of the page representing this status. It will be linked
	// from the UI to allow users to see the source of the status.
	TargetURL string `protobuf:"bytes,3,opt,name=TargetURL,proto3" json:"TargetURL,omitempty"`
	// Description is a short, high-level summary of the status.
	Description string `protobuf:"bytes,4,opt,name=Description,proto3" json:"Description,omitempty"`
	// A string label to differentiate this status from the statuses of other systems.
	Context   string            `protobuf:"bytes,5,opt,name=Context,proto3" json:"Context,omitempty"`
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,6,opt,name=CreatedAt" json:"CreatedAt"`
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,7,opt,name=UpdatedAt" json:"UpdatedAt"`
}

func (m *RepoStatus) Reset()                    { *m = RepoStatus{} }
func (m *RepoStatus) String() string            { return proto.CompactTextString(m) }
func (*RepoStatus) ProtoMessage()               {}
func (*RepoStatus) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{10} }

type RepoStatusList struct {
	RepoStatuses []*RepoStatus `protobuf:"bytes,1,rep,name=RepoStatuses" json:"RepoStatuses,omitempty"`
}

func (m *RepoStatusList) Reset()                    { *m = RepoStatusList{} }
func (m *RepoStatusList) String() string            { return proto.CompactTextString(m) }
func (*RepoStatusList) ProtoMessage()               {}
func (*RepoStatusList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{11} }

type RepoStatusesCreateOp struct {
	Repo   RepoRevSpec `protobuf:"bytes,1,opt,name=Repo" json:"Repo"`
	Status RepoStatus  `protobuf:"bytes,2,opt,name=Status" json:"Status"`
}

func (m *RepoStatusesCreateOp) Reset()                    { *m = RepoStatusesCreateOp{} }
func (m *RepoStatusesCreateOp) String() string            { return proto.CompactTextString(m) }
func (*RepoStatusesCreateOp) ProtoMessage()               {}
func (*RepoStatusesCreateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{12} }

type RepoList struct {
	Repos []*Repo `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *RepoList) Reset()                    { *m = RepoList{} }
func (m *RepoList) String() string            { return proto.CompactTextString(m) }
func (*RepoList) ProtoMessage()               {}
func (*RepoList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{13} }

// ReposResolveRevOp specifies a Repos.ResolveRev operation.
type ReposResolveRevOp struct {
	Repo int32 `protobuf:"varint,1,opt,name=repo,proto3" json:"repo,omitempty"`
	// Rev is a VCS revision specifier, such as a branch or
	// "master~7".
	Rev string `protobuf:"bytes,2,opt,name=rev,proto3" json:"rev,omitempty"`
}

func (m *ReposResolveRevOp) Reset()                    { *m = ReposResolveRevOp{} }
func (m *ReposResolveRevOp) String() string            { return proto.CompactTextString(m) }
func (*ReposResolveRevOp) ProtoMessage()               {}
func (*ReposResolveRevOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{14} }

// ResolvedRev is the result of resolving a VCS revision specifier to
// an absolute commit ID.
type ResolvedRev struct {
	// CommitID is the 40-character absolute SHA-1 hex digest of the
	// commit's Git oid.
	CommitID string `protobuf:"bytes,1,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
}

func (m *ResolvedRev) Reset()                    { *m = ResolvedRev{} }
func (m *ResolvedRev) String() string            { return proto.CompactTextString(m) }
func (*ResolvedRev) ProtoMessage()               {}
func (*ResolvedRev) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{15} }

type ReceivePackOp struct {
	Repo          int32  `protobuf:"varint,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Data          []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	AdvertiseRefs bool   `protobuf:"varint,4,opt,name=advertiseRefs,proto3" json:"advertiseRefs,omitempty"`
}

func (m *ReceivePackOp) Reset()                    { *m = ReceivePackOp{} }
func (m *ReceivePackOp) String() string            { return proto.CompactTextString(m) }
func (*ReceivePackOp) ProtoMessage()               {}
func (*ReceivePackOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{16} }

type UploadPackOp struct {
	Repo          int32  `protobuf:"varint,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Data          []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	AdvertiseRefs bool   `protobuf:"varint,4,opt,name=advertiseRefs,proto3" json:"advertiseRefs,omitempty"`
}

func (m *UploadPackOp) Reset()                    { *m = UploadPackOp{} }
func (m *UploadPackOp) String() string            { return proto.CompactTextString(m) }
func (*UploadPackOp) ProtoMessage()               {}
func (*UploadPackOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{17} }

type Packet struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Packet) Reset()                    { *m = Packet{} }
func (m *Packet) String() string            { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()               {}
func (*Packet) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{18} }

type RepoResolveOp struct {
	// Path is some repo path, such as "github.com/user/repo".
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// Remote controls the behavior when Resolve locates a remote
	// repository that is not (yet) associated with an existing local
	// repository. If Remote is false (the default), then a NotFound
	// error is returned in that case. If Remote is true, then no
	// error is returned; the RepoResolution's Repo field will be
	// empty, but some metadata about the remote repository may be
	// provided.
	Remote bool `protobuf:"varint,2,opt,name=remote,proto3" json:"remote,omitempty"`
}

func (m *RepoResolveOp) Reset()                    { *m = RepoResolveOp{} }
func (m *RepoResolveOp) String() string            { return proto.CompactTextString(m) }
func (*RepoResolveOp) ProtoMessage()               {}
func (*RepoResolveOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{19} }

// RepoResolution is the result of resolving a repo using
// Repos.Resolve.
type RepoResolution struct {
	// ID is the ID of the local repo (either a locally hosted repo,
	// or a locally added mirror).
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// CanonicalPath is the canonical repo path of the local repo
	// (with the canonical casing, etc.). Clients should generally
	// redirect the user to the canonical repo path if users access a
	// repo by a non-canonical path.
	CanonicalPath string `protobuf:"bytes,3,opt,name=CanonicalPath,proto3" json:"CanonicalPath,omitempty"`
	// RemoteRepo holds metadata about the repo that exists on a
	// remote service (such as GitHub).
	RemoteRepo *RemoteRepo `protobuf:"bytes,2,opt,name=RemoteRepo" json:"RemoteRepo,omitempty"`
}

func (m *RepoResolution) Reset()                    { *m = RepoResolution{} }
func (m *RepoResolution) String() string            { return proto.CompactTextString(m) }
func (*RepoResolution) ProtoMessage()               {}
func (*RepoResolution) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{20} }

// ReposListRemoteOptions specifies options for Repos.ListRemote.
type ReposListRemoteOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *ReposListRemoteOptions) Reset()         { *m = ReposListRemoteOptions{} }
func (m *ReposListRemoteOptions) String() string { return proto.CompactTextString(m) }
func (*ReposListRemoteOptions) ProtoMessage()    {}
func (*ReposListRemoteOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{21}
}

// RemoteRepoList is a list of remote repos.
type RemoteRepoList struct {
	RemoteRepos []*RemoteRepo `protobuf:"bytes,1,rep,name=RemoteRepos" json:"RemoteRepos,omitempty"`
}

func (m *RemoteRepoList) Reset()                    { *m = RemoteRepoList{} }
func (m *RemoteRepoList) String() string            { return proto.CompactTextString(m) }
func (*RemoteRepoList) ProtoMessage()               {}
func (*RemoteRepoList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{22} }

// SrclibDataVersion specifies a srclib store version.
type SrclibDataVersion struct {
	CommitID      string `protobuf:"bytes,1,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	CommitsBehind int32  `protobuf:"varint,2,opt,name=CommitsBehind,proto3" json:"CommitsBehind,omitempty"`
}

func (m *SrclibDataVersion) Reset()                    { *m = SrclibDataVersion{} }
func (m *SrclibDataVersion) String() string            { return proto.CompactTextString(m) }
func (*SrclibDataVersion) ProtoMessage()               {}
func (*SrclibDataVersion) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{23} }

type RepoConfigureAppOp struct {
	// Repo is the repository whose applications are being configured.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// App is the app ID to enable or disable.
	App string `protobuf:"bytes,2,opt,name=App,proto3" json:"App,omitempty"`
	// Enable is true if the app should be enabled and false if it
	// should be disabled.
	Enable bool `protobuf:"varint,3,opt,name=Enable,proto3" json:"Enable,omitempty"`
}

func (m *RepoConfigureAppOp) Reset()                    { *m = RepoConfigureAppOp{} }
func (m *RepoConfigureAppOp) String() string            { return proto.CompactTextString(m) }
func (*RepoConfigureAppOp) ProtoMessage()               {}
func (*RepoConfigureAppOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{24} }

type ReposCreateOp struct {
	// Types that are valid to be assigned to Op:
	//	*ReposCreateOp_New
	//	*ReposCreateOp_FromGitHubID
	//	*ReposCreateOp_Origin
	Op isReposCreateOp_Op `protobuf_oneof:"Op"`
}

func (m *ReposCreateOp) Reset()                    { *m = ReposCreateOp{} }
func (m *ReposCreateOp) String() string            { return proto.CompactTextString(m) }
func (*ReposCreateOp) ProtoMessage()               {}
func (*ReposCreateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{25} }

type isReposCreateOp_Op interface {
	isReposCreateOp_Op()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReposCreateOp_New struct {
	New *ReposCreateOp_NewRepo `protobuf:"bytes,1,opt,name=New,oneof"`
}
type ReposCreateOp_FromGitHubID struct {
	FromGitHubID int32 `protobuf:"varint,2,opt,name=FromGitHubID,proto3,oneof"`
}
type ReposCreateOp_Origin struct {
	Origin *Origin `protobuf:"bytes,3,opt,name=Origin,oneof"`
}

func (*ReposCreateOp_New) isReposCreateOp_Op()          {}
func (*ReposCreateOp_FromGitHubID) isReposCreateOp_Op() {}
func (*ReposCreateOp_Origin) isReposCreateOp_Op()       {}

func (m *ReposCreateOp) GetOp() isReposCreateOp_Op {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *ReposCreateOp) GetNew() *ReposCreateOp_NewRepo {
	if x, ok := m.GetOp().(*ReposCreateOp_New); ok {
		return x.New
	}
	return nil
}

func (m *ReposCreateOp) GetFromGitHubID() int32 {
	if x, ok := m.GetOp().(*ReposCreateOp_FromGitHubID); ok {
		return x.FromGitHubID
	}
	return 0
}

func (m *ReposCreateOp) GetOrigin() *Origin {
	if x, ok := m.GetOp().(*ReposCreateOp_Origin); ok {
		return x.Origin
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ReposCreateOp) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ReposCreateOp_OneofMarshaler, _ReposCreateOp_OneofUnmarshaler, _ReposCreateOp_OneofSizer, []interface{}{
		(*ReposCreateOp_New)(nil),
		(*ReposCreateOp_FromGitHubID)(nil),
		(*ReposCreateOp_Origin)(nil),
	}
}

func _ReposCreateOp_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ReposCreateOp)
	// Op
	switch x := m.Op.(type) {
	case *ReposCreateOp_New:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.New); err != nil {
			return err
		}
	case *ReposCreateOp_FromGitHubID:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.FromGitHubID))
	case *ReposCreateOp_Origin:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Origin); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ReposCreateOp.Op has unexpected type %T", x)
	}
	return nil
}

func _ReposCreateOp_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ReposCreateOp)
	switch tag {
	case 1: // Op.New
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReposCreateOp_NewRepo)
		err := b.DecodeMessage(msg)
		m.Op = &ReposCreateOp_New{msg}
		return true, err
	case 2: // Op.FromGitHubID
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Op = &ReposCreateOp_FromGitHubID{int32(x)}
		return true, err
	case 3: // Op.Origin
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Origin)
		err := b.DecodeMessage(msg)
		m.Op = &ReposCreateOp_Origin{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ReposCreateOp_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ReposCreateOp)
	// Op
	switch x := m.Op.(type) {
	case *ReposCreateOp_New:
		s := proto.Size(x.New)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ReposCreateOp_FromGitHubID:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.FromGitHubID))
	case *ReposCreateOp_Origin:
		s := proto.Size(x.Origin)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ReposCreateOp_NewRepo struct {
	// URI is the desired URI of the new repository.
	URI string `protobuf:"bytes,1,opt,name=URI,proto3" json:"URI,omitempty"`
	// CloneURL is the clone URL of the repository for mirrored
	// repositories. If blank, a new hosted repository is created
	// (i.e., a repo whose origin is on the server). If Mirror is
	// true, a clone URL must be provided.
	CloneURL string `protobuf:"bytes,3,opt,name=CloneURL,proto3" json:"CloneURL,omitempty"`
	// DefaultBranch is the repository's default Git branch.
	DefaultBranch string `protobuf:"bytes,4,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Mirror is a boolean value indicating whether the newly created
	// repository should be a mirror. Mirror repositories are
	// periodically updated to track their upstream (which is
	// specified using the CloneURL field of this message).
	Mirror bool `protobuf:"varint,5,opt,name=Mirror,proto3" json:"Mirror,omitempty"`
	// Description is the description of the repository.
	Description string `protobuf:"bytes,6,opt,name=Description,proto3" json:"Description,omitempty"`
	// Language is the primary programming language of the repository.
	Language string `protobuf:"bytes,7,opt,name=Language,proto3" json:"Language,omitempty"`
}

func (m *ReposCreateOp_NewRepo) Reset()         { *m = ReposCreateOp_NewRepo{} }
func (m *ReposCreateOp_NewRepo) String() string { return proto.CompactTextString(m) }
func (*ReposCreateOp_NewRepo) ProtoMessage()    {}
func (*ReposCreateOp_NewRepo) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{25, 0}
}

// ReposUpdateOp is an operation to update a repository's metadata.
type ReposUpdateOp struct {
	// Repo is the repository to update.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// Description is the new description of the repository. If empty,
	// the description is not changed.
	Description string `protobuf:"bytes,2,opt,name=Description,proto3" json:"Description,omitempty"`
	// Language is the new primary programming language of the
	// repository. If empty, the language is not changed.
	Language string `protobuf:"bytes,3,opt,name=Language,proto3" json:"Language,omitempty"`
	// DefaultBranch is the repo's new default branch.
	DefaultBranch string `protobuf:"bytes,6,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Fork is whether this repository is a fork.
	Fork ReposUpdateOp_BoolType `protobuf:"varint,7,opt,name=Fork,proto3,enum=sourcegraph.ReposUpdateOp_BoolType" json:"Fork,omitempty"`
	// Private is whether this repository is private.
	Private ReposUpdateOp_BoolType `protobuf:"varint,8,opt,name=Private,proto3,enum=sourcegraph.ReposUpdateOp_BoolType" json:"Private,omitempty"`
}

func (m *ReposUpdateOp) Reset()                    { *m = ReposUpdateOp{} }
func (m *ReposUpdateOp) String() string            { return proto.CompactTextString(m) }
func (*ReposUpdateOp) ProtoMessage()               {}
func (*ReposUpdateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{26} }

type ReposListCommitsOp struct {
	Repo int32                   `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListCommitsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListCommitsOp) Reset()                    { *m = ReposListCommitsOp{} }
func (m *ReposListCommitsOp) String() string            { return proto.CompactTextString(m) }
func (*ReposListCommitsOp) ProtoMessage()               {}
func (*ReposListCommitsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{27} }

type RepoListCommitsOptions struct {
	Head        string `protobuf:"bytes,1,opt,name=Head,proto3" json:"Head,omitempty" url:",omitempty"`
	Base        string `protobuf:"bytes,2,opt,name=Base,proto3" json:"Base,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
	Path        string `protobuf:"bytes,4,opt,name=Path,proto3" json:"Path,omitempty" url:",omitempty"`
}

func (m *RepoListCommitsOptions) Reset()         { *m = RepoListCommitsOptions{} }
func (m *RepoListCommitsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommitsOptions) ProtoMessage()    {}
func (*RepoListCommitsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{28}
}

type CommitList struct {
	Commits        []*vcs.Commit `protobuf:"bytes,1,rep,name=Commits" json:"Commits,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *CommitList) Reset()                    { *m = CommitList{} }
func (m *CommitList) String() string            { return proto.CompactTextString(m) }
func (*CommitList) ProtoMessage()               {}
func (*CommitList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{29} }

type ReposListBranchesOp struct {
	Repo int32                    `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListBranchesOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListBranchesOp) Reset()                    { *m = ReposListBranchesOp{} }
func (m *ReposListBranchesOp) String() string            { return proto.CompactTextString(m) }
func (*ReposListBranchesOp) ProtoMessage()               {}
func (*ReposListBranchesOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{30} }

type RepoListBranchesOptions struct {
	IncludeCommit     bool   `protobuf:"varint,4,opt,name=IncludeCommit,proto3" json:"IncludeCommit,omitempty"`
	BehindAheadBranch string `protobuf:"bytes,5,opt,name=BehindAheadBranch,proto3" json:"BehindAheadBranch,omitempty"`
	ContainsCommit    string `protobuf:"bytes,6,opt,name=ContainsCommit,proto3" json:"ContainsCommit,omitempty"`
	ListOptions       `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListBranchesOptions) Reset()         { *m = RepoListBranchesOptions{} }
func (m *RepoListBranchesOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListBranchesOptions) ProtoMessage()    {}
func (*RepoListBranchesOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{31}
}

type BranchList struct {
	Branches       []*vcs.Branch `protobuf:"bytes,1,rep,name=Branches" json:"Branches,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *BranchList) Reset()                    { *m = BranchList{} }
func (m *BranchList) String() string            { return proto.CompactTextString(m) }
func (*BranchList) ProtoMessage()               {}
func (*BranchList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{32} }

type ReposListTagsOp struct {
	Repo int32                `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListTagsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListTagsOp) Reset()                    { *m = ReposListTagsOp{} }
func (m *ReposListTagsOp) String() string            { return proto.CompactTextString(m) }
func (*ReposListTagsOp) ProtoMessage()               {}
func (*ReposListTagsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{33} }

type ReposListCommittersOp struct {
	Repo int32                      `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	Opt  *RepoListCommittersOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *ReposListCommittersOp) Reset()         { *m = ReposListCommittersOp{} }
func (m *ReposListCommittersOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommittersOp) ProtoMessage()    {}
func (*ReposListCommittersOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{34}
}

type RepoListCommittersOptions struct {
	Rev         string `protobuf:"bytes,1,opt,name=Rev,proto3" json:"Rev,omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListCommittersOptions) Reset()         { *m = RepoListCommittersOptions{} }
func (m *RepoListCommittersOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommittersOptions) ProtoMessage()    {}
func (*RepoListCommittersOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{35}
}

type CommitterList struct {
	Committers     []*vcs.Committer `protobuf:"bytes,1,rep,name=Committers" json:"Committers,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *CommitterList) Reset()                    { *m = CommitterList{} }
func (m *CommitterList) String() string            { return proto.CompactTextString(m) }
func (*CommitterList) ProtoMessage()               {}
func (*CommitterList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{36} }

type RepoListTagsOptions struct {
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *RepoListTagsOptions) Reset()                    { *m = RepoListTagsOptions{} }
func (m *RepoListTagsOptions) String() string            { return proto.CompactTextString(m) }
func (*RepoListTagsOptions) ProtoMessage()               {}
func (*RepoListTagsOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{37} }

type TagList struct {
	Tags           []*vcs.Tag `protobuf:"bytes,1,rep,name=Tags" json:"Tags,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *TagList) Reset()                    { *m = TagList{} }
func (m *TagList) String() string            { return proto.CompactTextString(m) }
func (*TagList) ProtoMessage()               {}
func (*TagList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{38} }

type MirrorReposRefreshVCSOp struct {
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// AsUser is the user whose auth token will be used for refreshing this
	// mirror repo. This can be used when refreshing a private repo mirror.
	AsUser *UserSpec `protobuf:"bytes,3,opt,name=AsUser" json:"AsUser,omitempty"`
}

func (m *MirrorReposRefreshVCSOp) Reset()         { *m = MirrorReposRefreshVCSOp{} }
func (m *MirrorReposRefreshVCSOp) String() string { return proto.CompactTextString(m) }
func (*MirrorReposRefreshVCSOp) ProtoMessage()    {}
func (*MirrorReposRefreshVCSOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{39}
}

// VCSCredentials for authentication during communication with VCS remotes.
type VCSCredentials struct {
	// Pass is the password provided to the VCS.
	Pass string `protobuf:"bytes,1,opt,name=Pass,proto3" json:"Pass,omitempty"`
}

func (m *VCSCredentials) Reset()                    { *m = VCSCredentials{} }
func (m *VCSCredentials) String() string            { return proto.CompactTextString(m) }
func (*VCSCredentials) ProtoMessage()               {}
func (*VCSCredentials) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{40} }

// RemoteRepo is a repo canonically stored on an external host, and
// possibly mirrored on the local instance.
type RemoteRepo struct {
	// GitHubID is the repo's GitHub repository ID.
	GitHubID int32 `protobuf:"varint,1,opt,name=GitHubID,proto3" json:"GitHubID,omitempty"`
	// Owner is the login or org name of the repo's owner ("foo" in
	// github.com/foo/bar).
	Owner string `protobuf:"bytes,2,opt,name=Owner,proto3" json:"Owner,omitempty"`
	// OwnerIsOrg is true if the repo's owner is an org (not a user).
	OwnerIsOrg bool `protobuf:"varint,15,opt,name=OwnerIsOrg,proto3" json:"OwnerIsOrg,omitempty"`
	// Name is the repo's name ("bar" in github.com/foo/bar).
	Name string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	// VCS is "git".
	VCS string `protobuf:"bytes,4,opt,name=VCS,proto3" json:"VCS,omitempty"`
	// CloneURL is the repo's HTTP (preferably HTTPS) clone URL.
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=HTTPCloneURL,proto3" json:"HTTPCloneURL,omitempty"`
	// DefaultBranch is the default Git branch for the repo.
	DefaultBranch string `protobuf:"bytes,6,opt,name=DefaultBranch,proto3" json:"DefaultBranch,omitempty"`
	// Description is the repo's description from GitHub.
	Description string `protobuf:"bytes,7,opt,name=Description,proto3" json:"Description,omitempty"`
	// Language is the repo's primary programming language, as
	// reported by GitHub.
	Language string `protobuf:"bytes,8,opt,name=Language,proto3" json:"Language,omitempty"`
	// UpdatedAt is the date of the most recent update (push or
	// metadata edit) to the repo on GitHub.
	UpdatedAt *pbtypes.Timestamp `protobuf:"bytes,9,opt,name=UpdatedAt" json:"UpdatedAt,omitempty"`
	// PushedAt is the date of the most recent git push to the repo.
	PushedAt *pbtypes.Timestamp `protobuf:"bytes,14,opt,name=PushedAt" json:"PushedAt,omitempty"`
	// Private is true for private repos.
	Private bool `protobuf:"varint,10,opt,name=Private,proto3" json:"Private,omitempty"`
	// Fork is true for repos that were forked from another repo using
	// GitHub's "fork" operation.
	Fork bool `protobuf:"varint,11,opt,name=Fork,proto3" json:"Fork,omitempty"`
	// Mirror is true for mirror repos (e.g., Apache Foundation
	// open-source repo mirrors on GitHub.com).
	Mirror bool `protobuf:"varint,12,opt,name=Mirror,proto3" json:"Mirror,omitempty"`
	// Stars is the number of stargazers of the GitHub repo.
	Stars int32 `protobuf:"varint,13,opt,name=Stars,proto3" json:"Stars,omitempty"`
}

func (m *RemoteRepo) Reset()                    { *m = RemoteRepo{} }
func (m *RemoteRepo) String() string            { return proto.CompactTextString(m) }
func (*RemoteRepo) ProtoMessage()               {}
func (*RemoteRepo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{41} }

// A Build represents a scheduled, completed, or failed repository analysis and
// import job.
//
// A build is composed of many tasks. The worker that is responsible for a build or
// task determines whether a task failure causes the whole build to fail. (Keep
// reading to see how we determine who is responsible for a build or task.) There
// is no single kind of worker; currently there are 2 things that could be
// considered workers because they build builds or perform tasks: the builders on
// Sourcegraph.com, and anyone who runs `src push` locally.
//
// Each task has logs associated with it, and each task can be associated with a
// single source unit (or not).
//
// Builds have a Queue bool field. If a process creates a build that
// has Queue=true, that means that it relinquishes responsibility for
// it; some other queue workers (on the server, for example) will
// dequeue and complete it. If Queue=false, then the process that
// created it is responsible for completing it. The only exception to
// this is that after a certain timeout (on the order of 45 minutes),
// started but unfinished builds are marked as failed.
//
// Builds and tasks are simple "build"ing blocks (no pun intended) with simple
// behavior. As we encounter new requirements for the build system, they may
// evolve.
type Build struct {
	// Repo is the repository this build is for.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// ID is the numeric ID of the build. It is up to the
	// implementation to decide whether it is sequential within the
	// repo or globally unique across all repos.
	ID uint64 `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
	// CommitID is the full resolved commit ID to build.
	CommitID string `protobuf:"bytes,3,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	// Branch, if set, is the name of the VCS branch on which this
	// commit was built. Commits may be configured to be built in
	// different ways depending on the branch the build was started on
	// (e.g., a release branch may trigger additional deployment
	// actions). A single commit can exist on any number of branches.
	//
	// A build is recommended to be associated with either a branch or
	// a tag because it is not generally possible to fetch a specific
	// commit from a Git repository; you can only fetch a refspec
	// (branch, tag, etc.). During CI we want to avoid needing to
	// clone *all* branches just to find the specific commit we
	// need. If the branch or tag is specified, we can do a fetch of a
	// specific refspec; otherwise we need to fetch all branches,
	// which makes CI much slower. And Git servers do not let you
	// request a single commit (although this is changing; see
	// http://stackoverflow.com/a/30701724, but it is still disabled
	// by default for apparently good reasons).
	Branch string `protobuf:"bytes,14,opt,name=Branch,proto3" json:"Branch,omitempty"`
	// Tag, if set, is the name of the VCS tag associated with this
	// commit. See Branch for more information. A single commit can
	// have any number of tags.
	Tag         string             `protobuf:"bytes,15,opt,name=Tag,proto3" json:"Tag,omitempty"`
	CreatedAt   pbtypes.Timestamp  `protobuf:"bytes,4,opt,name=CreatedAt" json:"CreatedAt"`
	StartedAt   *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=StartedAt" json:"StartedAt,omitempty"`
	EndedAt     *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=EndedAt" json:"EndedAt,omitempty"`
	HeartbeatAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=HeartbeatAt" json:"HeartbeatAt,omitempty"`
	Success     bool               `protobuf:"varint,8,opt,name=Success,proto3" json:"Success,omitempty"`
	Failure     bool               `protobuf:"varint,9,opt,name=Failure,proto3" json:"Failure,omitempty"`
	// Killed is true if this build's worker didn't exit on its own accord. It is
	// generally set when no heartbeat has been received within a certain interval. If
	// Killed is true, then Failure must also always be set to true. Unqueued builds
	// are never killed for lack of a heartbeat.
	Killed bool `protobuf:"varint,10,opt,name=Killed,proto3" json:"Killed,omitempty"`
	// Host is the hostname of the machine that is working on this build.
	Host        string `protobuf:"bytes,11,opt,name=Host,proto3" json:"Host,omitempty"`
	Purged      bool   `protobuf:"varint,12,opt,name=Purged,proto3" json:"Purged,omitempty"`
	BuildConfig `protobuf:"bytes,13,opt,name=BuildConfig,embedded=BuildConfig" json:""`
}

func (m *Build) Reset()                    { *m = Build{} }
func (m *Build) String() string            { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()               {}
func (*Build) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{42} }

// BuildConfig configures a repository build.
type BuildConfig struct {
	// Queue is whether this build should be enqueued. If enqueued, any worker may
	// begin running this build. If not enqueued, it is up to the client to run the
	// build and update it accordingly.
	Queue bool `protobuf:"varint,2,opt,name=Queue,proto3" json:"Queue,omitempty"`
	// Priority of the build in the queue (higher numbers mean the build is dequeued
	// sooner).
	Priority int32 `protobuf:"varint,4,opt,name=Priority,proto3" json:"Priority,omitempty"`
	// BuilderConfig is the actual .drone.yml config file that was
	// used to run this build in CI. It reflects all automatic
	// additions/changes made by the worker (i.e., it is not
	// necessarily the same .drone.yml config file as the one in the
	// repository).
	BuilderConfig string `protobuf:"bytes,16,opt,name=BuilderConfig,proto3" json:"BuilderConfig,omitempty"`
}

func (m *BuildConfig) Reset()                    { *m = BuildConfig{} }
func (m *BuildConfig) String() string            { return proto.CompactTextString(m) }
func (*BuildConfig) ProtoMessage()               {}
func (*BuildConfig) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{43} }

type BuildJob struct {
	// Spec is the BuildSpec of the referenced build.
	Spec BuildSpec `protobuf:"bytes,1,opt,name=Spec" json:"Spec"`
	// CommitID is the full resolved commit ID to build.
	CommitID string `protobuf:"bytes,3,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	// Branch, if set, is the name of the VCS branch on which this
	// commit was built. See Build.Branch.
	Branch string `protobuf:"bytes,14,opt,name=Branch,proto3" json:"Branch,omitempty"`
	// Tag, if set, is the name of the VCS tag associated with this
	// commit. See Branch for more information. A single commit can
	// have any number of tags.
	Tag string `protobuf:"bytes,15,opt,name=Tag,proto3" json:"Tag,omitempty"`
	// AccessToken is a token that has write access to the repository being built.
	AccessToken string `protobuf:"bytes,16,opt,name=AccessToken,proto3" json:"AccessToken,omitempty"`
}

func (m *BuildJob) Reset()                    { *m = BuildJob{} }
func (m *BuildJob) String() string            { return proto.CompactTextString(m) }
func (*BuildJob) ProtoMessage()               {}
func (*BuildJob) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{44} }

// BuildGetLogOptions specifies options for build log API methods.
type BuildGetLogOptions struct {
	// MinID indicates that only log entries whose monotonically increasing ID is
	// greater than MinID should be returned.
	//
	// To "tail -f" or watch a log for updates, set each subsequent request's MinID to
	// the MaxID of the previous request.
	MinID string `protobuf:"bytes,1,opt,name=MinID,proto3" json:"MinID,omitempty"`
}

func (m *BuildGetLogOptions) Reset()                    { *m = BuildGetLogOptions{} }
func (m *BuildGetLogOptions) String() string            { return proto.CompactTextString(m) }
func (*BuildGetLogOptions) ProtoMessage()               {}
func (*BuildGetLogOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{45} }

type BuildListOptions struct {
	Queued      bool   `protobuf:"varint,1,opt,name=Queued,proto3" json:"Queued,omitempty" url:",omitempty"`
	Active      bool   `protobuf:"varint,2,opt,name=Active,proto3" json:"Active,omitempty" url:",omitempty"`
	Ended       bool   `protobuf:"varint,3,opt,name=Ended,proto3" json:"Ended,omitempty" url:",omitempty"`
	Succeeded   bool   `protobuf:"varint,4,opt,name=Succeeded,proto3" json:"Succeeded,omitempty" url:",omitempty"`
	Failed      bool   `protobuf:"varint,5,opt,name=Failed,proto3" json:"Failed,omitempty" url:",omitempty"`
	Purged      bool   `protobuf:"varint,6,opt,name=Purged,proto3" json:"Purged,omitempty" url:",omitempty"`
	Repo        int32  `protobuf:"varint,7,opt,name=Repo,proto3" json:"Repo,omitempty" url:",omitempty"`
	CommitID    string `protobuf:"bytes,8,opt,name=CommitID,proto3" json:"CommitID,omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,9,opt,name=Sort,proto3" json:"Sort,omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,10,opt,name=Direction,proto3" json:"Direction,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *BuildListOptions) Reset()                    { *m = BuildListOptions{} }
func (m *BuildListOptions) String() string            { return proto.CompactTextString(m) }
func (*BuildListOptions) ProtoMessage()               {}
func (*BuildListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{46} }

// A BuildSpec uniquely identifies a build.
type BuildSpec struct {
	// Repo is the repository associated with the build.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// ID is the numeric ID of the build. It is up to the
	// implementation to decide whether it is sequential within the
	// repo or globally unique across all repos' builds.
	ID uint64 `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *BuildSpec) Reset()                    { *m = BuildSpec{} }
func (m *BuildSpec) String() string            { return proto.CompactTextString(m) }
func (*BuildSpec) ProtoMessage()               {}
func (*BuildSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{47} }

// A BuildTask represents an individual step of a build.
//
// See the documentation for Build for more information about how builds and tasks
// relate to each other.
type BuildTask struct {
	// ID is the numeric ID of the task. It is up to the
	// implementation to decide whether it is sequential within the
	// build or globally unique across all builds.
	ID uint64 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Build specifies the build associated with this task.
	Build BuildSpec `protobuf:"bytes,2,opt,name=Build" json:"Build"`
	// ParentID, if non-zero, indicates that this task's parent is the
	// task (in the same build) with the given ID. A ParentID of zero
	// means that this is a top-level task.
	ParentID uint64 `protobuf:"varint,3,opt,name=ParentID,proto3" json:"ParentID,omitempty"`
	// Label describes the task (e.g., "Go build").
	Label string `protobuf:"bytes,4,opt,name=Label,proto3" json:"Label,omitempty"`
	// CreatedAt is when this task was initially created.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,5,opt,name=CreatedAt" json:"CreatedAt"`
	// StartedAt is when this task's execution began.
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=StartedAt" json:"StartedAt,omitempty"`
	// EndedAt is when this task's execution ended (whether because it succeeded or
	// failed).
	EndedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=EndedAt" json:"EndedAt,omitempty"`
	// Success is whether this task's execution succeeded.
	Success bool `protobuf:"varint,8,opt,name=Success,proto3" json:"Success,omitempty"`
	// Failure is whether this task's execution failed.
	Failure bool `protobuf:"varint,9,opt,name=Failure,proto3" json:"Failure,omitempty"`
	// Skipped is whether this task's execution was skipped.
	Skipped bool `protobuf:"varint,10,opt,name=Skipped,proto3" json:"Skipped,omitempty"`
	// Warnings is whether this task produced warnings. Tasks with
	// warnings are not displayed as "green". The warnings are
	// contained in the task logs.
	Warnings bool `protobuf:"varint,11,opt,name=Warnings,proto3" json:"Warnings,omitempty"`
}

func (m *BuildTask) Reset()                    { *m = BuildTask{} }
func (m *BuildTask) String() string            { return proto.CompactTextString(m) }
func (*BuildTask) ProtoMessage()               {}
func (*BuildTask) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{48} }

type BuildTaskListOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *BuildTaskListOptions) Reset()                    { *m = BuildTaskListOptions{} }
func (m *BuildTaskListOptions) String() string            { return proto.CompactTextString(m) }
func (*BuildTaskListOptions) ProtoMessage()               {}
func (*BuildTaskListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{49} }

// A BuildUpdate contains updated information to update on an existing build.
type BuildUpdate struct {
	StartedAt     *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=StartedAt" json:"StartedAt,omitempty"`
	EndedAt       *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=EndedAt" json:"EndedAt,omitempty"`
	HeartbeatAt   *pbtypes.Timestamp `protobuf:"bytes,3,opt,name=HeartbeatAt" json:"HeartbeatAt,omitempty"`
	Host          string             `protobuf:"bytes,4,opt,name=Host,proto3" json:"Host,omitempty"`
	Success       bool               `protobuf:"varint,5,opt,name=Success,proto3" json:"Success,omitempty"`
	Purged        bool               `protobuf:"varint,6,opt,name=Purged,proto3" json:"Purged,omitempty"`
	Failure       bool               `protobuf:"varint,7,opt,name=Failure,proto3" json:"Failure,omitempty"`
	Killed        bool               `protobuf:"varint,8,opt,name=Killed,proto3" json:"Killed,omitempty"`
	Priority      int32              `protobuf:"varint,9,opt,name=Priority,proto3" json:"Priority,omitempty"`
	BuilderConfig string             `protobuf:"bytes,10,opt,name=BuilderConfig,proto3" json:"BuilderConfig,omitempty"`
	FileScore     float32            `protobuf:"fixed32,11,opt,name=FileScore,proto3" json:"FileScore,omitempty"`
	RefScore      float32            `protobuf:"fixed32,12,opt,name=RefScore,proto3" json:"RefScore,omitempty"`
	TokDensity    float32            `protobuf:"fixed32,13,opt,name=TokDensity,proto3" json:"TokDensity,omitempty"`
}

func (m *BuildUpdate) Reset()                    { *m = BuildUpdate{} }
func (m *BuildUpdate) String() string            { return proto.CompactTextString(m) }
func (*BuildUpdate) ProtoMessage()               {}
func (*BuildUpdate) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{50} }

type BuildList struct {
	Builds         []*Build `protobuf:"bytes,1,rep,name=Builds" json:"Builds,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *BuildList) Reset()                    { *m = BuildList{} }
func (m *BuildList) String() string            { return proto.CompactTextString(m) }
func (*BuildList) ProtoMessage()               {}
func (*BuildList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{51} }

type BuildsCreateOp struct {
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// CommitID is the full commit ID of the commit to build. It is
	// required.
	CommitID string `protobuf:"bytes,2,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	// Branch, if specified, indicates that this build's commit is on
	// the given branch. If Branch is set, Tag must be empty.
	Branch string `protobuf:"bytes,3,opt,name=Branch,proto3" json:"Branch,omitempty"`
	// Tag, if specified, indicates that this build's commit has the
	// given tag. If Tag is set, Branch must be empty.
	Tag    string      `protobuf:"bytes,4,opt,name=Tag,proto3" json:"Tag,omitempty"`
	Config BuildConfig `protobuf:"bytes,5,opt,name=Config" json:"Config"`
}

func (m *BuildsCreateOp) Reset()                    { *m = BuildsCreateOp{} }
func (m *BuildsCreateOp) String() string            { return proto.CompactTextString(m) }
func (*BuildsCreateOp) ProtoMessage()               {}
func (*BuildsCreateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{52} }

type BuildsUpdateOp struct {
	Build BuildSpec   `protobuf:"bytes,1,opt,name=Build" json:"Build"`
	Info  BuildUpdate `protobuf:"bytes,2,opt,name=Info" json:"Info"`
}

func (m *BuildsUpdateOp) Reset()                    { *m = BuildsUpdateOp{} }
func (m *BuildsUpdateOp) String() string            { return proto.CompactTextString(m) }
func (*BuildsUpdateOp) ProtoMessage()               {}
func (*BuildsUpdateOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{53} }

type BuildsListBuildTasksOp struct {
	Build BuildSpec             `protobuf:"bytes,1,opt,name=Build" json:"Build"`
	Opt   *BuildTaskListOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *BuildsListBuildTasksOp) Reset()         { *m = BuildsListBuildTasksOp{} }
func (m *BuildsListBuildTasksOp) String() string { return proto.CompactTextString(m) }
func (*BuildsListBuildTasksOp) ProtoMessage()    {}
func (*BuildsListBuildTasksOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{54}
}

type BuildTaskList struct {
	BuildTasks []*BuildTask `protobuf:"bytes,1,rep,name=BuildTasks" json:"BuildTasks,omitempty"`
}

func (m *BuildTaskList) Reset()                    { *m = BuildTaskList{} }
func (m *BuildTaskList) String() string            { return proto.CompactTextString(m) }
func (*BuildTaskList) ProtoMessage()               {}
func (*BuildTaskList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{55} }

type BuildsCreateTasksOp struct {
	Build BuildSpec    `protobuf:"bytes,1,opt,name=Build" json:"Build"`
	Tasks []*BuildTask `protobuf:"bytes,2,rep,name=Tasks" json:"Tasks,omitempty"`
}

func (m *BuildsCreateTasksOp) Reset()                    { *m = BuildsCreateTasksOp{} }
func (m *BuildsCreateTasksOp) String() string            { return proto.CompactTextString(m) }
func (*BuildsCreateTasksOp) ProtoMessage()               {}
func (*BuildsCreateTasksOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{56} }

type BuildsUpdateTaskOp struct {
	Task TaskSpec   `protobuf:"bytes,1,opt,name=Task" json:"Task"`
	Info TaskUpdate `protobuf:"bytes,2,opt,name=Info" json:"Info"`
}

func (m *BuildsUpdateTaskOp) Reset()                    { *m = BuildsUpdateTaskOp{} }
func (m *BuildsUpdateTaskOp) String() string            { return proto.CompactTextString(m) }
func (*BuildsUpdateTaskOp) ProtoMessage()               {}
func (*BuildsUpdateTaskOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{57} }

type BuildsGetTaskLogOp struct {
	Task TaskSpec            `protobuf:"bytes,1,opt,name=Task" json:"Task"`
	Opt  *BuildGetLogOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *BuildsGetTaskLogOp) Reset()                    { *m = BuildsGetTaskLogOp{} }
func (m *BuildsGetTaskLogOp) String() string            { return proto.CompactTextString(m) }
func (*BuildsGetTaskLogOp) ProtoMessage()               {}
func (*BuildsGetTaskLogOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{58} }

type BuildsDequeueNextOp struct {
}

func (m *BuildsDequeueNextOp) Reset()                    { *m = BuildsDequeueNextOp{} }
func (m *BuildsDequeueNextOp) String() string            { return proto.CompactTextString(m) }
func (*BuildsDequeueNextOp) ProtoMessage()               {}
func (*BuildsDequeueNextOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{59} }

// EmailAddr is an email address associated with a user.
type EmailAddr struct {
	// the email address (case-insensitively compared in the DB and API)
	Email string `protobuf:"bytes,1,opt,name=Email,proto3" json:"Email,omitempty"`
	// whether this email address has been verified
	Verified bool `protobuf:"varint,2,opt,name=Verified,proto3" json:"Verified,omitempty"`
	// indicates this is the user's primary email (only 1 email can be primary per user)
	Primary bool `protobuf:"varint,3,opt,name=Primary,proto3" json:"Primary,omitempty"`
	// whether Sourcegraph inferred via public data that this is an email for the user
	Guessed bool `protobuf:"varint,4,opt,name=Guessed,proto3" json:"Guessed,omitempty"`
	// indicates that this email should not be associated with the user (even if guessed in the future)
	Blacklisted bool `protobuf:"varint,5,opt,name=Blacklisted,proto3" json:"Blacklisted,omitempty"`
}

func (m *EmailAddr) Reset()                    { *m = EmailAddr{} }
func (m *EmailAddr) String() string            { return proto.CompactTextString(m) }
func (*EmailAddr) ProtoMessage()               {}
func (*EmailAddr) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{60} }

type LogEntries struct {
	MaxID   string   `protobuf:"bytes,1,opt,name=MaxID,proto3" json:"MaxID,omitempty"`
	Entries []string `protobuf:"bytes,2,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *LogEntries) Reset()                    { *m = LogEntries{} }
func (m *LogEntries) String() string            { return proto.CompactTextString(m) }
func (*LogEntries) ProtoMessage()               {}
func (*LogEntries) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{61} }

type Org struct {
	User `protobuf:"bytes,1,opt,name=User,embedded=User" json:""`
}

func (m *Org) Reset()                    { *m = Org{} }
func (m *Org) String() string            { return proto.CompactTextString(m) }
func (*Org) ProtoMessage()               {}
func (*Org) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{62} }

type OrgListMembersOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *OrgListMembersOptions) Reset()         { *m = OrgListMembersOptions{} }
func (m *OrgListMembersOptions) String() string { return proto.CompactTextString(m) }
func (*OrgListMembersOptions) ProtoMessage()    {}
func (*OrgListMembersOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{63}
}

// OrgSpec specifies an organization. At least one of Email, Login, and UID must be
// nonempty.
type OrgSpec struct {
	Org string `protobuf:"bytes,1,opt,name=Org,proto3" json:"Org,omitempty"`
	UID int32  `protobuf:"varint,2,opt,name=UID,proto3" json:"UID,omitempty"`
}

func (m *OrgSpec) Reset()                    { *m = OrgSpec{} }
func (m *OrgSpec) String() string            { return proto.CompactTextString(m) }
func (*OrgSpec) ProtoMessage()               {}
func (*OrgSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{64} }

type OrgsListMembersOp struct {
	Org OrgSpec                `protobuf:"bytes,1,opt,name=Org" json:"Org"`
	Opt *OrgListMembersOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *OrgsListMembersOp) Reset()                    { *m = OrgsListMembersOp{} }
func (m *OrgsListMembersOp) String() string            { return proto.CompactTextString(m) }
func (*OrgsListMembersOp) ProtoMessage()               {}
func (*OrgsListMembersOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{65} }

type UserList struct {
	Users []*User `protobuf:"bytes,1,rep,name=Users" json:"Users,omitempty"`
}

func (m *UserList) Reset()                    { *m = UserList{} }
func (m *UserList) String() string            { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()               {}
func (*UserList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{66} }

type UserCount struct {
	Count int32 `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *UserCount) Reset()                    { *m = UserCount{} }
func (m *UserCount) String() string            { return proto.CompactTextString(m) }
func (*UserCount) ProtoMessage()               {}
func (*UserCount) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{67} }

// A Person represents either a registered user or a committer to a repository
// (typically when their commit email can't be resolved to a user).
type Person struct {
	// PersonSpec is an identifier for the person. If the person was resolved to a
	// user, then both Login and UID are set. Otherwise only Email is set, and it may
	// be obfuscated (to protect privacy).
	PersonSpec `protobuf:"bytes,1,opt,name=PersonSpec,embedded=PersonSpec" json:""`
	// FullName is the (possibly empty) full name of the person.
	FullName string `protobuf:"bytes,2,opt,name=FullName,proto3" json:"FullName,omitempty"`
	// AvatarURL is the URL to the user's avatar image.
	AvatarURL string `protobuf:"bytes,3,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
}

func (m *Person) Reset()                    { *m = Person{} }
func (m *Person) String() string            { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()               {}
func (*Person) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{68} }

// PersonSpec specifies a person. At least one of Email, Login, and UID must be
// nonempty.
type PersonSpec struct {
	// Email is a person's email address. It may be obfuscated (to protect privacy).
	Email string `protobuf:"bytes,1,opt,name=Email,proto3" json:"Email,omitempty"`
	// Login is a user's login.
	Login string `protobuf:"bytes,2,opt,name=Login,proto3" json:"Login,omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,3,opt,name=UID,proto3" json:"UID,omitempty"`
}

func (m *PersonSpec) Reset()                    { *m = PersonSpec{} }
func (m *PersonSpec) String() string            { return proto.CompactTextString(m) }
func (*PersonSpec) ProtoMessage()               {}
func (*PersonSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{69} }

type TaskSpec struct {
	Build BuildSpec `protobuf:"bytes,1,opt,name=Build" json:"Build"`
	ID    uint64    `protobuf:"varint,2,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *TaskSpec) Reset()                    { *m = TaskSpec{} }
func (m *TaskSpec) String() string            { return proto.CompactTextString(m) }
func (*TaskSpec) ProtoMessage()               {}
func (*TaskSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{70} }

// A TaskUpdate contains updated information to update on an existing task.
type TaskUpdate struct {
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=StartedAt" json:"StartedAt,omitempty"`
	EndedAt   *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=EndedAt" json:"EndedAt,omitempty"`
	Success   bool               `protobuf:"varint,3,opt,name=Success,proto3" json:"Success,omitempty"`
	Failure   bool               `protobuf:"varint,4,opt,name=Failure,proto3" json:"Failure,omitempty"`
	Skipped   bool               `protobuf:"varint,5,opt,name=Skipped,proto3" json:"Skipped,omitempty"`
	Warnings  bool               `protobuf:"varint,6,opt,name=Warnings,proto3" json:"Warnings,omitempty"`
}

func (m *TaskUpdate) Reset()                    { *m = TaskUpdate{} }
func (m *TaskUpdate) String() string            { return proto.CompactTextString(m) }
func (*TaskUpdate) ProtoMessage()               {}
func (*TaskUpdate) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{71} }

// User represents a registered user.
type User struct {
	// UID is the numeric primary key for a user.
	UID int32 `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	// Login is the user's username.
	Login string `protobuf:"bytes,2,opt,name=Login,proto3" json:"Login,omitempty"`
	// Name is the (possibly empty) full name of the user.
	Name string `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	// IsOrganization is whether this user represents an organization.
	IsOrganization bool `protobuf:"varint,5,opt,name=IsOrganization,proto3" json:"IsOrganization,omitempty"`
	// AvatarURL is the URL to an avatar image specified by the user.
	AvatarURL string `protobuf:"bytes,6,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
	// Location is the user's physical location.
	Location string `protobuf:"bytes,7,opt,name=Location,proto3" json:"Location,omitempty"`
	// Company is the user's company.
	Company string `protobuf:"bytes,8,opt,name=Company,proto3" json:"Company,omitempty"`
	// HomepageURL is the user's homepage or blog URL.
	HomepageURL string `protobuf:"bytes,9,opt,name=HomepageURL,proto3" json:"HomepageURL,omitempty"`
	// Disabled is whether the user account is disabled.
	Disabled bool `protobuf:"varint,10,opt,name=Disabled,proto3" json:"Disabled,omitempty"`
	// Admin is whether the user is a site admin for the site.
	Admin bool `protobuf:"varint,12,opt,name=Admin,proto3" json:"Admin,omitempty"`
	// Write is whether the user has write access for the site.
	Write bool `protobuf:"varint,13,opt,name=Write,proto3" json:"Write,omitempty"`
	// RegisteredAt is the date that the user registered. If the user has not
	// registered (i.e., we have processed their repos but they haven't signed into
	// Sourcegraph), it is null.
	RegisteredAt *pbtypes.Timestamp `protobuf:"bytes,11,opt,name=RegisteredAt" json:"RegisteredAt,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{72} }

// UserSpec specifies a user. At least one of Login and UID must be
// nonempty.
type UserSpec struct {
	// Login is a user's login.
	Login string `protobuf:"bytes,1,opt,name=Login,proto3" json:"Login,omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,2,opt,name=UID,proto3" json:"UID,omitempty"`
}

func (m *UserSpec) Reset()                    { *m = UserSpec{} }
func (m *UserSpec) String() string            { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()               {}
func (*UserSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{73} }

// UsersListOptions specifies options for the UsersService.List method.
type UsersListOptions struct {
	// Query filters the results to only those whose logins match. The search algorithm
	// is an implementation detail (currently it is a prefix match).
	Query       string `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,2,opt,name=Sort,proto3" json:"Sort,omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,3,opt,name=Direction,proto3" json:"Direction,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,4,opt,name=ListOptions,embedded=ListOptions" json:""`
	// UIDs filters the resulting list to only contain users
	// with one of these UIDs.
	UIDs []int32 `protobuf:"varint,5,rep,name=UIDs" json:"UIDs,omitempty" url:",omitempty"`
}

func (m *UsersListOptions) Reset()                    { *m = UsersListOptions{} }
func (m *UsersListOptions) String() string            { return proto.CompactTextString(m) }
func (*UsersListOptions) ProtoMessage()               {}
func (*UsersListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{74} }

type OrgsListOp struct {
	Member      UserSpec `protobuf:"bytes,1,opt,name=Member" json:"Member"`
	ListOptions `protobuf:"bytes,2,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *OrgsListOp) Reset()                    { *m = OrgsListOp{} }
func (m *OrgsListOp) String() string            { return proto.CompactTextString(m) }
func (*OrgsListOp) ProtoMessage()               {}
func (*OrgsListOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{75} }

type EmailAddrList struct {
	EmailAddrs []*EmailAddr `protobuf:"bytes,1,rep,name=EmailAddrs" json:"EmailAddrs,omitempty"`
}

func (m *EmailAddrList) Reset()                    { *m = EmailAddrList{} }
func (m *EmailAddrList) String() string            { return proto.CompactTextString(m) }
func (*EmailAddrList) ProtoMessage()               {}
func (*EmailAddrList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{76} }

type OrgList struct {
	Orgs []*Org `protobuf:"bytes,1,rep,name=Orgs" json:"Orgs,omitempty"`
}

func (m *OrgList) Reset()                    { *m = OrgList{} }
func (m *OrgList) String() string            { return proto.CompactTextString(m) }
func (*OrgList) ProtoMessage()               {}
func (*OrgList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{77} }

// CreatedAccount is a newly created account.
type CreatedAccount struct {
	UID int32 `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	// TemporaryAccessToken is a temporary access token that grants
	// full access to this account. It can be used by the caller of
	// Accounts.Create to perform any immediate setup necessary on the
	// account (e.g., linking GitHub tokens) without needing to
	// create/generate a password for the account (which otherwise
	// would be the only way, via the resource owner password grant
	// type, to get an access token).
	TemporaryAccessToken string `protobuf:"bytes,2,opt,name=TemporaryAccessToken,proto3" json:"TemporaryAccessToken,omitempty"`
}

func (m *CreatedAccount) Reset()                    { *m = CreatedAccount{} }
func (m *CreatedAccount) String() string            { return proto.CompactTextString(m) }
func (*CreatedAccount) ProtoMessage()               {}
func (*CreatedAccount) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{78} }

type PasswordResetToken struct {
	// token is the hard to guess token that allows a user to set a new password.
	Token string `protobuf:"bytes,1,opt,name=Token,proto3" json:"Token,omitempty"`
}

func (m *PasswordResetToken) Reset()                    { *m = PasswordResetToken{} }
func (m *PasswordResetToken) String() string            { return proto.CompactTextString(m) }
func (*PasswordResetToken) ProtoMessage()               {}
func (*PasswordResetToken) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{79} }

type PendingPasswordReset struct {
	// Link is the URL for resetting password using this token.
	// It is set in the response only if the request was made
	// by an admin user.
	Link string `protobuf:"bytes,1,opt,name=Link,proto3" json:"Link,omitempty"`
	// Token is the hard to guess token that allows a user to
	// set a new password.
	// It is set in the response only if the request was made
	// by an admin user.
	Token *PasswordResetToken `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
	// EmailSent is set if the password reset link was emailed to
	// the user.
	EmailSent bool `protobuf:"varint,3,opt,name=EmailSent,proto3" json:"EmailSent,omitempty"`
	// Login is the login name of user for whom this request is created.
	Login string `protobuf:"bytes,4,opt,name=Login,proto3" json:"Login,omitempty"`
}

func (m *PendingPasswordReset) Reset()                    { *m = PendingPasswordReset{} }
func (m *PendingPasswordReset) String() string            { return proto.CompactTextString(m) }
func (*PendingPasswordReset) ProtoMessage()               {}
func (*PendingPasswordReset) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{80} }

type NewPassword struct {
	// password is the new password for the user who requested the password reset
	// token.
	Password string              `protobuf:"bytes,1,opt,name=Password,proto3" json:"Password,omitempty"`
	Token    *PasswordResetToken `protobuf:"bytes,2,opt,name=Token" json:"Token,omitempty"`
}

func (m *NewPassword) Reset()                    { *m = NewPassword{} }
func (m *NewPassword) String() string            { return proto.CompactTextString(m) }
func (*NewPassword) ProtoMessage()               {}
func (*NewPassword) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{81} }

type NewAccount struct {
	// Login is the desired login for the new user account.
	Login string `protobuf:"bytes,1,opt,name=Login,proto3" json:"Login,omitempty"`
	// Email is the primary email address for the new user account.
	Email string `protobuf:"bytes,2,opt,name=Email,proto3" json:"Email,omitempty"`
	// Password is the password for the new user account. If empty,
	// the user can only log into the account via GitHub or some other
	// external auth provider (until they reset the password).
	Password string `protobuf:"bytes,3,opt,name=Password,proto3" json:"Password,omitempty"`
	// UID is the desired UID for the new user account.
	UID int32 `protobuf:"varint,4,opt,name=UID,proto3" json:"UID,omitempty"`
}

func (m *NewAccount) Reset()                    { *m = NewAccount{} }
func (m *NewAccount) String() string            { return proto.CompactTextString(m) }
func (*NewAccount) ProtoMessage()               {}
func (*NewAccount) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{82} }

// LoginCredentials is the information a user submits to log in.
type LoginCredentials struct {
	// Login is the user's claimed login.
	Login string `protobuf:"bytes,1,opt,name=Login,proto3" json:"Login,omitempty"`
	// Password is the password (possibly) corresponding to the login.
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"Password,omitempty"`
}

func (m *LoginCredentials) Reset()                    { *m = LoginCredentials{} }
func (m *LoginCredentials) String() string            { return proto.CompactTextString(m) }
func (*LoginCredentials) ProtoMessage()               {}
func (*LoginCredentials) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{83} }

// GitHubAuthCode is a custom authorization grant type we support.
// It lets you log into Sourcegraph by presenting a valid GitHub
// authorization code for the same user.
type GitHubAuthCode struct {
	// Code is the GitHub OAuth2 authorization code returned from
	// GitHub.
	Code string `protobuf:"bytes,1,opt,name=Code,proto3" json:"Code,omitempty"`
	// Host is always "github.com" for now, but can be used in the
	// future to support GitHub Enterprises located at different URLs.
	Host string `protobuf:"bytes,2,opt,name=Host,proto3" json:"Host,omitempty"`
}

func (m *GitHubAuthCode) Reset()                    { *m = GitHubAuthCode{} }
func (m *GitHubAuthCode) String() string            { return proto.CompactTextString(m) }
func (*GitHubAuthCode) ProtoMessage()               {}
func (*GitHubAuthCode) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{84} }

// AccessTokenRequest contains the information necessary to
// request an OAuth2 access token. It supports a subset of
// authorization grant types specified in
// http://tools.ietf.org/html/rfc6749#section-4.
type AccessTokenRequest struct {
	// See http://tools.ietf.org/html/rfc6749#section-1.3 for more
	// information on OAuth2 authorization grant types.
	//
	// Types that are valid to be assigned to AuthorizationGrant:
	//	*AccessTokenRequest_ResourceOwnerPassword
	//	*AccessTokenRequest_GitHubAuthCode
	AuthorizationGrant isAccessTokenRequest_AuthorizationGrant `protobuf_oneof:"authorization_grant"`
	Scope              []string                                `protobuf:"bytes,17,rep,name=Scope" json:"Scope,omitempty"`
}

func (m *AccessTokenRequest) Reset()                    { *m = AccessTokenRequest{} }
func (m *AccessTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*AccessTokenRequest) ProtoMessage()               {}
func (*AccessTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{85} }

type isAccessTokenRequest_AuthorizationGrant interface {
	isAccessTokenRequest_AuthorizationGrant()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AccessTokenRequest_ResourceOwnerPassword struct {
	ResourceOwnerPassword *LoginCredentials `protobuf:"bytes,2,opt,name=ResourceOwnerPassword,oneof"`
}
type AccessTokenRequest_GitHubAuthCode struct {
	GitHubAuthCode *GitHubAuthCode `protobuf:"bytes,3,opt,name=GitHubAuthCode,oneof"`
}

func (*AccessTokenRequest_ResourceOwnerPassword) isAccessTokenRequest_AuthorizationGrant() {}
func (*AccessTokenRequest_GitHubAuthCode) isAccessTokenRequest_AuthorizationGrant()        {}

func (m *AccessTokenRequest) GetAuthorizationGrant() isAccessTokenRequest_AuthorizationGrant {
	if m != nil {
		return m.AuthorizationGrant
	}
	return nil
}

func (m *AccessTokenRequest) GetResourceOwnerPassword() *LoginCredentials {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_ResourceOwnerPassword); ok {
		return x.ResourceOwnerPassword
	}
	return nil
}

func (m *AccessTokenRequest) GetGitHubAuthCode() *GitHubAuthCode {
	if x, ok := m.GetAuthorizationGrant().(*AccessTokenRequest_GitHubAuthCode); ok {
		return x.GitHubAuthCode
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessTokenRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccessTokenRequest_OneofMarshaler, _AccessTokenRequest_OneofUnmarshaler, _AccessTokenRequest_OneofSizer, []interface{}{
		(*AccessTokenRequest_ResourceOwnerPassword)(nil),
		(*AccessTokenRequest_GitHubAuthCode)(nil),
	}
}

func _AccessTokenRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessTokenRequest)
	// authorization_grant
	switch x := m.AuthorizationGrant.(type) {
	case *AccessTokenRequest_ResourceOwnerPassword:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ResourceOwnerPassword); err != nil {
			return err
		}
	case *AccessTokenRequest_GitHubAuthCode:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GitHubAuthCode); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AccessTokenRequest.AuthorizationGrant has unexpected type %T", x)
	}
	return nil
}

func _AccessTokenRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessTokenRequest)
	switch tag {
	case 2: // authorization_grant.ResourceOwnerPassword
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LoginCredentials)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_ResourceOwnerPassword{msg}
		return true, err
	case 3: // authorization_grant.GitHubAuthCode
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GitHubAuthCode)
		err := b.DecodeMessage(msg)
		m.AuthorizationGrant = &AccessTokenRequest_GitHubAuthCode{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AccessTokenRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccessTokenRequest)
	// authorization_grant
	switch x := m.AuthorizationGrant.(type) {
	case *AccessTokenRequest_ResourceOwnerPassword:
		s := proto.Size(x.ResourceOwnerPassword)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessTokenRequest_GitHubAuthCode:
		s := proto.Size(x.GitHubAuthCode)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// AccessTokenResponse is a successful access token response. See
// http://tools.ietf.org/html/rfc6749#section-5.1 for more
// information.
type AccessTokenResponse struct {
	AccessToken  string   `protobuf:"bytes,1,opt,name=AccessToken,proto3" json:"AccessToken,omitempty"`
	TokenType    string   `protobuf:"bytes,2,opt,name=TokenType,proto3" json:"TokenType,omitempty"`
	ExpiresInSec int32    `protobuf:"varint,3,opt,name=ExpiresInSec,proto3" json:"ExpiresInSec,omitempty"`
	RefreshToken string   `protobuf:"bytes,4,opt,name=RefreshToken,proto3" json:"RefreshToken,omitempty"`
	Scope        []string `protobuf:"bytes,5,rep,name=Scope" json:"Scope,omitempty"`
	// Extra fields only used by Sourcegraph.
	UID               int32       `protobuf:"varint,6,opt,name=UID,proto3" json:"UID,omitempty"`
	GitHubAccessToken string      `protobuf:"bytes,7,opt,name=GitHubAccessToken,proto3" json:"GitHubAccessToken,omitempty"`
	GitHubUser        *GitHubUser `protobuf:"bytes,8,opt,name=GitHubUser" json:"GitHubUser,omitempty"`
}

func (m *AccessTokenResponse) Reset()                    { *m = AccessTokenResponse{} }
func (m *AccessTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*AccessTokenResponse) ProtoMessage()               {}
func (*AccessTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{86} }

// GitHubUser represents a GitHub user.
type GitHubUser struct {
	ID        int32  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Login     string `protobuf:"bytes,2,opt,name=Login,proto3" json:"Login,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Email     string `protobuf:"bytes,4,opt,name=Email,proto3" json:"Email,omitempty"`
	Location  string `protobuf:"bytes,5,opt,name=Location,proto3" json:"Location,omitempty"`
	Company   string `protobuf:"bytes,6,opt,name=Company,proto3" json:"Company,omitempty"`
	AvatarURL string `protobuf:"bytes,7,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
}

func (m *GitHubUser) Reset()                    { *m = GitHubUser{} }
func (m *GitHubUser) String() string            { return proto.CompactTextString(m) }
func (*GitHubUser) ProtoMessage()               {}
func (*GitHubUser) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{87} }

// AuthInfo describes the currently authenticated client and/or user
// (if any).
type AuthInfo struct {
	// UID is the UID of the currently authenticated user (if any).
	UID int32 `protobuf:"varint,2,opt,name=UID,proto3" json:"UID,omitempty"`
	// Login is the login of the currently authenticated user (if any).
	Login string `protobuf:"bytes,4,opt,name=Login,proto3" json:"Login,omitempty"`
	// Write is set if the user (if any) has write access on this server.
	Write bool `protobuf:"varint,5,opt,name=Write,proto3" json:"Write,omitempty"`
	// Admin is set if the user (if any) has admin access on this server.
	Admin bool `protobuf:"varint,6,opt,name=Admin,proto3" json:"Admin,omitempty"`
	// IntercomHash is a hash of the UID and the Intercom.io secret
	// key. See
	// https://docs.intercom.io/configuring-for-your-product-or-site/enable-secure-mode
	// for more information.
	IntercomHash string `protobuf:"bytes,7,opt,name=IntercomHash,proto3" json:"IntercomHash,omitempty"`
}

func (m *AuthInfo) Reset()                    { *m = AuthInfo{} }
func (m *AuthInfo) String() string            { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()               {}
func (*AuthInfo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{88} }

// ExternalTokenSpec specifies a request for a stored auth token
// of a user for an external host.
type ExternalTokenSpec struct {
	// UID is the UID of the user whose token is requested.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Host is the external service whose token is requested.
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	// ClientID is the application client ID this token was granted
	// to. The same client ID must be used when using this access
	// token.
	ClientID string `protobuf:"bytes,3,opt,name=client_id,proto3" json:"client_id,omitempty"`
}

func (m *ExternalTokenSpec) Reset()                    { *m = ExternalTokenSpec{} }
func (m *ExternalTokenSpec) String() string            { return proto.CompactTextString(m) }
func (*ExternalTokenSpec) ProtoMessage()               {}
func (*ExternalTokenSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{89} }

// ExternalToken specifies an auth token of a user for an external host.
type ExternalToken struct {
	// UID is the UID of the user authorized by the token.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Host is the external service which granted the token.
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	// Token is the auth token authorizing a user on an external service.
	Token string `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	// Scope lists the permissions the token is entitled to.
	Scope string `protobuf:"bytes,4,opt,name=scope,proto3" json:"scope,omitempty"`
	// ClientID is the application client ID this token was granted
	// to. The same client ID must be used when using this access
	// token.
	ClientID string `protobuf:"bytes,5,opt,name=client_id,proto3" json:"client_id,omitempty"`
	// ExtUID is the UID on the external service of the user corresponding
	// to this token.
	ExtUID int32 `protobuf:"varint,6,opt,name=ext_uid,proto3" json:"ext_uid,omitempty"`
}

func (m *ExternalToken) Reset()                    { *m = ExternalToken{} }
func (m *ExternalToken) String() string            { return proto.CompactTextString(m) }
func (*ExternalToken) ProtoMessage()               {}
func (*ExternalToken) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{90} }

// Def is a code def returned by the Sourcegraph API.
type Def struct {
	graph.Def  `protobuf:"bytes,1,opt,name=Def,embedded=Def" json:""`
	DocHTML    *pbtypes2.HTML          `protobuf:"bytes,2,opt,name=DocHTML" json:"DocHTML,omitempty"`
	FmtStrings *graph.DefFormatStrings `protobuf:"bytes,3,opt,name=FmtStrings" json:"FmtStrings,omitempty"`
	// StartLine and EndLine are populated if
	// DefGetOptions.ComputeLineRange is true.
	StartLine uint32 `protobuf:"varint,4,opt,name=StartLine,proto3" json:"StartLine,omitempty"`
	EndLine   uint32 `protobuf:"varint,5,opt,name=EndLine,proto3" json:"EndLine,omitempty"`
}

func (m *Def) Reset()                    { *m = Def{} }
func (m *Def) String() string            { return proto.CompactTextString(m) }
func (*Def) ProtoMessage()               {}
func (*Def) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{91} }

// DefGetOptions specifies options for DefsService.Get.
type DefGetOptions struct {
	Doc bool `protobuf:"varint,1,opt,name=Doc,proto3" json:"Doc,omitempty" url:",omitempty"`
	// ComputeLineRange is whether the server should compute the start
	// and end line numbers (1-indexed). This incurs additional cost,
	// so it's not always desired.
	ComputeLineRange bool `protobuf:"varint,2,opt,name=ComputeLineRange,proto3" json:"ComputeLineRange,omitempty" url:",omitempty"`
}

func (m *DefGetOptions) Reset()                    { *m = DefGetOptions{} }
func (m *DefGetOptions) String() string            { return proto.CompactTextString(m) }
func (*DefGetOptions) ProtoMessage()               {}
func (*DefGetOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{92} }

// DefListOptions specifies options for DefsService.List.
type DefListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty" url:",omitempty"`
	// Specifies a search query for defs. If specified, then the Sort and Direction
	// options are ignored
	Query string `protobuf:"bytes,2,opt,name=Query,proto3" json:"Query,omitempty" url:",omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteStart uint32 `protobuf:"varint,3,opt,name=ByteStart,proto3" json:"ByteStart,omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteEnd uint32 `protobuf:"varint,4,opt,name=ByteEnd,proto3" json:"ByteEnd,omitempty"`
	// DefKeys, if set, will return the definitions that match the given DefKey
	DefKeys []*graph.DefKey `protobuf:"bytes,5,rep,name=DefKeys" json:"DefKeys,omitempty"`
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	//
	// TODO(repo-key): Make this use repo IDs, not URIs.
	RepoRevs []string `protobuf:"bytes,6,rep,name=RepoRevs" json:"RepoRevs,omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,7,opt,name=UnitType,proto3" json:"UnitType,omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,8,opt,name=Unit,proto3" json:"Unit,omitempty" url:",omitempty"`
	Path     string   `protobuf:"bytes,9,opt,name=Path,proto3" json:"Path,omitempty" url:",omitempty"`
	// Files, if specified, will restrict the results to only defs defined in the
	// specified file.
	Files []string `protobuf:"bytes,10,rep,name=Files" json:"Files,omitempty" url:",omitempty"`
	// FilePathPrefix, if specified, will restrict the results to only defs defined in
	// files whose path is underneath the specified prefix.
	FilePathPrefix string   `protobuf:"bytes,11,opt,name=FilePathPrefix,proto3" json:"FilePathPrefix,omitempty" url:",omitempty"`
	Kinds          []string `protobuf:"bytes,12,rep,name=Kinds" json:"Kinds,omitempty" url:",omitempty,comma"`
	Exported       bool     `protobuf:"varint,13,opt,name=Exported,proto3" json:"Exported,omitempty" url:",omitempty"`
	Nonlocal       bool     `protobuf:"varint,14,opt,name=Nonlocal,proto3" json:"Nonlocal,omitempty" url:",omitempty"`
	// IncludeTest is whether the results should include definitions in test files.
	IncludeTest bool `protobuf:"varint,15,opt,name=IncludeTest,proto3" json:"IncludeTest,omitempty" url:",omitempty"`
	// Enhancements
	Doc   bool `protobuf:"varint,16,opt,name=Doc,proto3" json:"Doc,omitempty" url:",omitempty"`
	Fuzzy bool `protobuf:"varint,17,opt,name=Fuzzy,proto3" json:"Fuzzy,omitempty" url:",omitempty"`
	// Sorting
	Sort      string `protobuf:"bytes,18,opt,name=Sort,proto3" json:"Sort,omitempty" url:",omitempty"`
	Direction string `protobuf:"bytes,19,opt,name=Direction,proto3" json:"Direction,omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,20,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListOptions) Reset()                    { *m = DefListOptions{} }
func (m *DefListOptions) String() string            { return proto.CompactTextString(m) }
func (*DefListOptions) ProtoMessage()               {}
func (*DefListOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{93} }

// DefListRefsOptions configures the scope of ref search for a def.
type DefListRefsOptions struct {
	Repo        int32    `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty" url:",omitempty"`
	CommitID    string   `protobuf:"bytes,4,opt,name=CommitID,proto3" json:"CommitID,omitempty" url:",omitempty"`
	Files       []string `protobuf:"bytes,2,rep,name=Files" json:"Files,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListRefsOptions) Reset()                    { *m = DefListRefsOptions{} }
func (m *DefListRefsOptions) String() string            { return proto.CompactTextString(m) }
func (*DefListRefsOptions) ProtoMessage()               {}
func (*DefListRefsOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{94} }

// DefSpec specifies a def.
type DefSpec struct {
	Repo     int32  `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	CommitID string `protobuf:"bytes,2,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	UnitType string `protobuf:"bytes,3,opt,name=UnitType,proto3" json:"UnitType,omitempty"`
	Unit     string `protobuf:"bytes,4,opt,name=Unit,proto3" json:"Unit,omitempty"`
	Path     string `protobuf:"bytes,5,opt,name=Path,proto3" json:"Path,omitempty"`
}

func (m *DefSpec) Reset()                    { *m = DefSpec{} }
func (m *DefSpec) String() string            { return proto.CompactTextString(m) }
func (*DefSpec) ProtoMessage()               {}
func (*DefSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{95} }

type DefsGetOp struct {
	Def DefSpec        `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	Opt *DefGetOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsGetOp) Reset()                    { *m = DefsGetOp{} }
func (m *DefsGetOp) String() string            { return proto.CompactTextString(m) }
func (*DefsGetOp) ProtoMessage()               {}
func (*DefsGetOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{96} }

type DefList struct {
	Defs         []*Def `protobuf:"bytes,1,rep,name=Defs" json:"Defs,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=ListResponse,embedded=ListResponse" json:""`
}

func (m *DefList) Reset()                    { *m = DefList{} }
func (m *DefList) String() string            { return proto.CompactTextString(m) }
func (*DefList) ProtoMessage()               {}
func (*DefList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{97} }

type DefsListRefsOp struct {
	Def DefSpec             `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	Opt *DefListRefsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsListRefsOp) Reset()                    { *m = DefsListRefsOp{} }
func (m *DefsListRefsOp) String() string            { return proto.CompactTextString(m) }
func (*DefsListRefsOp) ProtoMessage()               {}
func (*DefsListRefsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{98} }

type RefList struct {
	Refs           []*graph1.Ref `protobuf:"bytes,1,rep,name=Refs" json:"Refs,omitempty"`
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
}

func (m *RefList) Reset()                    { *m = RefList{} }
func (m *RefList) String() string            { return proto.CompactTextString(m) }
func (*RefList) ProtoMessage()               {}
func (*RefList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{99} }

// DefListRefLocationsOptions holds the options for fetching
// all locations referencing a def.
type DefListRefLocationsOptions struct {
	// Repos is the list of repos to restrict the results to.
	// If empty, all repos are searched for references.
	Repos []string `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty" url:",omitempty"`
	// ListOptions specifies options for paginating
	// the result.
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListRefLocationsOptions) Reset()         { *m = DefListRefLocationsOptions{} }
func (m *DefListRefLocationsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListRefLocationsOptions) ProtoMessage()    {}
func (*DefListRefLocationsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{100}
}

// DefListRefLocationsOptions holds the options for fetching
// all locations referencing the specified def.
type DefsListRefLocationsOp struct {
	// Def identifies the definition whose locations are requested.
	Def DefSpec `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	// Opt controls the scope of the search for ref locations of this def.
	Opt *DefListRefLocationsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsListRefLocationsOp) Reset()         { *m = DefsListRefLocationsOp{} }
func (m *DefsListRefLocationsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListRefLocationsOp) ProtoMessage()    {}
func (*DefsListRefLocationsOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{101}
}

// DefsListExamples holds the options for fetching
// usage examples referencing the specified def.
type DefsListExamplesOp struct {
	// Def identifies the definition whose examples are requested.
	Def DefSpec `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	// ListOptions specifies options for paginating the result.
	ListOptions `protobuf:"bytes,2,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefsListExamplesOp) Reset()                    { *m = DefsListExamplesOp{} }
func (m *DefsListExamplesOp) String() string            { return proto.CompactTextString(m) }
func (*DefsListExamplesOp) ProtoMessage()               {}
func (*DefsListExamplesOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{102} }

// RefLocationsList lists the repos and files that reference a def.
type RefLocationsList struct {
	// RepoRefs holds the repos and files referencing the def.
	RepoRefs []*DefRepoRef `protobuf:"bytes,1,rep,name=RepoRefs" json:"RepoRefs,omitempty"`
	// StreamResponse specifies if more results are available.
	StreamResponse `protobuf:"bytes,2,opt,name=StreamResponse,embedded=StreamResponse" json:""`
	// TotalRepos is the total number of repos which reference the def.
	TotalRepos int32 `protobuf:"varint,3,opt,name=TotalRepos,proto3" json:"TotalRepos,omitempty"`
}

func (m *RefLocationsList) Reset()                    { *m = RefLocationsList{} }
func (m *RefLocationsList) String() string            { return proto.CompactTextString(m) }
func (*RefLocationsList) ProtoMessage()               {}
func (*RefLocationsList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{103} }

// DefRepoRef identifies a repo and its files that reference a def.
type DefRepoRef struct {
	// Repo is the name of repo that references the def.
	Repo string `protobuf:"bytes,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// Count is the number of references to the def in the repo.
	Count int32 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	// Score is the importance score of this repo for the def.
	Score float32 `protobuf:"fixed32,3,opt,name=Score,proto3" json:"Score,omitempty"`
	// Files is the list of files in this repo referencing the def.
	Files []*DefFileRef `protobuf:"bytes,4,rep,name=Files" json:"Files,omitempty"`
}

func (m *DefRepoRef) Reset()                    { *m = DefRepoRef{} }
func (m *DefRepoRef) String() string            { return proto.CompactTextString(m) }
func (*DefRepoRef) ProtoMessage()               {}
func (*DefRepoRef) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{104} }

// DefFileRef identifies a file that references a def.
type DefFileRef struct {
	// Path is the path of this file.
	Path string `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	// Count is the number of references to the def in this file.
	Count int32 `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	// Score is the importance score of this file for the def.
	Score float32 `protobuf:"fixed32,3,opt,name=Score,proto3" json:"Score,omitempty"`
}

func (m *DefFileRef) Reset()                    { *m = DefFileRef{} }
func (m *DefFileRef) String() string            { return proto.CompactTextString(m) }
func (*DefFileRef) ProtoMessage()               {}
func (*DefFileRef) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{105} }

// Delta represents the difference between two commits (possibly in 2 separate
// repositories).
type Delta struct {
	Base       RepoRevSpec `protobuf:"bytes,1,opt,name=Base" json:"Base"`
	Head       RepoRevSpec `protobuf:"bytes,2,opt,name=Head" json:"Head"`
	BaseCommit *vcs.Commit `protobuf:"bytes,3,opt,name=BaseCommit" json:"BaseCommit,omitempty"`
	HeadCommit *vcs.Commit `protobuf:"bytes,4,opt,name=HeadCommit" json:"HeadCommit,omitempty"`
}

func (m *Delta) Reset()                    { *m = Delta{} }
func (m *Delta) String() string            { return proto.CompactTextString(m) }
func (*Delta) ProtoMessage()               {}
func (*Delta) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{106} }

// FileDiff holds data about a diff, and additionally stores extended
// information about its hunks.
type FileDiff struct {
	diff.FileDiff `protobuf:"bytes,1,opt,name=FileDiff,embedded=FileDiff" json:""`
	FileDiffHunks []*diff.Hunk `protobuf:"bytes,2,rep,name=FileDiffHunks" json:"FileDiffHunks,omitempty"`
	// PreImage is the CommitID at which this file was before the change occurred.
	PreImage string `protobuf:"bytes,3,opt,name=PreImage,proto3" json:",omitempty"`
	// PostImage is the CommitID at which this file was after the change occurred.
	PostImage string `protobuf:"bytes,4,opt,name=PostImage,proto3" json:",omitempty"`
	// Stat contains statistics about additions and deletions to this diff.
	Stats diff.Stat `protobuf:"bytes,5,opt,name=Stats" json:"Stats"`
	// Filtered specifies whether or not this file diff was filtered out, and as
	// such contains no FileDiffHunks or FileDiff.Hunks.
	Filtered bool `protobuf:"varint,6,opt,name=Filtered,proto3" json:",omitempty"`
}

func (m *FileDiff) Reset()                    { *m = FileDiff{} }
func (m *FileDiff) String() string            { return proto.CompactTextString(m) }
func (*FileDiff) ProtoMessage()               {}
func (*FileDiff) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{107} }

// DeltaFiles describes files added/changed/deleted in a delta.
type DeltaFiles struct {
	FileDiffs []*FileDiff `protobuf:"bytes,1,rep,name=FileDiffs" json:"FileDiffs,omitempty"`
	Delta     *Delta      `protobuf:"bytes,2,opt,name=Delta" json:"Delta,omitempty"`
	Stats     diff.Stat   `protobuf:"bytes,3,opt,name=Stats" json:"Stats"`
}

func (m *DeltaFiles) Reset()                    { *m = DeltaFiles{} }
func (m *DeltaFiles) String() string            { return proto.CompactTextString(m) }
func (*DeltaFiles) ProtoMessage()               {}
func (*DeltaFiles) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{108} }

// DeltaFilter specifies criteria by which to filter results from DeltaListXxx
// methods.
type DeltaFilter struct {
	Unit     string `protobuf:"bytes,1,opt,name=Unit,proto3" json:"Unit,omitempty" url:",omitempty"`
	UnitType string `protobuf:"bytes,2,opt,name=UnitType,proto3" json:"UnitType,omitempty" url:",omitempty"`
}

func (m *DeltaFilter) Reset()                    { *m = DeltaFilter{} }
func (m *DeltaFilter) String() string            { return proto.CompactTextString(m) }
func (*DeltaFilter) ProtoMessage()               {}
func (*DeltaFilter) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{109} }

// DeltaListFilesOptions specifies options for ListFiles.
type DeltaListFilesOptions struct {
	// Filter filters the list of returned files to those whose name matches
	// Filter. There is no difference in the returned data except that the
	// returned DeltaFiles.FileDiffs will not contain any hunks and will have
	// Filtered set to true.
	Filter string `protobuf:"bytes,2,opt,name=Filter,proto3" json:"Filter,omitempty" url:",omitempty"`
	// Ignore specifies a list of '/'-separated path globs to omit from the
	// returned results.
	Ignore      []string `protobuf:"bytes,6,rep,name=Ignore" json:"Ignore,omitempty" url:",omitempty"`
	DeltaFilter `protobuf:"bytes,5,opt,name=DeltaFilter,embedded=DeltaFilter" json:""`
}

func (m *DeltaListFilesOptions) Reset()         { *m = DeltaListFilesOptions{} }
func (m *DeltaListFilesOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListFilesOptions) ProtoMessage()    {}
func (*DeltaListFilesOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{110}
}

// A DeltaSpec specifies a delta.
type DeltaSpec struct {
	Base RepoRevSpec `protobuf:"bytes,1,opt,name=Base" json:"Base"`
	Head RepoRevSpec `protobuf:"bytes,2,opt,name=Head" json:"Head"`
}

func (m *DeltaSpec) Reset()                    { *m = DeltaSpec{} }
func (m *DeltaSpec) String() string            { return proto.CompactTextString(m) }
func (*DeltaSpec) ProtoMessage()               {}
func (*DeltaSpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{111} }

type DeltasListFilesOp struct {
	Ds  DeltaSpec              `protobuf:"bytes,1,opt,name=Ds" json:"Ds"`
	Opt *DeltaListFilesOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DeltasListFilesOp) Reset()                    { *m = DeltasListFilesOp{} }
func (m *DeltasListFilesOp) String() string            { return proto.CompactTextString(m) }
func (*DeltasListFilesOp) ProtoMessage()               {}
func (*DeltasListFilesOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{112} }

// RepoTreeGetOptions specifies options for (RepoTreeService).Get.
type RepoTreeGetOptions struct {
	ContentsAsString bool `protobuf:"varint,4,opt,name=ContentsAsString,proto3" json:"ContentsAsString,omitempty" url:",omitempty"`
	GetFileOptions   `protobuf:"bytes,5,opt,name=GetFileOptions,embedded=GetFileOptions" json:""`
}

func (m *RepoTreeGetOptions) Reset()                    { *m = RepoTreeGetOptions{} }
func (m *RepoTreeGetOptions) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeGetOptions) ProtoMessage()               {}
func (*RepoTreeGetOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{113} }

// GetFileOptions specifies options for GetFileWithOptions.
type GetFileOptions struct {
	// line or byte range to fetch (can't set both line *and* byte range)
	FileRange `protobuf:"bytes,1,opt,name=FileRange,embedded=FileRange" json:""`
	// EntireFile is whether the entire file contents should be returned. If true,
	// Start/EndLine and Start/EndBytes are ignored.
	EntireFile bool `protobuf:"varint,2,opt,name=EntireFile,proto3" json:"EntireFile,omitempty" url:",omitempty"`
	// ExpandContextLines is how many lines of additional output context to include (if
	// Start/EndLine and Start/EndBytes are specified). For example, specifying 2 will
	// expand the range to include 2 full lines before the beginning and 2 full lines
	// after the end of the range specified by Start/EndLine and Start/EndBytes.
	ExpandContextLines int32 `protobuf:"varint,3,opt,name=ExpandContextLines,proto3" json:"ExpandContextLines,omitempty" url:",omitempty"`
	// FullLines is whether a range that includes partial lines should be extended to
	// the nearest line boundaries on both sides. It is only valid if StartByte and
	// EndByte are specified.
	FullLines bool `protobuf:"varint,4,opt,name=FullLines,proto3" json:"FullLines,omitempty" url:",omitempty"`
	// Recursive only applies if the returned entry is a directory. It will
	// return the full file tree of the host repository, recursing into all
	// sub-directories.
	Recursive bool `protobuf:"varint,5,opt,name=Recursive,proto3" json:"Recursive,omitempty" url:",omitempty"`
	// RecurseSingleSubfolderLimit only applies if the returned entry is a directory.
	// If nonzero, it will recursively find and include all singleton sub-directory chains,
	// up to a limit of RecurseSingleSubfolderLimit.
	RecurseSingleSubfolderLimit int32 `protobuf:"varint,6,opt,name=RecurseSingleSubfolderLimit,proto3" json:"RecurseSingleSubfolderLimit,omitempty" url:",omitempty"`
}

func (m *GetFileOptions) Reset()                    { *m = GetFileOptions{} }
func (m *GetFileOptions) String() string            { return proto.CompactTextString(m) }
func (*GetFileOptions) ProtoMessage()               {}
func (*GetFileOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{114} }

type RepoTreeSearchOptions struct {
	vcs.SearchOptions `protobuf:"bytes,1,opt,name=SearchOptions,embedded=SearchOptions" json:""`
}

func (m *RepoTreeSearchOptions) Reset()         { *m = RepoTreeSearchOptions{} }
func (m *RepoTreeSearchOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOptions) ProtoMessage()    {}
func (*RepoTreeSearchOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{115}
}

// A RepoTreeSearchResult is a tree search result that includes the repo and rev it
// came from.
type RepoTreeSearchResult struct {
	vcs.SearchResult `protobuf:"bytes,1,opt,name=SearchResult,embedded=SearchResult" json:""`
	RepoRev          RepoRevSpec `protobuf:"bytes,2,opt,name=RepoRev" json:"RepoRev"`
}

func (m *RepoTreeSearchResult) Reset()         { *m = RepoTreeSearchResult{} }
func (m *RepoTreeSearchResult) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchResult) ProtoMessage()    {}
func (*RepoTreeSearchResult) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{116}
}

type RepoTreeGetOp struct {
	Entry TreeEntrySpec       `protobuf:"bytes,1,opt,name=Entry" json:"Entry"`
	Opt   *RepoTreeGetOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *RepoTreeGetOp) Reset()                    { *m = RepoTreeGetOp{} }
func (m *RepoTreeGetOp) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeGetOp) ProtoMessage()               {}
func (*RepoTreeGetOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{117} }

type RepoTreeSearchOp struct {
	Rev RepoRevSpec            `protobuf:"bytes,1,opt,name=Rev" json:"Rev"`
	Opt *RepoTreeSearchOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *RepoTreeSearchOp) Reset()                    { *m = RepoTreeSearchOp{} }
func (m *RepoTreeSearchOp) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeSearchOp) ProtoMessage()               {}
func (*RepoTreeSearchOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{118} }

type RepoTreeListOp struct {
	Rev RepoRevSpec `protobuf:"bytes,1,opt,name=Rev" json:"Rev"`
}

func (m *RepoTreeListOp) Reset()                    { *m = RepoTreeListOp{} }
func (m *RepoTreeListOp) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeListOp) ProtoMessage()               {}
func (*RepoTreeListOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{119} }

type RepoTreeListResult struct {
	Files []string `protobuf:"bytes,1,rep,name=Files" json:"Files,omitempty"`
}

func (m *RepoTreeListResult) Reset()                    { *m = RepoTreeListResult{} }
func (m *RepoTreeListResult) String() string            { return proto.CompactTextString(m) }
func (*RepoTreeListResult) ProtoMessage()               {}
func (*RepoTreeListResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{120} }

type VCSSearchResultList struct {
	SearchResults []*vcs.SearchResult `protobuf:"bytes,1,rep,name=SearchResults" json:"SearchResults,omitempty"`
	ListResponse  `protobuf:"bytes,2,opt,name=ListResponse,embedded=ListResponse" json:""`
}

func (m *VCSSearchResultList) Reset()                    { *m = VCSSearchResultList{} }
func (m *VCSSearchResultList) String() string            { return proto.CompactTextString(m) }
func (*VCSSearchResultList) ProtoMessage()               {}
func (*VCSSearchResultList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{121} }

// TreeEntry is a file or directory in a repository.
type TreeEntry struct {
	*BasicTreeEntry `protobuf:"bytes,1,opt,name=BasicTreeEntry,embedded=BasicTreeEntry" json:""`
	*FileRange      `protobuf:"bytes,2,opt,name=FileRange,embedded=FileRange" json:""`
	ContentsString  string `protobuf:"bytes,3,opt,name=ContentsString,proto3" json:"ContentsString,omitempty"`
}

func (m *TreeEntry) Reset()                    { *m = TreeEntry{} }
func (m *TreeEntry) String() string            { return proto.CompactTextString(m) }
func (*TreeEntry) ProtoMessage()               {}
func (*TreeEntry) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{122} }

type BasicTreeEntry struct {
	Name     string            `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Type     TreeEntryType     `protobuf:"varint,2,opt,name=Type,proto3,enum=sourcegraph.TreeEntryType" json:"Type,omitempty"`
	CommitID string            `protobuf:"bytes,3,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	Contents []byte            `protobuf:"bytes,5,opt,name=Contents,proto3" json:"Contents,omitempty"`
	Entries  []*BasicTreeEntry `protobuf:"bytes,6,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *BasicTreeEntry) Reset()                    { *m = BasicTreeEntry{} }
func (m *BasicTreeEntry) String() string            { return proto.CompactTextString(m) }
func (*BasicTreeEntry) ProtoMessage()               {}
func (*BasicTreeEntry) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{123} }

type TreeEntrySpec struct {
	RepoRev RepoRevSpec `protobuf:"bytes,1,opt,name=RepoRev" json:"RepoRev"`
	Path    string      `protobuf:"bytes,2,opt,name=Path,proto3" json:"Path,omitempty"`
}

func (m *TreeEntrySpec) Reset()                    { *m = TreeEntrySpec{} }
func (m *TreeEntrySpec) String() string            { return proto.CompactTextString(m) }
func (*TreeEntrySpec) ProtoMessage()               {}
func (*TreeEntrySpec) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{124} }

// FileRange is a line and byte range in a file.
type FileRange struct {
	// start of line range
	StartLine int64 `protobuf:"varint,1,opt,name=StartLine,proto3" json:"StartLine,omitempty" url:",omitempty"`
	// end of line range
	EndLine int64 `protobuf:"varint,2,opt,name=EndLine,proto3" json:"EndLine,omitempty" url:",omitempty"`
	// start of byte range
	StartByte int64 `protobuf:"varint,3,opt,name=StartByte,proto3" json:"StartByte,omitempty" url:",omitempty"`
	// end of byte range
	EndByte int64 `protobuf:"varint,4,opt,name=EndByte,proto3" json:"EndByte,omitempty" url:",omitempty"`
}

func (m *FileRange) Reset()                    { *m = FileRange{} }
func (m *FileRange) String() string            { return proto.CompactTextString(m) }
func (*FileRange) ProtoMessage()               {}
func (*FileRange) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{125} }

type DefsRefreshIndexOp struct {
	// Repo is the repo whose graph data is to be re-indexed
	// for global ref locations.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// RefreshRefLocations refreshes the global ref locations index for
	// the specified repository.
	RefreshRefLocations bool `protobuf:"varint,2,opt,name=RefreshRefLocations,proto3" json:"RefreshRefLocations,omitempty"`
	// Force ensures we reindex, even if we have already indexed the latest
	// commit for repo
	Force bool `protobuf:"varint,3,opt,name=Force,proto3" json:"Force,omitempty"`
	// CommitID is the commit for which defs should be synced from srclib-store to DB.
	CommitID string `protobuf:"bytes,4,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
}

func (m *DefsRefreshIndexOp) Reset()                    { *m = DefsRefreshIndexOp{} }
func (m *DefsRefreshIndexOp) String() string            { return proto.CompactTextString(m) }
func (*DefsRefreshIndexOp) ProtoMessage()               {}
func (*DefsRefreshIndexOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{126} }

type AsyncRefreshIndexesOp struct {
	// Repo will have all of its indexes refreshed.
	Repo int32 `protobuf:"varint,1,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// Source helps tie back async jobs to their source.
	Source string `protobuf:"bytes,2,opt,name=Source,proto3" json:"Source,omitempty"`
	// Force will ensure all indexes are refreshed, even if the index
	// already includes the latest commit.
	Force bool `protobuf:"varint,3,opt,name=Force,proto3" json:"Force,omitempty"`
}

func (m *AsyncRefreshIndexesOp) Reset()         { *m = AsyncRefreshIndexesOp{} }
func (m *AsyncRefreshIndexesOp) String() string { return proto.CompactTextString(m) }
func (*AsyncRefreshIndexesOp) ProtoMessage()    {}
func (*AsyncRefreshIndexesOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{127}
}

type AuthorshipInfo struct {
	LastCommitDate pbtypes.Timestamp `protobuf:"bytes,1,opt,name=LastCommitDate" json:"LastCommitDate"`
	// LastCommitID is the commit ID of the last commit that this author made to the
	// thing that this info describes.
	LastCommitID string `protobuf:"bytes,2,opt,name=LastCommitID,proto3" json:"LastCommitID,omitempty"`
}

func (m *AuthorshipInfo) Reset()                    { *m = AuthorshipInfo{} }
func (m *AuthorshipInfo) String() string            { return proto.CompactTextString(m) }
func (*AuthorshipInfo) ProtoMessage()               {}
func (*AuthorshipInfo) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{128} }

type DefAuthor struct {
	// Email is the author's email. It may be obfuscated or truncated
	// to prevent spam.
	Email string `protobuf:"bytes,1,opt,name=Email,proto3" json:"Email,omitempty"`
	// AvatarURL is the URL to the author's avatar image, if any.
	AvatarURL string `protobuf:"bytes,2,opt,name=AvatarURL,proto3" json:"AvatarURL,omitempty"`
	// DefAuthorship contains statistics about the author's contributions
	// to the def.
	DefAuthorship `protobuf:"bytes,3,opt,name=DefAuthorship,embedded=DefAuthorship" json:""`
}

func (m *DefAuthor) Reset()                    { *m = DefAuthor{} }
func (m *DefAuthor) String() string            { return proto.CompactTextString(m) }
func (*DefAuthor) ProtoMessage()               {}
func (*DefAuthor) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{129} }

type DefAuthorship struct {
	AuthorshipInfo  `protobuf:"bytes,1,opt,name=AuthorshipInfo,embedded=AuthorshipInfo" json:""`
	Bytes           int32   `protobuf:"varint,3,opt,name=Bytes,proto3" json:"Bytes,omitempty"`
	BytesProportion float64 `protobuf:"fixed64,4,opt,name=BytesProportion,proto3" json:"BytesProportion,omitempty"`
}

func (m *DefAuthorship) Reset()                    { *m = DefAuthorship{} }
func (m *DefAuthorship) String() string            { return proto.CompactTextString(m) }
func (*DefAuthorship) ProtoMessage()               {}
func (*DefAuthorship) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{130} }

// DefListAuthorsOptions specifies options for DefsService.ListAuthors.
type DefListAuthorsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=ListOptions,embedded=ListOptions" json:""`
}

func (m *DefListAuthorsOptions) Reset()         { *m = DefListAuthorsOptions{} }
func (m *DefListAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListAuthorsOptions) ProtoMessage()    {}
func (*DefListAuthorsOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{131}
}

type DefsListAuthorsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=Def" json:"Def"`
	Opt *DefListAuthorsOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *DefsListAuthorsOp) Reset()                    { *m = DefsListAuthorsOp{} }
func (m *DefsListAuthorsOp) String() string            { return proto.CompactTextString(m) }
func (*DefsListAuthorsOp) ProtoMessage()               {}
func (*DefsListAuthorsOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{132} }

type DefAuthorList struct {
	DefAuthors []*DefAuthor `protobuf:"bytes,1,rep,name=DefAuthors" json:"DefAuthors,omitempty"`
}

func (m *DefAuthorList) Reset()                    { *m = DefAuthorList{} }
func (m *DefAuthorList) String() string            { return proto.CompactTextString(m) }
func (*DefAuthorList) ProtoMessage()               {}
func (*DefAuthorList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{133} }

type Checklist struct {
	// number of tasks to be done (unchecked)
	Todo int32 `protobuf:"varint,1,opt,name=Todo,proto3" json:"Todo,omitempty"`
	// number of tasks that are done (checked)
	Done int32 `protobuf:"varint,2,opt,name=Done,proto3" json:"Done,omitempty"`
}

func (m *Checklist) Reset()                    { *m = Checklist{} }
func (m *Checklist) String() string            { return proto.CompactTextString(m) }
func (*Checklist) ProtoMessage()               {}
func (*Checklist) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{134} }

type FileToken struct {
	Path  string          `protobuf:"bytes,1,opt,name=Path,proto3" json:"Path,omitempty"`
	Entry *BasicTreeEntry `protobuf:"bytes,2,opt,name=Entry" json:"Entry,omitempty"`
}

func (m *FileToken) Reset()                    { *m = FileToken{} }
func (m *FileToken) String() string            { return proto.CompactTextString(m) }
func (*FileToken) ProtoMessage()               {}
func (*FileToken) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{135} }

// ServerStatus describes the server's status.
type ServerStatus struct {
	// Info contains arbitrary human-readable status information about
	// the server.
	Info string `protobuf:"bytes,1,opt,name=Info,proto3" json:"Info,omitempty"`
}

func (m *ServerStatus) Reset()                    { *m = ServerStatus{} }
func (m *ServerStatus) String() string            { return proto.CompactTextString(m) }
func (*ServerStatus) ProtoMessage()               {}
func (*ServerStatus) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{136} }

// ServerConfig describes the server's configuration.
//
// DEV NOTE: There is some overlap with Go CLI flag structs. In the
// future we may consolidate these.
type ServerConfig struct {
	// Version is the version of Sourcegraph that this server is
	// running.
	Version string `protobuf:"bytes,1,opt,name=Version,proto3" json:"Version,omitempty"`
	// AppURL is the base URL of the user-facing web application
	// (e.g., "https://sourcegraph.com").
	AppURL string `protobuf:"bytes,2,opt,name=AppURL,proto3" json:"AppURL,omitempty"`
	// IDKey is the server's identity key (ID key).
	IDKey string `protobuf:"bytes,7,opt,name=IDKey,proto3" json:"IDKey,omitempty"`
}

func (m *ServerConfig) Reset()                    { *m = ServerConfig{} }
func (m *ServerConfig) String() string            { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()               {}
func (*ServerConfig) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{137} }

// UserEvent encodes any user initiated event on the local instance.
type UserEvent struct {
	Type     string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	UID      int32  `protobuf:"varint,2,opt,name=UID,proto3" json:"UID,omitempty"`
	ClientID string `protobuf:"bytes,3,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	Service  string `protobuf:"bytes,4,opt,name=Service,proto3" json:"Service,omitempty"`
	Method   string `protobuf:"bytes,5,opt,name=Method,proto3" json:"Method,omitempty"`
	Result   string `protobuf:"bytes,6,opt,name=Result,proto3" json:"Result,omitempty"`
	// CreatedAt holds the time when this event was logged.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=CreatedAt" json:"CreatedAt,omitempty"`
	Message   string             `protobuf:"bytes,8,opt,name=Message,proto3" json:"Message,omitempty"`
	// Version holds the release version of the Sourcegraph binary.
	Version string `protobuf:"bytes,9,opt,name=Version,proto3" json:"Version,omitempty"`
	// URL holds the http request url.
	URL string `protobuf:"bytes,10,opt,name=URL,proto3" json:"URL,omitempty"`
}

func (m *UserEvent) Reset()                    { *m = UserEvent{} }
func (m *UserEvent) String() string            { return proto.CompactTextString(m) }
func (*UserEvent) ProtoMessage()               {}
func (*UserEvent) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{138} }

// Event is any action logged on a Sourcegraph instance.
type Event struct {
	// Type specifies the action type, eg. "AccountCreate" or "AddRepo".
	Type string `protobuf:"bytes,1,opt,name=Type,proto3" json:"Type,omitempty"`
	// UserID is the unique identifier of a user on a Sourcegraph instance.
	// It is constructed as "login@short-client-id", where short-client-id
	// is the first 6 characters of this sourcegraph instance's public key
	// fingerprint (i.e. it's ClientID).
	UserID string `protobuf:"bytes,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	// DeviceID is the unique identifier of an anonymous user on a Sourcegraph
	// instance.
	DeviceID string `protobuf:"bytes,3,opt,name=DeviceID,proto3" json:"DeviceID,omitempty"`
	// ClientID is this Sourcegraph instance's public key fingerprint.
	ClientID string `protobuf:"bytes,4,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	// Timestamp records the instant when this event was logged.
	Timestamp *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=Timestamp" json:"Timestamp,omitempty"`
	// UserProperties holds metadata relating to user who performed this
	// action, eg. "Email".
	UserProperties map[string]string `protobuf:"bytes,6,rep,name=UserProperties" json:"UserProperties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// EventProperties holds metadata relating to the action logged by
	// this event, eg. for "AddRepo" event, a property is "Source" which
	// specifies if the repo is local or mirrored.
	EventProperties map[string]string `protobuf:"bytes,7,rep,name=EventProperties" json:"EventProperties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{139} }

// EventList is a list of logged Sourcegraph events.
type EventList struct {
	// Events holds the list of events.
	Events []*Event `protobuf:"bytes,1,rep,name=Events" json:"Events,omitempty"`
	// Version holds the release version of the Sourcegraph binary.
	Version string `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
	// AppURL holds the base URL of the Sourcegraph app.
	AppURL string `protobuf:"bytes,3,opt,name=AppURL,proto3" json:"AppURL,omitempty"`
}

func (m *EventList) Reset()                    { *m = EventList{} }
func (m *EventList) String() string            { return proto.CompactTextString(m) }
func (*EventList) ProtoMessage()               {}
func (*EventList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{140} }

// NotifyGenericEvent describes an action being done against an object. For
// example, pushing a branch.
type NotifyGenericEvent struct {
	// Actor is the User who did the action
	Actor *UserSpec `protobuf:"bytes,1,opt,name=Actor" json:"Actor,omitempty"`
	// Recipients is who should be notified of the action
	Recipients []*UserSpec `protobuf:"bytes,2,rep,name=Recipients" json:"Recipients,omitempty"`
	// ActionType example: "pushed"
	ActionType string `protobuf:"bytes,3,opt,name=ActionType,proto3" json:"ActionType,omitempty"`
	// ActionContent example: "37 commits"
	ActionContent string `protobuf:"bytes,4,opt,name=ActionContent,proto3" json:"ActionContent,omitempty"`
	// ObjectID example: 71
	ObjectID int64 `protobuf:"varint,5,opt,name=ObjectID,proto3" json:"ObjectID,omitempty"`
	// ObjectRepo example: "gorilla/mux"
	ObjectRepo string `protobuf:"bytes,6,opt,name=ObjectRepo,proto3" json:"ObjectRepo,omitempty"`
	// ObjectType example: "branch"
	ObjectType string `protobuf:"bytes,7,opt,name=ObjectType,proto3" json:"ObjectType,omitempty"`
	// ObjectTitle example: "mybranch"
	ObjectTitle string `protobuf:"bytes,8,opt,name=ObjectTitle,proto3" json:"ObjectTitle,omitempty"`
	// ObjectURL example: "https://sourcegraph.com/sourcegraph/sourcegraph/-/branches/mybranch"
	ObjectURL string `protobuf:"bytes,9,opt,name=ObjectURL,proto3" json:"ObjectURL,omitempty"`
	// SlackMsg, if present, will override the Slack message for this event.
	SlackMsg string `protobuf:"bytes,10,opt,name=SlackMsg,proto3" json:"SlackMsg,omitempty"`
	// EmailHTML, if present, will override the notification email body for this event.
	EmailHTML string `protobuf:"bytes,11,opt,name=EmailHTML,proto3" json:"EmailHTML,omitempty"`
	// NoEmail turns off the email notification for this event.
	NoEmail bool `protobuf:"varint,13,opt,name=NoEmail,proto3" json:"NoEmail,omitempty"`
}

func (m *NotifyGenericEvent) Reset()                    { *m = NotifyGenericEvent{} }
func (m *NotifyGenericEvent) String() string            { return proto.CompactTextString(m) }
func (*NotifyGenericEvent) ProtoMessage()               {}
func (*NotifyGenericEvent) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{141} }

// An Annotation is metadata (such as a srclib ref) attached to a
// portion of a file.
type Annotation struct {
	// URL is the location where more information about the
	// annotation's topic may be found (e.g., for a srclib ref, it's
	// the def's URL).
	URL string `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	// StartByte is the start of the byte range.
	StartByte uint32 `protobuf:"varint,2,opt,name=StartByte,proto3" json:"StartByte"`
	// EndByte is the end of the byte range.
	EndByte uint32 `protobuf:"varint,3,opt,name=EndByte,proto3" json:"EndByte"`
	// Class is the HTML class name that should be applied to this
	// region.
	Class string `protobuf:"bytes,4,opt,name=Class,proto3" json:"Class,omitempty"`
	// Def is whether this annotation marks the definition of the
	// item described in URL or URLs. For example, "Foo" in "func Foo() {}"
	// would have its annotation with Def=true.
	//
	// Marking whether this annotation is a def lets us
	// jump-to-definition here from other refs in the same file
	// without needing to load the defs for those refs.
	Def bool `protobuf:"varint,7,opt,name=Def,proto3" json:"Def,omitempty"`
	// WantInner indicates that this annotation, when being applied to
	// the underlying text, should be inner (i.e., more deeply
	// nested). Larger numbers mean greater precedence for being
	// nested more deeply.
	WantInner int32 `protobuf:"varint,5,opt,name=WantInner,proto3" json:"WantInner,omitempty"`
	// URLs can be set instead of URL if there are multiple URLs on an
	// annotation.
	URLs []string `protobuf:"bytes,6,rep,name=URLs" json:"URLs,omitempty"`
}

func (m *Annotation) Reset()                    { *m = Annotation{} }
func (m *Annotation) String() string            { return proto.CompactTextString(m) }
func (*Annotation) ProtoMessage()               {}
func (*Annotation) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{142} }

// AnnotationList is a list of annotations.
type AnnotationList struct {
	Annotations    []*Annotation `protobuf:"bytes,1,rep,name=Annotations" json:"Annotations,omitempty"`
	LineStartBytes []uint32      `protobuf:"varint,2,rep,name=LineStartBytes" json:"LineStartBytes,omitempty"`
}

func (m *AnnotationList) Reset()                    { *m = AnnotationList{} }
func (m *AnnotationList) String() string            { return proto.CompactTextString(m) }
func (*AnnotationList) ProtoMessage()               {}
func (*AnnotationList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{143} }

// AnnotationsListOptions specifies options for Annotations.List.
type AnnotationsListOptions struct {
	// Entry specifies the file in a specific repository at a specific
	// version.
	Entry TreeEntrySpec `protobuf:"bytes,1,opt,name=Entry" json:"Entry"`
	// Range specifies the range within the file that annotations
	// should be fetched for. If it is not set, then all of the file's
	// annotations are returned.
	Range *FileRange `protobuf:"bytes,2,opt,name=Range" json:"Range,omitempty"`
}

func (m *AnnotationsListOptions) Reset()         { *m = AnnotationsListOptions{} }
func (m *AnnotationsListOptions) String() string { return proto.CompactTextString(m) }
func (*AnnotationsListOptions) ProtoMessage()    {}
func (*AnnotationsListOptions) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{144}
}

// SearchOptions configures the scope of a global search.
type SearchOptions struct {
	// Repos is the list of repos to restrict the results to.
	// If empty, all repos are searched.
	Repos []int32 `protobuf:"varint,1,rep,name=Repos" json:"Repos,omitempty" url:",omitempty"`
	// NotRepos is the list of repos from which to exclude results.
	// If empty, then no repositories are excluded.
	NotRepos []int32 `protobuf:"varint,2,rep,name=NotRepos" json:"NotRepos,omitempty" url:",omitempty"`
	// Languages, if specified, limits the returned results to just the
	// specified languages.
	//
	// The values are case-insensitive, e.g. "java", "Java", and "jAvA" will
	// all match the Java programming language.
	Languages []string `protobuf:"bytes,6,rep,name=Languages" json:"Languages,omitempty"`
	// NotLanguages, if specified, excludes the specified languages from the
	// returned results.
	//
	// The values are case-insensitive, e.g. "java", "Java", and "jAvA" will
	// all exclude the Java programming language.
	NotLanguages []string `protobuf:"bytes,7,rep,name=NotLanguages" json:"NotLanguages,omitempty"`
	// Kinds, if specified, limits the returned results to just the specified
	// kinds of definitions (func, var, etc).
	Kinds []string `protobuf:"bytes,8,rep,name=Kinds" json:"Kinds,omitempty"`
	// NotKinds, if specified, excludes the specified kinds of definitions
	// (func, var, etc) from the returned results.
	NotKinds []string `protobuf:"bytes,9,rep,name=NotKinds" json:"NotKinds,omitempty"`
	// CommitID is the Git commit ID to restrict the results to. This option is
	// only used when filtering by a specific set of repositories.
	// If empty, the latest indexed revision is implied.
	CommitID string `protobuf:"bytes,10,opt,name=CommitID,proto3" json:"CommitID,omitempty"`
	// ListOptions specifies options for paginating
	// the result.
	ListOptions `protobuf:"bytes,3,opt,name=ListOptions,embedded=ListOptions" json:""`
	// IncludeRepos indicates whether to include repository search results.
	IncludeRepos bool `protobuf:"varint,4,opt,name=IncludeRepos,proto3" json:"IncludeRepos,omitempty"`
	// PrefixMatch indicates whether to include defs prefix match on search results.
	PrefixMatch bool `protobuf:"varint,5,opt,name=PrefixMatch,proto3" json:"PrefixMatch,omitempty"`
	// Fast specifies that the client would like results returned more quickly at
	// the cost of missing lower ranked results. If there are no high-ranking results
	// and Fast is set to true, there may be no results returned at all.
	Fast bool `protobuf:"varint,11,opt,name=Fast,proto3" json:"Fast,omitempty"`
	// Latest indicates that the search should only search over the latest indexed revision of repositories.
	Latest bool `protobuf:"varint,12,opt,name=Latest,proto3" json:"Latest,omitempty"`
}

func (m *SearchOptions) Reset()                    { *m = SearchOptions{} }
func (m *SearchOptions) String() string            { return proto.CompactTextString(m) }
func (*SearchOptions) ProtoMessage()               {}
func (*SearchOptions) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{145} }

// SearchOp holds the options for global search for a given query.
type SearchOp struct {
	// Query is the text string being searched for.
	Query string `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	// Opt controls the scope of the search.
	Opt *SearchOptions `protobuf:"bytes,2,opt,name=Opt" json:"Opt,omitempty"`
}

func (m *SearchOp) Reset()                    { *m = SearchOp{} }
func (m *SearchOp) String() string            { return proto.CompactTextString(m) }
func (*SearchOp) ProtoMessage()               {}
func (*SearchOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{146} }

// RepoSearchResult holds a result of a global repo search.
type RepoSearchResult struct {
	// Repo represents a source code repository.
	Repo *Repo `protobuf:"bytes,1,opt,name=Repo" json:"Repo,omitempty"`
}

func (m *RepoSearchResult) Reset()                    { *m = RepoSearchResult{} }
func (m *RepoSearchResult) String() string            { return proto.CompactTextString(m) }
func (*RepoSearchResult) ProtoMessage()               {}
func (*RepoSearchResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{147} }

// DefSearchResult holds a result of a global def search.
type DefSearchResult struct {
	// Def is the def matching the search query.
	Def `protobuf:"bytes,1,opt,name=Def,embedded=Def" json:""`
	// Score is the computed relevance of this result to the search query.
	Score float32 `protobuf:"fixed32,2,opt,name=Score,proto3" json:"Score,omitempty"`
	// RefCount is global ref count for this def.
	RefCount int32 `protobuf:"varint,3,opt,name=RefCount,proto3" json:"RefCount,omitempty"`
}

func (m *DefSearchResult) Reset()                    { *m = DefSearchResult{} }
func (m *DefSearchResult) String() string            { return proto.CompactTextString(m) }
func (*DefSearchResult) ProtoMessage()               {}
func (*DefSearchResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{148} }

// SearchResultsList is a list of results to a global search.
type SearchResultsList struct {
	// RepoResults is the list of repo search results
	RepoResults []*RepoSearchResult `protobuf:"bytes,1,rep,name=RepoResults" json:"RepoResults,omitempty"`
	// DefResults is the list of def search results
	DefResults []*DefSearchResult `protobuf:"bytes,2,rep,name=DefResults" json:"DefResults,omitempty"`
	// SearchOptions is a list of options to a global search query.
	SearchQueryOptions []*SearchOptions `protobuf:"bytes,3,rep,name=SearchQueryOptions" json:"SearchQueryOptions,omitempty"`
}

func (m *SearchResultsList) Reset()                    { *m = SearchResultsList{} }
func (m *SearchResultsList) String() string            { return proto.CompactTextString(m) }
func (*SearchResultsList) ProtoMessage()               {}
func (*SearchResultsList) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{149} }

type SearchRefreshIndexOp struct {
	// Repos is the list of repos whose graph data is to be re-indexed
	// for global search.
	Repos []int32 `protobuf:"varint,1,rep,name=Repos" json:"Repos,omitempty"`
	// RefreshCounts refreshes the global xref counts for the specified
	// repositories.
	RefreshCounts bool `protobuf:"varint,2,opt,name=RefreshCounts,proto3" json:"RefreshCounts,omitempty"`
	// RefreshSearch refreshes the global search index for the specified
	// repositories.
	RefreshSearch bool `protobuf:"varint,3,opt,name=RefreshSearch,proto3" json:"RefreshSearch,omitempty"`
}

func (m *SearchRefreshIndexOp) Reset()         { *m = SearchRefreshIndexOp{} }
func (m *SearchRefreshIndexOp) String() string { return proto.CompactTextString(m) }
func (*SearchRefreshIndexOp) ProtoMessage()    {}
func (*SearchRefreshIndexOp) Descriptor() ([]byte, []int) {
	return fileDescriptorSourcegraph, []int{150}
}

// ChannelListenOp is provided to a Channel.Listen call to initiate listening.
type ChannelListenOp struct {
	// Channel is the channel name to start listening for actions on.
	//
	// TODO(sqs): figure out how to separate channels, not rely on
	// clients to create strong/secure channel names, and prevent
	// guessing channels to snoop on other people's activity.
	Channel string `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
}

func (m *ChannelListenOp) Reset()                    { *m = ChannelListenOp{} }
func (m *ChannelListenOp) String() string            { return proto.CompactTextString(m) }
func (*ChannelListenOp) ProtoMessage()               {}
func (*ChannelListenOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{151} }

// A ChannelAction is an action sent to all listeners on a given channel.
type ChannelAction struct {
	// Error is the title of the error that is occuring client-side
	// Not used in latest version, since these errors shown editor side, potentially used in future
	Error string `protobuf:"bytes,1,opt,name=Error,proto3" json:"Error,omitempty"`
	// Fix is the Fix for the Error occurring client-side
	// Not used in latest version, since these errors shown editor side, potentially used in future
	Fix string `protobuf:"bytes,2,opt,name=Fix,proto3" json:"Fix,omitempty"`
	// Package is a the package of the token under the cursor
	Package string `protobuf:"bytes,3,opt,name=Package,proto3" json:"Package,omitempty"`
	// Repo is the repo that the package belongs to
	Repo string `protobuf:"bytes,4,opt,name=Repo,proto3" json:"Repo,omitempty"`
	// Def is the definition
	Def string `protobuf:"bytes,5,opt,name=Def,proto3" json:"Def,omitempty"`
	// Status is the status code, 1 for successful lookup, 0 for editor doesn't recognize symbol
	Status int32 `protobuf:"varint,6,opt,name=Status,proto3" json:"Status"`
	// VersionMajor and VersionMinor are the plugin versions, i.e. 'Major:0' 'Minor:1' is 0.1
	VersionMajor int32 `protobuf:"varint,7,opt,name=VersionMajor,proto3" json:"VersionMajor"`
	VersionMinor int32 `protobuf:"varint,8,opt,name=VersionMinor,proto3" json:"VersionMinor"`
	// Editor type is the type of editor, i.e. 'sublime'
	EditorType string `protobuf:"bytes,9,opt,name=EditorType,proto3" json:"EditorType,omitempty"`
}

func (m *ChannelAction) Reset()                    { *m = ChannelAction{} }
func (m *ChannelAction) String() string            { return proto.CompactTextString(m) }
func (*ChannelAction) ProtoMessage()               {}
func (*ChannelAction) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{152} }

// ChannelSendResult is provided to a Channel.Send call to send an action
// to all listeners on a given channel.
type ChannelSendOp struct {
	// Channel is the channel name whose listeners should receive this
	// action.
	Channel string `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	// Action is the action to send.
	Action ChannelAction `protobuf:"bytes,2,opt,name=Action" json:"Action"`
	// CheckForListeners is whether the Channel.Send call should wait to see
	// if there are any listeners on the channel.
	CheckForListeners bool `protobuf:"varint,3,opt,name=CheckForListeners,proto3" json:"CheckForListeners,omitempty"`
}

func (m *ChannelSendOp) Reset()                    { *m = ChannelSendOp{} }
func (m *ChannelSendOp) String() string            { return proto.CompactTextString(m) }
func (*ChannelSendOp) ProtoMessage()               {}
func (*ChannelSendOp) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{153} }

// ChannelSendResult describes the result of a Channel.Send call.
type ChannelSendResult struct {
}

func (m *ChannelSendResult) Reset()                    { *m = ChannelSendResult{} }
func (m *ChannelSendResult) String() string            { return proto.CompactTextString(m) }
func (*ChannelSendResult) ProtoMessage()               {}
func (*ChannelSendResult) Descriptor() ([]byte, []int) { return fileDescriptorSourcegraph, []int{154} }

func init() {
	proto.RegisterType((*Origin)(nil), "sourcegraph.Origin")
	proto.RegisterType((*CombinedStatus)(nil), "sourcegraph.CombinedStatus")
	proto.RegisterType((*ListOptions)(nil), "sourcegraph.ListOptions")
	proto.RegisterType((*ListResponse)(nil), "sourcegraph.ListResponse")
	proto.RegisterType((*StreamResponse)(nil), "sourcegraph.StreamResponse")
	proto.RegisterType((*RepoConfig)(nil), "sourcegraph.RepoConfig")
	proto.RegisterType((*Repo)(nil), "sourcegraph.Repo")
	proto.RegisterType((*RepoListOptions)(nil), "sourcegraph.RepoListOptions")
	proto.RegisterType((*RepoRevSpec)(nil), "sourcegraph.RepoRevSpec")
	proto.RegisterType((*RepoSpec)(nil), "sourcegraph.RepoSpec")
	proto.RegisterType((*RepoStatus)(nil), "sourcegraph.RepoStatus")
	proto.RegisterType((*RepoStatusList)(nil), "sourcegraph.RepoStatusList")
	proto.RegisterType((*RepoStatusesCreateOp)(nil), "sourcegraph.RepoStatusesCreateOp")
	proto.RegisterType((*RepoList)(nil), "sourcegraph.RepoList")
	proto.RegisterType((*ReposResolveRevOp)(nil), "sourcegraph.ReposResolveRevOp")
	proto.RegisterType((*ResolvedRev)(nil), "sourcegraph.ResolvedRev")
	proto.RegisterType((*ReceivePackOp)(nil), "sourcegraph.ReceivePackOp")
	proto.RegisterType((*UploadPackOp)(nil), "sourcegraph.UploadPackOp")
	proto.RegisterType((*Packet)(nil), "sourcegraph.Packet")
	proto.RegisterType((*RepoResolveOp)(nil), "sourcegraph.RepoResolveOp")
	proto.RegisterType((*RepoResolution)(nil), "sourcegraph.RepoResolution")
	proto.RegisterType((*ReposListRemoteOptions)(nil), "sourcegraph.ReposListRemoteOptions")
	proto.RegisterType((*RemoteRepoList)(nil), "sourcegraph.RemoteRepoList")
	proto.RegisterType((*SrclibDataVersion)(nil), "sourcegraph.SrclibDataVersion")
	proto.RegisterType((*RepoConfigureAppOp)(nil), "sourcegraph.RepoConfigureAppOp")
	proto.RegisterType((*ReposCreateOp)(nil), "sourcegraph.ReposCreateOp")
	proto.RegisterType((*ReposCreateOp_NewRepo)(nil), "sourcegraph.ReposCreateOp.NewRepo")
	proto.RegisterType((*ReposUpdateOp)(nil), "sourcegraph.ReposUpdateOp")
	proto.RegisterType((*ReposListCommitsOp)(nil), "sourcegraph.ReposListCommitsOp")
	proto.RegisterType((*RepoListCommitsOptions)(nil), "sourcegraph.RepoListCommitsOptions")
	proto.RegisterType((*CommitList)(nil), "sourcegraph.CommitList")
	proto.RegisterType((*ReposListBranchesOp)(nil), "sourcegraph.ReposListBranchesOp")
	proto.RegisterType((*RepoListBranchesOptions)(nil), "sourcegraph.RepoListBranchesOptions")
	proto.RegisterType((*BranchList)(nil), "sourcegraph.BranchList")
	proto.RegisterType((*ReposListTagsOp)(nil), "sourcegraph.ReposListTagsOp")
	proto.RegisterType((*ReposListCommittersOp)(nil), "sourcegraph.ReposListCommittersOp")
	proto.RegisterType((*RepoListCommittersOptions)(nil), "sourcegraph.RepoListCommittersOptions")
	proto.RegisterType((*CommitterList)(nil), "sourcegraph.CommitterList")
	proto.RegisterType((*RepoListTagsOptions)(nil), "sourcegraph.RepoListTagsOptions")
	proto.RegisterType((*TagList)(nil), "sourcegraph.TagList")
	proto.RegisterType((*MirrorReposRefreshVCSOp)(nil), "sourcegraph.MirrorReposRefreshVCSOp")
	proto.RegisterType((*VCSCredentials)(nil), "sourcegraph.VCSCredentials")
	proto.RegisterType((*RemoteRepo)(nil), "sourcegraph.RemoteRepo")
	proto.RegisterType((*Build)(nil), "sourcegraph.Build")
	proto.RegisterType((*BuildConfig)(nil), "sourcegraph.BuildConfig")
	proto.RegisterType((*BuildJob)(nil), "sourcegraph.BuildJob")
	proto.RegisterType((*BuildGetLogOptions)(nil), "sourcegraph.BuildGetLogOptions")
	proto.RegisterType((*BuildListOptions)(nil), "sourcegraph.BuildListOptions")
	proto.RegisterType((*BuildSpec)(nil), "sourcegraph.BuildSpec")
	proto.RegisterType((*BuildTask)(nil), "sourcegraph.BuildTask")
	proto.RegisterType((*BuildTaskListOptions)(nil), "sourcegraph.BuildTaskListOptions")
	proto.RegisterType((*BuildUpdate)(nil), "sourcegraph.BuildUpdate")
	proto.RegisterType((*BuildList)(nil), "sourcegraph.BuildList")
	proto.RegisterType((*BuildsCreateOp)(nil), "sourcegraph.BuildsCreateOp")
	proto.RegisterType((*BuildsUpdateOp)(nil), "sourcegraph.BuildsUpdateOp")
	proto.RegisterType((*BuildsListBuildTasksOp)(nil), "sourcegraph.BuildsListBuildTasksOp")
	proto.RegisterType((*BuildTaskList)(nil), "sourcegraph.BuildTaskList")
	proto.RegisterType((*BuildsCreateTasksOp)(nil), "sourcegraph.BuildsCreateTasksOp")
	proto.RegisterType((*BuildsUpdateTaskOp)(nil), "sourcegraph.BuildsUpdateTaskOp")
	proto.RegisterType((*BuildsGetTaskLogOp)(nil), "sourcegraph.BuildsGetTaskLogOp")
	proto.RegisterType((*BuildsDequeueNextOp)(nil), "sourcegraph.BuildsDequeueNextOp")
	proto.RegisterType((*EmailAddr)(nil), "sourcegraph.EmailAddr")
	proto.RegisterType((*LogEntries)(nil), "sourcegraph.LogEntries")
	proto.RegisterType((*Org)(nil), "sourcegraph.Org")
	proto.RegisterType((*OrgListMembersOptions)(nil), "sourcegraph.OrgListMembersOptions")
	proto.RegisterType((*OrgSpec)(nil), "sourcegraph.OrgSpec")
	proto.RegisterType((*OrgsListMembersOp)(nil), "sourcegraph.OrgsListMembersOp")
	proto.RegisterType((*UserList)(nil), "sourcegraph.UserList")
	proto.RegisterType((*UserCount)(nil), "sourcegraph.UserCount")
	proto.RegisterType((*Person)(nil), "sourcegraph.Person")
	proto.RegisterType((*PersonSpec)(nil), "sourcegraph.PersonSpec")
	proto.RegisterType((*TaskSpec)(nil), "sourcegraph.TaskSpec")
	proto.RegisterType((*TaskUpdate)(nil), "sourcegraph.TaskUpdate")
	proto.RegisterType((*User)(nil), "sourcegraph.User")
	proto.RegisterType((*UserSpec)(nil), "sourcegraph.UserSpec")
	proto.RegisterType((*UsersListOptions)(nil), "sourcegraph.UsersListOptions")
	proto.RegisterType((*OrgsListOp)(nil), "sourcegraph.OrgsListOp")
	proto.RegisterType((*EmailAddrList)(nil), "sourcegraph.EmailAddrList")
	proto.RegisterType((*OrgList)(nil), "sourcegraph.OrgList")
	proto.RegisterType((*CreatedAccount)(nil), "sourcegraph.CreatedAccount")
	proto.RegisterType((*PasswordResetToken)(nil), "sourcegraph.PasswordResetToken")
	proto.RegisterType((*PendingPasswordReset)(nil), "sourcegraph.PendingPasswordReset")
	proto.RegisterType((*NewPassword)(nil), "sourcegraph.NewPassword")
	proto.RegisterType((*NewAccount)(nil), "sourcegraph.NewAccount")
	proto.RegisterType((*LoginCredentials)(nil), "sourcegraph.LoginCredentials")
	proto.RegisterType((*GitHubAuthCode)(nil), "sourcegraph.GitHubAuthCode")
	proto.RegisterType((*AccessTokenRequest)(nil), "sourcegraph.AccessTokenRequest")
	proto.RegisterType((*AccessTokenResponse)(nil), "sourcegraph.AccessTokenResponse")
	proto.RegisterType((*GitHubUser)(nil), "sourcegraph.GitHubUser")
	proto.RegisterType((*AuthInfo)(nil), "sourcegraph.AuthInfo")
	proto.RegisterType((*ExternalTokenSpec)(nil), "sourcegraph.ExternalTokenSpec")
	proto.RegisterType((*ExternalToken)(nil), "sourcegraph.ExternalToken")
	proto.RegisterType((*Def)(nil), "sourcegraph.Def")
	proto.RegisterType((*DefGetOptions)(nil), "sourcegraph.DefGetOptions")
	proto.RegisterType((*DefListOptions)(nil), "sourcegraph.DefListOptions")
	proto.RegisterType((*DefListRefsOptions)(nil), "sourcegraph.DefListRefsOptions")
	proto.RegisterType((*DefSpec)(nil), "sourcegraph.DefSpec")
	proto.RegisterType((*DefsGetOp)(nil), "sourcegraph.DefsGetOp")
	proto.RegisterType((*DefList)(nil), "sourcegraph.DefList")
	proto.RegisterType((*DefsListRefsOp)(nil), "sourcegraph.DefsListRefsOp")
	proto.RegisterType((*RefList)(nil), "sourcegraph.RefList")
	proto.RegisterType((*DefListRefLocationsOptions)(nil), "sourcegraph.DefListRefLocationsOptions")
	proto.RegisterType((*DefsListRefLocationsOp)(nil), "sourcegraph.DefsListRefLocationsOp")
	proto.RegisterType((*DefsListExamplesOp)(nil), "sourcegraph.DefsListExamplesOp")
	proto.RegisterType((*RefLocationsList)(nil), "sourcegraph.RefLocationsList")
	proto.RegisterType((*DefRepoRef)(nil), "sourcegraph.DefRepoRef")
	proto.RegisterType((*DefFileRef)(nil), "sourcegraph.DefFileRef")
	proto.RegisterType((*Delta)(nil), "sourcegraph.Delta")
	proto.RegisterType((*FileDiff)(nil), "sourcegraph.FileDiff")
	proto.RegisterType((*DeltaFiles)(nil), "sourcegraph.DeltaFiles")
	proto.RegisterType((*DeltaFilter)(nil), "sourcegraph.DeltaFilter")
	proto.RegisterType((*DeltaListFilesOptions)(nil), "sourcegraph.DeltaListFilesOptions")
	proto.RegisterType((*DeltaSpec)(nil), "sourcegraph.DeltaSpec")
	proto.RegisterType((*DeltasListFilesOp)(nil), "sourcegraph.DeltasListFilesOp")
	proto.RegisterType((*RepoTreeGetOptions)(nil), "sourcegraph.RepoTreeGetOptions")
	proto.RegisterType((*GetFileOptions)(nil), "sourcegraph.GetFileOptions")
	proto.RegisterType((*RepoTreeSearchOptions)(nil), "sourcegraph.RepoTreeSearchOptions")
	proto.RegisterType((*RepoTreeSearchResult)(nil), "sourcegraph.RepoTreeSearchResult")
	proto.RegisterType((*RepoTreeGetOp)(nil), "sourcegraph.RepoTreeGetOp")
	proto.RegisterType((*RepoTreeSearchOp)(nil), "sourcegraph.RepoTreeSearchOp")
	proto.RegisterType((*RepoTreeListOp)(nil), "sourcegraph.RepoTreeListOp")
	proto.RegisterType((*RepoTreeListResult)(nil), "sourcegraph.RepoTreeListResult")
	proto.RegisterType((*VCSSearchResultList)(nil), "sourcegraph.VCSSearchResultList")
	proto.RegisterType((*TreeEntry)(nil), "sourcegraph.TreeEntry")
	proto.RegisterType((*BasicTreeEntry)(nil), "sourcegraph.BasicTreeEntry")
	proto.RegisterType((*TreeEntrySpec)(nil), "sourcegraph.TreeEntrySpec")
	proto.RegisterType((*FileRange)(nil), "sourcegraph.FileRange")
	proto.RegisterType((*DefsRefreshIndexOp)(nil), "sourcegraph.DefsRefreshIndexOp")
	proto.RegisterType((*AsyncRefreshIndexesOp)(nil), "sourcegraph.AsyncRefreshIndexesOp")
	proto.RegisterType((*AuthorshipInfo)(nil), "sourcegraph.AuthorshipInfo")
	proto.RegisterType((*DefAuthor)(nil), "sourcegraph.DefAuthor")
	proto.RegisterType((*DefAuthorship)(nil), "sourcegraph.DefAuthorship")
	proto.RegisterType((*DefListAuthorsOptions)(nil), "sourcegraph.DefListAuthorsOptions")
	proto.RegisterType((*DefsListAuthorsOp)(nil), "sourcegraph.DefsListAuthorsOp")
	proto.RegisterType((*DefAuthorList)(nil), "sourcegraph.DefAuthorList")
	proto.RegisterType((*Checklist)(nil), "sourcegraph.Checklist")
	proto.RegisterType((*FileToken)(nil), "sourcegraph.FileToken")
	proto.RegisterType((*ServerStatus)(nil), "sourcegraph.ServerStatus")
	proto.RegisterType((*ServerConfig)(nil), "sourcegraph.ServerConfig")
	proto.RegisterType((*UserEvent)(nil), "sourcegraph.UserEvent")
	proto.RegisterType((*Event)(nil), "sourcegraph.Event")
	proto.RegisterType((*EventList)(nil), "sourcegraph.EventList")
	proto.RegisterType((*NotifyGenericEvent)(nil), "sourcegraph.NotifyGenericEvent")
	proto.RegisterType((*Annotation)(nil), "sourcegraph.Annotation")
	proto.RegisterType((*AnnotationList)(nil), "sourcegraph.AnnotationList")
	proto.RegisterType((*AnnotationsListOptions)(nil), "sourcegraph.AnnotationsListOptions")
	proto.RegisterType((*SearchOptions)(nil), "sourcegraph.SearchOptions")
	proto.RegisterType((*SearchOp)(nil), "sourcegraph.SearchOp")
	proto.RegisterType((*RepoSearchResult)(nil), "sourcegraph.RepoSearchResult")
	proto.RegisterType((*DefSearchResult)(nil), "sourcegraph.DefSearchResult")
	proto.RegisterType((*SearchResultsList)(nil), "sourcegraph.SearchResultsList")
	proto.RegisterType((*SearchRefreshIndexOp)(nil), "sourcegraph.SearchRefreshIndexOp")
	proto.RegisterType((*ChannelListenOp)(nil), "sourcegraph.ChannelListenOp")
	proto.RegisterType((*ChannelAction)(nil), "sourcegraph.ChannelAction")
	proto.RegisterType((*ChannelSendOp)(nil), "sourcegraph.ChannelSendOp")
	proto.RegisterType((*ChannelSendResult)(nil), "sourcegraph.ChannelSendResult")
	proto.RegisterEnum("sourcegraph.TreeEntryType", TreeEntryType_name, TreeEntryType_value)
	proto.RegisterEnum("sourcegraph.Origin_ServiceType", Origin_ServiceType_name, Origin_ServiceType_value)
	proto.RegisterEnum("sourcegraph.ReposUpdateOp_BoolType", ReposUpdateOp_BoolType_name, ReposUpdateOp_BoolType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for RepoStatuses service

type RepoStatusesClient interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error)
	// GetCoverage fetches the coverage data for all repositories.
	GetCoverage(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RepoStatusList, error)
	// Create creates a repository status for the given commit.
	Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error)
}

type repoStatusesClient struct {
	cc *grpc.ClientConn
}

func NewRepoStatusesClient(cc *grpc.ClientConn) RepoStatusesClient {
	return &repoStatusesClient{cc}
}

func (c *repoStatusesClient) GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error) {
	out := new(CombinedStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCombined", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) GetCoverage(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RepoStatusList, error) {
	out := new(RepoStatusList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCoverage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error) {
	out := new(RepoStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoStatuses service

type RepoStatusesServer interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(context.Context, *RepoRevSpec) (*CombinedStatus, error)
	// GetCoverage fetches the coverage data for all repositories.
	GetCoverage(context.Context, *pbtypes1.Void) (*RepoStatusList, error)
	// Create creates a repository status for the given commit.
	Create(context.Context, *RepoStatusesCreateOp) (*RepoStatus, error)
}

func RegisterRepoStatusesServer(s *grpc.Server, srv RepoStatusesServer) {
	s.RegisterService(&_RepoStatuses_serviceDesc, srv)
}

func _RepoStatuses_GetCombined_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCombined(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_GetCoverage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCoverage(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoStatusesCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoStatuses_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoStatuses",
	HandlerType: (*RepoStatusesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCombined",
			Handler:    _RepoStatuses_GetCombined_Handler,
		},
		{
			MethodName: "GetCoverage",
			Handler:    _RepoStatuses_GetCoverage_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RepoStatuses_Create_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Repos service

type ReposClient interface {
	// Get fetches a repository.
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error)
	// Resolve looks up a repo from its "path", which is a
	// slash-separated string (e.g., "github.com/user/repo"). Resolve
	// may have to consult external sources (such as GitHub) to
	// resolve a path. It returns the repo's ID if it has been created
	// on Sourcegraph, plus additional metadata about the repository
	// that was determined during the resolution operation.
	//
	// Example use case: The app calls Resolve to support navigating
	// directly to "https://sourcegraph.com/github.com/my/repo" when
	// that has not been created yet. It calls Resolve with
	// "github.com/my/repo". It will transparently call Repos.Create
	// if it gets a RemoteRepo back from Resolve.
	Resolve(ctx context.Context, in *RepoResolveOp, opts ...grpc.CallOption) (*RepoResolution, error)
	// List repositories.
	List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error)
	// List remote repositories (on GitHub) associated with the
	// currently authenticated actor.
	ListRemote(ctx context.Context, in *ReposListRemoteOptions, opts ...grpc.CallOption) (*RemoteRepoList, error)
	// Create creates a new repository.
	Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error)
	// Update updates a repository.
	Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error)
	// Delete removes a repository.
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error)
	// ResolveRev resolves a VCS revision specifier (e.g., a branch or
	// "master~7") to its underlying commit ID.
	ResolveRev(ctx context.Context, in *ReposResolveRevOp, opts ...grpc.CallOption) (*ResolvedRev, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error)
	ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error)
	ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error)
	// ConfigureApp configures an application for a repository.
	ConfigureApp(ctx context.Context, in *RepoConfigureAppOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error)
	ReceivePack(ctx context.Context, in *ReceivePackOp, opts ...grpc.CallOption) (*Packet, error)
	UploadPack(ctx context.Context, in *UploadPackOp, opts ...grpc.CallOption) (*Packet, error)
}

type reposClient struct {
	cc *grpc.ClientConn
}

func NewReposClient(cc *grpc.ClientConn) ReposClient {
	return &reposClient{cc}
}

func (c *reposClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Resolve(ctx context.Context, in *RepoResolveOp, opts ...grpc.CallOption) (*RepoResolution, error) {
	out := new(RepoResolution)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Resolve", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error) {
	out := new(RepoList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListRemote(ctx context.Context, in *ReposListRemoteOptions, opts ...grpc.CallOption) (*RemoteRepoList, error) {
	out := new(RemoteRepoList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListRemote", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Update(ctx context.Context, in *ReposUpdateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error) {
	out := new(RepoConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error) {
	out := new(vcs.Commit)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ResolveRev(ctx context.Context, in *ReposResolveRevOp, opts ...grpc.CallOption) (*ResolvedRev, error) {
	out := new(ResolvedRev)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ResolveRev", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error) {
	out := new(CommitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error) {
	out := new(BranchList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListBranches", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error) {
	out := new(TagList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error) {
	out := new(CommitterList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommitters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetSrclibDataVersionForPath(ctx context.Context, in *TreeEntrySpec, opts ...grpc.CallOption) (*SrclibDataVersion, error) {
	out := new(SrclibDataVersion)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetSrclibDataVersionForPath", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ConfigureApp(ctx context.Context, in *RepoConfigureAppOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ConfigureApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetInventory(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*inventory.Inventory, error) {
	out := new(inventory.Inventory)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetInventory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ReceivePack(ctx context.Context, in *ReceivePackOp, opts ...grpc.CallOption) (*Packet, error) {
	out := new(Packet)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ReceivePack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) UploadPack(ctx context.Context, in *UploadPackOp, opts ...grpc.CallOption) (*Packet, error) {
	out := new(Packet)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/UploadPack", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repos service

type ReposServer interface {
	// Get fetches a repository.
	Get(context.Context, *RepoSpec) (*Repo, error)
	// Resolve looks up a repo from its "path", which is a
	// slash-separated string (e.g., "github.com/user/repo"). Resolve
	// may have to consult external sources (such as GitHub) to
	// resolve a path. It returns the repo's ID if it has been created
	// on Sourcegraph, plus additional metadata about the repository
	// that was determined during the resolution operation.
	//
	// Example use case: The app calls Resolve to support navigating
	// directly to "https://sourcegraph.com/github.com/my/repo" when
	// that has not been created yet. It calls Resolve with
	// "github.com/my/repo". It will transparently call Repos.Create
	// if it gets a RemoteRepo back from Resolve.
	Resolve(context.Context, *RepoResolveOp) (*RepoResolution, error)
	// List repositories.
	List(context.Context, *RepoListOptions) (*RepoList, error)
	// List remote repositories (on GitHub) associated with the
	// currently authenticated actor.
	ListRemote(context.Context, *ReposListRemoteOptions) (*RemoteRepoList, error)
	// Create creates a new repository.
	Create(context.Context, *ReposCreateOp) (*Repo, error)
	// Update updates a repository.
	Update(context.Context, *ReposUpdateOp) (*Repo, error)
	// Delete removes a repository.
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// GetConfig retrieves the configuration for a repository.
	GetConfig(context.Context, *RepoSpec) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	GetCommit(context.Context, *RepoRevSpec) (*vcs.Commit, error)
	// ResolveRev resolves a VCS revision specifier (e.g., a branch or
	// "master~7") to its underlying commit ID.
	ResolveRev(context.Context, *ReposResolveRevOp) (*ResolvedRev, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(context.Context, *ReposListCommitsOp) (*CommitList, error)
	ListBranches(context.Context, *ReposListBranchesOp) (*BranchList, error)
	ListTags(context.Context, *ReposListTagsOp) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(context.Context, *ReposListCommittersOp) (*CommitterList, error)
	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	GetSrclibDataVersionForPath(context.Context, *TreeEntrySpec) (*SrclibDataVersion, error)
	// ConfigureApp configures an application for a repository.
	ConfigureApp(context.Context, *RepoConfigureAppOp) (*pbtypes1.Void, error)
	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	GetInventory(context.Context, *RepoRevSpec) (*inventory.Inventory, error)
	ReceivePack(context.Context, *ReceivePackOp) (*Packet, error)
	UploadPack(context.Context, *UploadPackOp) (*Packet, error)
}

func RegisterReposServer(s *grpc.Server, srv ReposServer) {
	s.RegisterService(&_Repos_serviceDesc, srv)
}

func _Repos_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Resolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoResolveOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Resolve(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListRemote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListRemoteOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListRemote(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetConfig(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetCommit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ResolveRev_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposResolveRevOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ResolveRev(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommitsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListBranchesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListBranches(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListTagsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListTags(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommitters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReposListCommittersOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommitters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetSrclibDataVersionForPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(TreeEntrySpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetSrclibDataVersionForPath(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ConfigureApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoConfigureAppOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ConfigureApp(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetInventory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetInventory(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ReceivePack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ReceivePackOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ReceivePack(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_UploadPack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UploadPackOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).UploadPack(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Repos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Repos",
	HandlerType: (*ReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Repos_Get_Handler,
		},
		{
			MethodName: "Resolve",
			Handler:    _Repos_Resolve_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Repos_List_Handler,
		},
		{
			MethodName: "ListRemote",
			Handler:    _Repos_ListRemote_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Repos_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Repos_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Repos_Delete_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _Repos_GetConfig_Handler,
		},
		{
			MethodName: "GetCommit",
			Handler:    _Repos_GetCommit_Handler,
		},
		{
			MethodName: "ResolveRev",
			Handler:    _Repos_ResolveRev_Handler,
		},
		{
			MethodName: "ListCommits",
			Handler:    _Repos_ListCommits_Handler,
		},
		{
			MethodName: "ListBranches",
			Handler:    _Repos_ListBranches_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _Repos_ListTags_Handler,
		},
		{
			MethodName: "ListCommitters",
			Handler:    _Repos_ListCommitters_Handler,
		},
		{
			MethodName: "GetSrclibDataVersionForPath",
			Handler:    _Repos_GetSrclibDataVersionForPath_Handler,
		},
		{
			MethodName: "ConfigureApp",
			Handler:    _Repos_ConfigureApp_Handler,
		},
		{
			MethodName: "GetInventory",
			Handler:    _Repos_GetInventory_Handler,
		},
		{
			MethodName: "ReceivePack",
			Handler:    _Repos_ReceivePack_Handler,
		},
		{
			MethodName: "UploadPack",
			Handler:    _Repos_UploadPack_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirrorRepos service

type MirrorReposClient interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirrorReposClient struct {
	cc *grpc.ClientConn
}

func NewMirrorReposClient(cc *grpc.ClientConn) MirrorReposClient {
	return &mirrorReposClient{cc}
}

func (c *mirrorReposClient) RefreshVCS(ctx context.Context, in *MirrorReposRefreshVCSOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirrorRepos/RefreshVCS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorRepos service

type MirrorReposServer interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(context.Context, *MirrorReposRefreshVCSOp) (*pbtypes1.Void, error)
}

func RegisterMirrorReposServer(s *grpc.Server, srv MirrorReposServer) {
	s.RegisterService(&_MirrorRepos_serviceDesc, srv)
}

func _MirrorRepos_RefreshVCS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(MirrorReposRefreshVCSOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MirrorReposServer).RefreshVCS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirrorRepos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirrorRepos",
	HandlerType: (*MirrorReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshVCS",
			Handler:    _MirrorRepos_RefreshVCS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Builds service

type BuildsClient interface {
	// Get fetches a build.
	Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error)
	// List builds.
	List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*BuildJob, error)
}

type buildsClient struct {
	cc *grpc.ClientConn
}

func NewBuildsClient(cc *grpc.ClientConn) BuildsClient {
	return &buildsClient{cc}
}

func (c *buildsClient) Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error) {
	out := new(BuildList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/ListBuildTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/CreateTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error) {
	out := new(BuildTask)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/UpdateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error) {
	out := new(LogEntries)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetTaskLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*BuildJob, error) {
	out := new(BuildJob)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/DequeueNext", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Builds service

type BuildsServer interface {
	// Get fetches a build.
	Get(context.Context, *BuildSpec) (*Build, error)
	// List builds.
	List(context.Context, *BuildListOptions) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(context.Context, *BuildsCreateOp) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(context.Context, *BuildsUpdateOp) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(context.Context, *BuildsListBuildTasksOp) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(context.Context, *BuildsCreateTasksOp) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(context.Context, *BuildsUpdateTaskOp) (*BuildTask, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(context.Context, *BuildsGetTaskLogOp) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(context.Context, *BuildsDequeueNextOp) (*BuildJob, error)
}

func RegisterBuildsServer(s *grpc.Server, srv BuildsServer) {
	s.RegisterService(&_Builds_serviceDesc, srv)
}

func _Builds_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsCreateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsUpdateOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_ListBuildTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsListBuildTasksOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).ListBuildTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_CreateTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsCreateTasksOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).CreateTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsUpdateTaskOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).UpdateTask(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetTaskLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsGetTaskLogOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetTaskLog(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_DequeueNext_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(BuildsDequeueNextOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).DequeueNext(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Builds_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Builds",
	HandlerType: (*BuildsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Builds_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Builds_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Builds_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Builds_Update_Handler,
		},
		{
			MethodName: "ListBuildTasks",
			Handler:    _Builds_ListBuildTasks_Handler,
		},
		{
			MethodName: "CreateTasks",
			Handler:    _Builds_CreateTasks_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Builds_UpdateTask_Handler,
		},
		{
			MethodName: "GetTaskLog",
			Handler:    _Builds_GetTaskLog_Handler,
		},
		{
			MethodName: "DequeueNext",
			Handler:    _Builds_DequeueNext_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Orgs service

type OrgsClient interface {
	// Get fetches an organization.
	Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error)
	// List lists organizations that a user is a member of.
	List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error)
}

type orgsClient struct {
	cc *grpc.ClientConn
}

func NewOrgsClient(cc *grpc.ClientConn) OrgsClient {
	return &orgsClient{cc}
}

func (c *orgsClient) Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error) {
	out := new(Org)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error) {
	out := new(OrgList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/ListMembers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Orgs service

type OrgsServer interface {
	// Get fetches an organization.
	Get(context.Context, *OrgSpec) (*Org, error)
	// List lists organizations that a user is a member of.
	List(context.Context, *OrgsListOp) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(context.Context, *OrgsListMembersOp) (*UserList, error)
}

func RegisterOrgsServer(s *grpc.Server, srv OrgsServer) {
	s.RegisterService(&_Orgs_serviceDesc, srv)
}

func _Orgs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgsListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_ListMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(OrgsListMembersOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).ListMembers(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Orgs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Orgs",
	HandlerType: (*OrgsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Orgs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Orgs_List_Handler,
		},
		{
			MethodName: "ListMembers",
			Handler:    _Orgs_ListMembers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for People service

type PeopleClient interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error)
}

type peopleClient struct {
	cc *grpc.ClientConn
}

func NewPeopleClient(cc *grpc.ClientConn) PeopleClient {
	return &peopleClient{cc}
}

func (c *peopleClient) Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error) {
	out := new(Person)
	err := grpc.Invoke(ctx, "/sourcegraph.People/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for People service

type PeopleServer interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(context.Context, *PersonSpec) (*Person, error)
}

func RegisterPeopleServer(s *grpc.Server, srv PeopleServer) {
	s.RegisterService(&_People_serviceDesc, srv)
}

func _People_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(PeopleServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _People_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.People",
	HandlerType: (*PeopleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _People_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Accounts service

type AccountsClient interface {
	// Create creates a new user account.
	Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*CreatedAccount, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*PendingPasswordReset, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete deletes a user account from this server.
	Delete(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type accountsClient struct {
	cc *grpc.ClientConn
}

func NewAccountsClient(cc *grpc.ClientConn) AccountsClient {
	return &accountsClient{cc}
}

func (c *accountsClient) Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*CreatedAccount, error) {
	out := new(CreatedAccount)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) RequestPasswordReset(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*PendingPasswordReset, error) {
	out := new(PendingPasswordReset)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/RequestPasswordReset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/ResetPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Delete(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Accounts service

type AccountsServer interface {
	// Create creates a new user account.
	Create(context.Context, *NewAccount) (*CreatedAccount, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(context.Context, *PersonSpec) (*PendingPasswordReset, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(context.Context, *NewPassword) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(context.Context, *User) (*pbtypes1.Void, error)
	// Delete deletes a user account from this server.
	Delete(context.Context, *PersonSpec) (*pbtypes1.Void, error)
}

func RegisterAccountsServer(s *grpc.Server, srv AccountsServer) {
	s.RegisterService(&_Accounts_serviceDesc, srv)
}

func _Accounts_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_RequestPasswordReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).RequestPasswordReset(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NewPassword)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).ResetPassword(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(User)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(PersonSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Accounts_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Accounts",
	HandlerType: (*AccountsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Accounts_Create_Handler,
		},
		{
			MethodName: "RequestPasswordReset",
			Handler:    _Accounts_RequestPasswordReset_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _Accounts_ResetPassword_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Accounts_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Accounts_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Users service

type UsersClient interface {
	// Get fetches a user.
	Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error)
	// GetWithEmail fetches a user by their primary email.
	GetWithEmail(ctx context.Context, in *EmailAddr, opts ...grpc.CallOption) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error)
	// List users.
	List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error)
	// Count returns the number of users signed up on this instance.
	Count(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*UserCount, error)
}

type usersClient struct {
	cc *grpc.ClientConn
}

func NewUsersClient(cc *grpc.ClientConn) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetWithEmail(ctx context.Context, in *EmailAddr, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/GetWithEmail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error) {
	out := new(EmailAddrList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/ListEmails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Count(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*UserCount, error) {
	out := new(UserCount)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/Count", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Users service

type UsersServer interface {
	// Get fetches a user.
	Get(context.Context, *UserSpec) (*User, error)
	// GetWithEmail fetches a user by their primary email.
	GetWithEmail(context.Context, *EmailAddr) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(context.Context, *UserSpec) (*EmailAddrList, error)
	// List users.
	List(context.Context, *UsersListOptions) (*UserList, error)
	// Count returns the number of users signed up on this instance.
	Count(context.Context, *pbtypes1.Void) (*UserCount, error)
}

func RegisterUsersServer(s *grpc.Server, srv UsersServer) {
	s.RegisterService(&_Users_serviceDesc, srv)
}

func _Users_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_GetWithEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(EmailAddr)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).GetWithEmail(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_ListEmails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UserSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).ListEmails(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UsersListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).Count(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Users_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Users_Get_Handler,
		},
		{
			MethodName: "GetWithEmail",
			Handler:    _Users_GetWithEmail_Handler,
		},
		{
			MethodName: "ListEmails",
			Handler:    _Users_ListEmails_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Users_List_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _Users_Count_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Auth service

type AuthClient interface {
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error)
	// GetExternalToken returns a stored token that authorizes this server
	// to an external service on behalf of the user.
	GetExternalToken(ctx context.Context, in *ExternalTokenSpec, opts ...grpc.CallOption) (*ExternalToken, error)
	// SetExternalToken stores a token that authorizes this server
	// to an external service on behalf of the user.
	SetExternalToken(ctx context.Context, in *ExternalToken, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// DeleteAndRevokeExternalToken deletes the specified token from
	// Sourcegraph and revokes/disables the token on the external host
	// (e.g., for GitHub, it hits the "revoke an authorizations for an
	// application" API endpoint).
	DeleteAndRevokeExternalToken(ctx context.Context, in *ExternalTokenSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type authClient struct {
	cc *grpc.ClientConn
}

func NewAuthClient(cc *grpc.ClientConn) AuthClient {
	return &authClient{cc}
}

func (c *authClient) GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error) {
	out := new(AccessTokenResponse)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetAccessToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error) {
	out := new(AuthInfo)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/Identify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) GetExternalToken(ctx context.Context, in *ExternalTokenSpec, opts ...grpc.CallOption) (*ExternalToken, error) {
	out := new(ExternalToken)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetExternalToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) SetExternalToken(ctx context.Context, in *ExternalToken, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/SetExternalToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) DeleteAndRevokeExternalToken(ctx context.Context, in *ExternalTokenSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/DeleteAndRevokeExternalToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auth service

type AuthServer interface {
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(context.Context, *AccessTokenRequest) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(context.Context, *pbtypes1.Void) (*AuthInfo, error)
	// GetExternalToken returns a stored token that authorizes this server
	// to an external service on behalf of the user.
	GetExternalToken(context.Context, *ExternalTokenSpec) (*ExternalToken, error)
	// SetExternalToken stores a token that authorizes this server
	// to an external service on behalf of the user.
	SetExternalToken(context.Context, *ExternalToken) (*pbtypes1.Void, error)
	// DeleteAndRevokeExternalToken deletes the specified token from
	// Sourcegraph and revokes/disables the token on the external host
	// (e.g., for GitHub, it hits the "revoke an authorizations for an
	// application" API endpoint).
	DeleteAndRevokeExternalToken(context.Context, *ExternalTokenSpec) (*pbtypes1.Void, error)
}

func RegisterAuthServer(s *grpc.Server, srv AuthServer) {
	s.RegisterService(&_Auth_serviceDesc, srv)
}

func _Auth_GetAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetAccessToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_Identify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).Identify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_GetExternalToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ExternalTokenSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetExternalToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_SetExternalToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ExternalToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).SetExternalToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_DeleteAndRevokeExternalToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ExternalTokenSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).DeleteAndRevokeExternalToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Auth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccessToken",
			Handler:    _Auth_GetAccessToken_Handler,
		},
		{
			MethodName: "Identify",
			Handler:    _Auth_Identify_Handler,
		},
		{
			MethodName: "GetExternalToken",
			Handler:    _Auth_GetExternalToken_Handler,
		},
		{
			MethodName: "SetExternalToken",
			Handler:    _Auth_SetExternalToken_Handler,
		},
		{
			MethodName: "DeleteAndRevokeExternalToken",
			Handler:    _Auth_DeleteAndRevokeExternalToken_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Defs service

type DefsClient interface {
	// Get fetches a def.
	Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error)
	// List defs.
	List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error)
	// ListRefLocations lists repos and files that refer to def.
	ListRefLocations(ctx context.Context, in *DefsListRefLocationsOp, opts ...grpc.CallOption) (*RefLocationsList, error)
	// ListExamples lists usage examples for a given def.
	ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*RefLocationsList, error)
	// ListAuthors lists people who committed parts of def's definition.
	ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error)
	// RefreshIndex updates the precomputed indexes used for answering
	// ListRefLocations queries. The indexes are built from the current
	// snapshot of the code graph. This operation is idempotent, and
	// should be executed regularly to keep the indexes up-to-date.
	RefreshIndex(ctx context.Context, in *DefsRefreshIndexOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type defsClient struct {
	cc *grpc.ClientConn
}

func NewDefsClient(cc *grpc.ClientConn) DefsClient {
	return &defsClient{cc}
}

func (c *defsClient) Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error) {
	out := new(Def)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error) {
	out := new(DefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error) {
	out := new(RefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListRefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListRefLocations(ctx context.Context, in *DefsListRefLocationsOp, opts ...grpc.CallOption) (*RefLocationsList, error) {
	out := new(RefLocationsList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListRefLocations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*RefLocationsList, error) {
	out := new(RefLocationsList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListExamples", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error) {
	out := new(DefAuthorList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) RefreshIndex(ctx context.Context, in *DefsRefreshIndexOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/RefreshIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Defs service

type DefsServer interface {
	// Get fetches a def.
	Get(context.Context, *DefsGetOp) (*Def, error)
	// List defs.
	List(context.Context, *DefListOptions) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(context.Context, *DefsListRefsOp) (*RefList, error)
	// ListRefLocations lists repos and files that refer to def.
	ListRefLocations(context.Context, *DefsListRefLocationsOp) (*RefLocationsList, error)
	// ListExamples lists usage examples for a given def.
	ListExamples(context.Context, *DefsListExamplesOp) (*RefLocationsList, error)
	// ListAuthors lists people who committed parts of def's definition.
	ListAuthors(context.Context, *DefsListAuthorsOp) (*DefAuthorList, error)
	// RefreshIndex updates the precomputed indexes used for answering
	// ListRefLocations queries. The indexes are built from the current
	// snapshot of the code graph. This operation is idempotent, and
	// should be executed regularly to keep the indexes up-to-date.
	RefreshIndex(context.Context, *DefsRefreshIndexOp) (*pbtypes1.Void, error)
}

func RegisterDefsServer(s *grpc.Server, srv DefsServer) {
	s.RegisterService(&_Defs_serviceDesc, srv)
}

func _Defs_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListRefs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListRefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListRefLocations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListRefLocationsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListRefLocations(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListExamples_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListExamplesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListExamples(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListAuthors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsListAuthorsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_RefreshIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsRefreshIndexOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).RefreshIndex(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Defs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Defs",
	HandlerType: (*DefsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Defs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Defs_List_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Defs_ListRefs_Handler,
		},
		{
			MethodName: "ListRefLocations",
			Handler:    _Defs_ListRefLocations_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _Defs_ListExamples_Handler,
		},
		{
			MethodName: "ListAuthors",
			Handler:    _Defs_ListAuthors_Handler,
		},
		{
			MethodName: "RefreshIndex",
			Handler:    _Defs_RefreshIndex_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Async service

type AsyncClient interface {
	// RefreshIndexes refreshes indexes we keep on a repo (GlobalRefs,
	// GlobalDefs, etc)
	RefreshIndexes(ctx context.Context, in *AsyncRefreshIndexesOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type asyncClient struct {
	cc *grpc.ClientConn
}

func NewAsyncClient(cc *grpc.ClientConn) AsyncClient {
	return &asyncClient{cc}
}

func (c *asyncClient) RefreshIndexes(ctx context.Context, in *AsyncRefreshIndexesOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Async/RefreshIndexes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Async service

type AsyncServer interface {
	// RefreshIndexes refreshes indexes we keep on a repo (GlobalRefs,
	// GlobalDefs, etc)
	RefreshIndexes(context.Context, *AsyncRefreshIndexesOp) (*pbtypes1.Void, error)
}

func RegisterAsyncServer(s *grpc.Server, srv AsyncServer) {
	s.RegisterService(&_Async_serviceDesc, srv)
}

func _Async_RefreshIndexes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AsyncRefreshIndexesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AsyncServer).RefreshIndexes(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Async_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Async",
	HandlerType: (*AsyncServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshIndexes",
			Handler:    _Async_RefreshIndexes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Deltas service

type DeltasClient interface {
	// Get fetches a summary of a delta.
	Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error)
}

type deltasClient struct {
	cc *grpc.ClientConn
}

func NewDeltasClient(cc *grpc.ClientConn) DeltasClient {
	return &deltasClient{cc}
}

func (c *deltasClient) Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error) {
	out := new(Delta)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error) {
	out := new(DeltaFiles)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Deltas service

type DeltasServer interface {
	// Get fetches a summary of a delta.
	Get(context.Context, *DeltaSpec) (*Delta, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(context.Context, *DeltasListFilesOp) (*DeltaFiles, error)
}

func RegisterDeltasServer(s *grpc.Server, srv DeltasServer) {
	s.RegisterService(&_Deltas_serviceDesc, srv)
}

func _Deltas_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltaSpec)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DeltasListFilesOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListFiles(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Deltas_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Deltas",
	HandlerType: (*DeltasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Deltas_Get_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _Deltas_ListFiles_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoTree service

type RepoTreeClient interface {
	Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error)
	Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error)
}

type repoTreeClient struct {
	cc *grpc.ClientConn
}

func NewRepoTreeClient(cc *grpc.ClientConn) RepoTreeClient {
	return &repoTreeClient{cc}
}

func (c *repoTreeClient) Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error) {
	out := new(TreeEntry)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error) {
	out := new(VCSSearchResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) List(ctx context.Context, in *RepoTreeListOp, opts ...grpc.CallOption) (*RepoTreeListResult, error) {
	out := new(RepoTreeListResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoTree service

type RepoTreeServer interface {
	Get(context.Context, *RepoTreeGetOp) (*TreeEntry, error)
	Search(context.Context, *RepoTreeSearchOp) (*VCSSearchResultList, error)
	// List returns a list of all the files in the repo tree at
	// the given revision.
	List(context.Context, *RepoTreeListOp) (*RepoTreeListResult, error)
}

func RegisterRepoTreeServer(s *grpc.Server, srv RepoTreeServer) {
	s.RegisterService(&_RepoTree_serviceDesc, srv)
}

func _RepoTree_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeGetOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeSearchOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RepoTreeListOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoTree_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoTree",
	HandlerType: (*RepoTreeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RepoTree_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _RepoTree_Search_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RepoTree_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Meta service

type MetaClient interface {
	// Status returns status information from the server's point of
	// view.
	Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error)
}

type metaClient struct {
	cc *grpc.ClientConn
}

func NewMetaClient(cc *grpc.ClientConn) MetaClient {
	return &metaClient{cc}
}

func (c *metaClient) Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error) {
	out := new(ServerStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error) {
	out := new(ServerConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Config", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Meta service

type MetaServer interface {
	// Status returns status information from the server's point of
	// view.
	Status(context.Context, *pbtypes1.Void) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(context.Context, *pbtypes1.Void) (*ServerConfig, error)
}

func RegisterMetaServer(s *grpc.Server, srv MetaServer) {
	s.RegisterService(&_Meta_serviceDesc, srv)
}

func _Meta_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Status(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Config(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Meta_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Meta",
	HandlerType: (*MetaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Meta_Status_Handler,
		},
		{
			MethodName: "Config",
			Handler:    _Meta_Config_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Notify service

type NotifyClient interface {
	// GenericEvent will notify recipients of an event which happened
	GenericEvent(ctx context.Context, in *NotifyGenericEvent, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type notifyClient struct {
	cc *grpc.ClientConn
}

func NewNotifyClient(cc *grpc.ClientConn) NotifyClient {
	return &notifyClient{cc}
}

func (c *notifyClient) GenericEvent(ctx context.Context, in *NotifyGenericEvent, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Notify/GenericEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Notify service

type NotifyServer interface {
	// GenericEvent will notify recipients of an event which happened
	GenericEvent(context.Context, *NotifyGenericEvent) (*pbtypes1.Void, error)
}

func RegisterNotifyServer(s *grpc.Server, srv NotifyServer) {
	s.RegisterService(&_Notify_serviceDesc, srv)
}

func _Notify_GenericEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(NotifyGenericEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(NotifyServer).GenericEvent(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Notify_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Notify",
	HandlerType: (*NotifyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenericEvent",
			Handler:    _Notify_GenericEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Annotations service

type AnnotationsClient interface {
	// List lists matching annotations.
	List(ctx context.Context, in *AnnotationsListOptions, opts ...grpc.CallOption) (*AnnotationList, error)
}

type annotationsClient struct {
	cc *grpc.ClientConn
}

func NewAnnotationsClient(cc *grpc.ClientConn) AnnotationsClient {
	return &annotationsClient{cc}
}

func (c *annotationsClient) List(ctx context.Context, in *AnnotationsListOptions, opts ...grpc.CallOption) (*AnnotationList, error) {
	out := new(AnnotationList)
	err := grpc.Invoke(ctx, "/sourcegraph.Annotations/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Annotations service

type AnnotationsServer interface {
	// List lists matching annotations.
	List(context.Context, *AnnotationsListOptions) (*AnnotationList, error)
}

func RegisterAnnotationsServer(s *grpc.Server, srv AnnotationsServer) {
	s.RegisterService(&_Annotations_serviceDesc, srv)
}

func _Annotations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(AnnotationsListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(AnnotationsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Annotations_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Annotations",
	HandlerType: (*AnnotationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Annotations_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Search service

type SearchClient interface {
	// Search returns a list of defs matching the given query string.
	Search(ctx context.Context, in *SearchOp, opts ...grpc.CallOption) (*SearchResultsList, error)
	// RefreshIndex updates the precomputed indexes used for efficiently
	// answering search queries. The indexes are built from the current
	// snapshot of the code graph. This operation is idempotent, and
	// should be executed regularly to keep the indexes up-to-date.
	RefreshIndex(ctx context.Context, in *SearchRefreshIndexOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type searchClient struct {
	cc *grpc.ClientConn
}

func NewSearchClient(cc *grpc.ClientConn) SearchClient {
	return &searchClient{cc}
}

func (c *searchClient) Search(ctx context.Context, in *SearchOp, opts ...grpc.CallOption) (*SearchResultsList, error) {
	out := new(SearchResultsList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) RefreshIndex(ctx context.Context, in *SearchRefreshIndexOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/RefreshIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Search service

type SearchServer interface {
	// Search returns a list of defs matching the given query string.
	Search(context.Context, *SearchOp) (*SearchResultsList, error)
	// RefreshIndex updates the precomputed indexes used for efficiently
	// answering search queries. The indexes are built from the current
	// snapshot of the code graph. This operation is idempotent, and
	// should be executed regularly to keep the indexes up-to-date.
	RefreshIndex(context.Context, *SearchRefreshIndexOp) (*pbtypes1.Void, error)
}

func RegisterSearchServer(s *grpc.Server, srv SearchServer) {
	s.RegisterService(&_Search_serviceDesc, srv)
}

func _Search_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SearchOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Search_RefreshIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SearchRefreshIndexOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).RefreshIndex(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Search_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Search",
	HandlerType: (*SearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _Search_Search_Handler,
		},
		{
			MethodName: "RefreshIndex",
			Handler:    _Search_RefreshIndex_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Channel service

type ChannelClient interface {
	// Listen starts listening to a stream of actions for the given
	// channel.
	Listen(ctx context.Context, in *ChannelListenOp, opts ...grpc.CallOption) (Channel_ListenClient, error)
	// Send sends an action to all listeners on the given channel.
	Send(ctx context.Context, in *ChannelSendOp, opts ...grpc.CallOption) (*ChannelSendResult, error)
}

type channelClient struct {
	cc *grpc.ClientConn
}

func NewChannelClient(cc *grpc.ClientConn) ChannelClient {
	return &channelClient{cc}
}

func (c *channelClient) Listen(ctx context.Context, in *ChannelListenOp, opts ...grpc.CallOption) (Channel_ListenClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Channel_serviceDesc.Streams[0], c.cc, "/sourcegraph.Channel/Listen", opts...)
	if err != nil {
		return nil, err
	}
	x := &channelListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Channel_ListenClient interface {
	Recv() (*ChannelAction, error)
	grpc.ClientStream
}

type channelListenClient struct {
	grpc.ClientStream
}

func (x *channelListenClient) Recv() (*ChannelAction, error) {
	m := new(ChannelAction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *channelClient) Send(ctx context.Context, in *ChannelSendOp, opts ...grpc.CallOption) (*ChannelSendResult, error) {
	out := new(ChannelSendResult)
	err := grpc.Invoke(ctx, "/sourcegraph.Channel/Send", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Channel service

type ChannelServer interface {
	// Listen starts listening to a stream of actions for the given
	// channel.
	Listen(*ChannelListenOp, Channel_ListenServer) error
	// Send sends an action to all listeners on the given channel.
	Send(context.Context, *ChannelSendOp) (*ChannelSendResult, error)
}

func RegisterChannelServer(s *grpc.Server, srv ChannelServer) {
	s.RegisterService(&_Channel_serviceDesc, srv)
}

func _Channel_Listen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChannelListenOp)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChannelServer).Listen(m, &channelListenServer{stream})
}

type Channel_ListenServer interface {
	Send(*ChannelAction) error
	grpc.ServerStream
}

type channelListenServer struct {
	grpc.ServerStream
}

func (x *channelListenServer) Send(m *ChannelAction) error {
	return x.ServerStream.SendMsg(m)
}

func _Channel_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ChannelSendOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(ChannelServer).Send(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Channel_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Channel",
	HandlerType: (*ChannelServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Channel_Send_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Listen",
			Handler:       _Channel_Listen_Handler,
			ServerStreams: true,
		},
	},
}

func (m *Origin) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Origin) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if m.Service != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Service))
	}
	if len(m.APIBaseURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.APIBaseURL)))
		i += copy(data[i:], m.APIBaseURL)
	}
	return i, nil
}

func (m *CombinedStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CombinedStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.State) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.Statuses) > 0 {
		for _, msg := range m.Statuses {
			data[i] = 0x1a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Rev) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	return i, nil
}

func (m *ListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PerPage != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PerPage))
	}
	if m.Page != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ListResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Total))
	}
	return i, nil
}

func (m *StreamResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StreamResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HasMore {
		data[i] = 0x8
		i++
		if m.HasMore {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Repo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Repo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	if len(m.Owner) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.HTTPCloneURL) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTTPCloneURL)))
		i += copy(data[i:], m.HTTPCloneURL)
	}
	if len(m.SSHCloneURL) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.SSHCloneURL)))
		i += copy(data[i:], m.SSHCloneURL)
	}
	if len(m.HomepageURL) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HomepageURL)))
		i += copy(data[i:], m.HomepageURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if len(m.Language) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if m.Blocked {
		data[i] = 0x50
		i++
		if m.Blocked {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Deprecated {
		data[i] = 0x58
		i++
		if m.Deprecated {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fork {
		data[i] = 0x60
		i++
		if m.Fork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Mirror {
		data[i] = 0x68
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Private {
		data[i] = 0x70
		i++
		if m.Private {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != nil {
		data[i] = 0x7a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n1, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UpdatedAt != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
		n2, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.PushedAt != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PushedAt.Size()))
		n3, err := m.PushedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.ID != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if m.Origin != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Origin.Size()))
		n4, err := m.Origin.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.HTMLURL) > 0 {
		data[i] = 0xb2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTMLURL)))
		i += copy(data[i:], m.HTMLURL)
	}
	return i, nil
}

func (m *RepoListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Query) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Sort) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	if m.NoFork {
		data[i] = 0x38
		i++
		if m.NoFork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Type) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Owner) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	data[i] = 0x5a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n5, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *RepoRevSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoRevSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *RepoSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *RepoStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.TargetURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.TargetURL)))
		i += copy(data[i:], m.TargetURL)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Context) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	data[i] = 0x32
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n6, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	data[i] = 0x3a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
	n7, err := m.UpdatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	return i, nil
}

func (m *RepoStatusList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatusList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoStatuses) > 0 {
		for _, msg := range m.RepoStatuses {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RepoStatusesCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoStatusesCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
	n8, err := m.Repo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Status.Size()))
	n9, err := m.Status.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	return i, nil
}

func (m *RepoList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, msg := range m.Repos {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReposResolveRevOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposResolveRevOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Rev) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	return i, nil
}

func (m *ResolvedRev) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResolvedRev) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *ReceivePackOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReceivePackOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Data) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	if m.AdvertiseRefs {
		data[i] = 0x20
		i++
		if m.AdvertiseRefs {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UploadPackOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UploadPackOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Data) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	if m.AdvertiseRefs {
		data[i] = 0x20
		i++
		if m.AdvertiseRefs {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Packet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Packet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *RepoResolveOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoResolveOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Remote {
		data[i] = 0x10
		i++
		if m.Remote {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RepoResolution) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoResolution) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.RemoteRepo != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RemoteRepo.Size()))
		n10, err := m.RemoteRepo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.CanonicalPath) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CanonicalPath)))
		i += copy(data[i:], m.CanonicalPath)
	}
	return i, nil
}

func (m *ReposListRemoteOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListRemoteOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n11, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	return i, nil
}

func (m *RemoteRepoList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RemoteRepoList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RemoteRepos) > 0 {
		for _, msg := range m.RemoteRepos {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SrclibDataVersion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SrclibDataVersion) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CommitID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if m.CommitsBehind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CommitsBehind))
	}
	return i, nil
}

func (m *RepoConfigureAppOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoConfigureAppOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.App) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.App)))
		i += copy(data[i:], m.App)
	}
	if m.Enable {
		data[i] = 0x18
		i++
		if m.Enable {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReposCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		nn12, err := m.Op.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	return i, nil
}

func (m *ReposCreateOp_New) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.New != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.New.Size()))
		n13, err := m.New.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *ReposCreateOp_FromGitHubID) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x10
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.FromGitHubID))
	return i, nil
}
func (m *ReposCreateOp_Origin) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Origin != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Origin.Size()))
		n14, err := m.Origin.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *ReposCreateOp_NewRepo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposCreateOp_NewRepo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URI) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URI)))
		i += copy(data[i:], m.URI)
	}
	if len(m.CloneURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CloneURL)))
		i += copy(data[i:], m.CloneURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if m.Mirror {
		data[i] = 0x28
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Description) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Language) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	return i, nil
}

func (m *ReposUpdateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposUpdateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Language) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if m.Fork != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Fork))
	}
	if m.Private != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Private))
	}
	return i, nil
}

func (m *ReposListCommitsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListCommitsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n15, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *RepoListCommitsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListCommitsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Head) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Head)))
		i += copy(data[i:], m.Head)
	}
	if len(m.Base) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Base)))
		i += copy(data[i:], m.Base)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n16, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if len(m.Path) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *CommitList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, msg := range m.Commits {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n17, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	return i, nil
}

func (m *ReposListBranchesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListBranchesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n18, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *RepoListBranchesOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListBranchesOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n19, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	if m.IncludeCommit {
		data[i] = 0x20
		i++
		if m.IncludeCommit {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.BehindAheadBranch) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.BehindAheadBranch)))
		i += copy(data[i:], m.BehindAheadBranch)
	}
	if len(m.ContainsCommit) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ContainsCommit)))
		i += copy(data[i:], m.ContainsCommit)
	}
	return i, nil
}

func (m *BranchList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BranchList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Branches) > 0 {
		for _, msg := range m.Branches {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n20, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	return i, nil
}

func (m *ReposListTagsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListTagsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n21, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *ReposListCommittersOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReposListCommittersOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n22, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *RepoListCommittersOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListCommittersOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rev) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Rev)))
		i += copy(data[i:], m.Rev)
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n23, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	return i, nil
}

func (m *CommitterList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CommitterList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Committers) > 0 {
		for _, msg := range m.Committers {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n24, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	return i, nil
}

func (m *RepoListTagsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoListTagsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n25, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	return i, nil
}

func (m *TagList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TagList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n26, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	return i, nil
}

func (m *MirrorReposRefreshVCSOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MirrorReposRefreshVCSOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.AsUser != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.AsUser.Size()))
		n27, err := m.AsUser.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *VCSCredentials) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VCSCredentials) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pass) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Pass)))
		i += copy(data[i:], m.Pass)
	}
	return i, nil
}

func (m *RemoteRepo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RemoteRepo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GitHubID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.GitHubID))
	}
	if len(m.Owner) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Owner)))
		i += copy(data[i:], m.Owner)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.VCS) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.VCS)))
		i += copy(data[i:], m.VCS)
	}
	if len(m.HTTPCloneURL) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HTTPCloneURL)))
		i += copy(data[i:], m.HTTPCloneURL)
	}
	if len(m.DefaultBranch) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DefaultBranch)))
		i += copy(data[i:], m.DefaultBranch)
	}
	if len(m.Description) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Language) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if m.UpdatedAt != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UpdatedAt.Size()))
		n28, err := m.UpdatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Private {
		data[i] = 0x50
		i++
		if m.Private {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fork {
		data[i] = 0x58
		i++
		if m.Fork {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Mirror {
		data[i] = 0x60
		i++
		if m.Mirror {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Stars != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Stars))
	}
	if m.PushedAt != nil {
		data[i] = 0x72
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.PushedAt.Size()))
		n29, err := m.PushedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.OwnerIsOrg {
		data[i] = 0x78
		i++
		if m.OwnerIsOrg {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Build) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Build) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	data[i] = 0x22
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n30, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	if m.StartedAt != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n31, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.EndedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n32, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.HeartbeatAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeartbeatAt.Size()))
		n33, err := m.HeartbeatAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Success {
		data[i] = 0x40
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x48
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Killed {
		data[i] = 0x50
		i++
		if m.Killed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Host) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if m.Purged {
		data[i] = 0x60
		i++
		if m.Purged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x6a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.BuildConfig.Size()))
	n34, err := m.BuildConfig.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	if len(m.Branch) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Branch)))
		i += copy(data[i:], m.Branch)
	}
	if len(m.Tag) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Tag)))
		i += copy(data[i:], m.Tag)
	}
	return i, nil
}

func (m *BuildConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Queue {
		data[i] = 0x10
		i++
		if m.Queue {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Priority != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Priority))
	}
	if len(m.BuilderConfig) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.BuilderConfig)))
		i += copy(data[i:], m.BuilderConfig)
	}
	return i, nil
}

func (m *BuildJob) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildJob) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Spec.Size()))
	n35, err := m.Spec.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	if len(m.CommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.Branch) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Branch)))
		i += copy(data[i:], m.Branch)
	}
	if len(m.Tag) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Tag)))
		i += copy(data[i:], m.Tag)
	}
	if len(m.AccessToken) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AccessToken)))
		i += copy(data[i:], m.AccessToken)
	}
	return i, nil
}

func (m *BuildGetLogOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildGetLogOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MinID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.MinID)))
		i += copy(data[i:], m.MinID)
	}
	return i, nil
}

func (m *BuildListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Queued {
		data[i] = 0x8
		i++
		if m.Queued {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Active {
		data[i] = 0x10
		i++
		if m.Active {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ended {
		data[i] = 0x18
		i++
		if m.Ended {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Succeeded {
		data[i] = 0x20
		i++
		if m.Succeeded {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failed {
		data[i] = 0x28
		i++
		if m.Failed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Purged {
		data[i] = 0x30
		i++
		if m.Purged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Repo != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.Sort) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	data[i] = 0x5a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n36, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n36
	return i, nil
}

func (m *BuildSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *BuildTask) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildTask) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n37, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n37
	if m.ParentID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ParentID))
	}
	if len(m.Label) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
	n38, err := m.CreatedAt.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n38
	if m.StartedAt != nil {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n39, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.EndedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n40, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Success {
		data[i] = 0x40
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x48
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Skipped {
		data[i] = 0x50
		i++
		if m.Skipped {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Warnings {
		data[i] = 0x58
		i++
		if m.Warnings {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BuildTaskListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildTaskListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n41, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n41
	return i, nil
}

func (m *BuildUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartedAt != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n42, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.EndedAt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n43, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.HeartbeatAt != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeartbeatAt.Size()))
		n44, err := m.HeartbeatAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.Host) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if m.Success {
		data[i] = 0x28
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Purged {
		data[i] = 0x30
		i++
		if m.Purged {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x38
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Killed {
		data[i] = 0x40
		i++
		if m.Killed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Priority != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Priority))
	}
	if len(m.BuilderConfig) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.BuilderConfig)))
		i += copy(data[i:], m.BuilderConfig)
	}
	if m.FileScore != 0 {
		data[i] = 0x5d
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.FileScore))))
	}
	if m.RefScore != 0 {
		data[i] = 0x65
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.RefScore))))
	}
	if m.TokDensity != 0 {
		data[i] = 0x6d
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.TokDensity))))
	}
	return i, nil
}

func (m *BuildList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Builds) > 0 {
		for _, msg := range m.Builds {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n45, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n45
	return i, nil
}

func (m *BuildsCreateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsCreateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.Branch) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Branch)))
		i += copy(data[i:], m.Branch)
	}
	if len(m.Tag) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Tag)))
		i += copy(data[i:], m.Tag)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Config.Size()))
	n46, err := m.Config.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n46
	return i, nil
}

func (m *BuildsUpdateOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsUpdateOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n47, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n47
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Info.Size()))
	n48, err := m.Info.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n48
	return i, nil
}

func (m *BuildsListBuildTasksOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsListBuildTasksOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n49, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n49
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n50, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}

func (m *BuildTaskList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildTaskList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BuildTasks) > 0 {
		for _, msg := range m.BuildTasks {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuildsCreateTasksOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsCreateTasksOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n51, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n51
	if len(m.Tasks) > 0 {
		for _, msg := range m.Tasks {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BuildsUpdateTaskOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsUpdateTaskOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Task.Size()))
	n52, err := m.Task.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n52
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Info.Size()))
	n53, err := m.Info.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n53
	return i, nil
}

func (m *BuildsGetTaskLogOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsGetTaskLogOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Task.Size()))
	n54, err := m.Task.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n54
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n55, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *BuildsDequeueNextOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BuildsDequeueNextOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EmailAddr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailAddr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if m.Verified {
		data[i] = 0x10
		i++
		if m.Verified {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Primary {
		data[i] = 0x18
		i++
		if m.Primary {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Guessed {
		data[i] = 0x20
		i++
		if m.Guessed {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Blacklisted {
		data[i] = 0x28
		i++
		if m.Blacklisted {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LogEntries) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LogEntries) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MaxID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.MaxID)))
		i += copy(data[i:], m.MaxID)
	}
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Org) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Org) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.User.Size()))
	n56, err := m.User.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n56
	return i, nil
}

func (m *OrgListMembersOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgListMembersOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n57, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n57
	return i, nil
}

func (m *OrgSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Org) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Org)))
		i += copy(data[i:], m.Org)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *OrgsListMembersOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgsListMembersOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Org.Size()))
	n58, err := m.Org.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n58
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n59, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}

func (m *UserList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserCount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserCount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *Person) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Person) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.PersonSpec.Size()))
	n60, err := m.PersonSpec.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n60
	if len(m.FullName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.FullName)))
		i += copy(data[i:], m.FullName)
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	return i, nil
}

func (m *PersonSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersonSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.Login) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if m.UID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *TaskSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TaskSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Build.Size()))
	n61, err := m.Build.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n61
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	return i, nil
}

func (m *TaskUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TaskUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartedAt != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartedAt.Size()))
		n62, err := m.StartedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if m.EndedAt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndedAt.Size()))
		n63, err := m.EndedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Success {
		data[i] = 0x18
		i++
		if m.Success {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Failure {
		data[i] = 0x20
		i++
		if m.Failure {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Skipped {
		data[i] = 0x28
		i++
		if m.Skipped {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Warnings {
		data[i] = 0x30
		i++
		if m.Warnings {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *User) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *User) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Login) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Name) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.IsOrganization {
		data[i] = 0x28
		i++
		if m.IsOrganization {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	if len(m.Location) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Location)))
		i += copy(data[i:], m.Location)
	}
	if len(m.Company) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Company)))
		i += copy(data[i:], m.Company)
	}
	if len(m.HomepageURL) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.HomepageURL)))
		i += copy(data[i:], m.HomepageURL)
	}
	if m.Disabled {
		data[i] = 0x50
		i++
		if m.Disabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RegisteredAt != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RegisteredAt.Size()))
		n64, err := m.RegisteredAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Admin {
		data[i] = 0x60
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Write {
		data[i] = 0x68
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UserSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Login) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *UsersListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UsersListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if len(m.Sort) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	data[i] = 0x22
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n65, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n65
	if len(m.UIDs) > 0 {
		for _, num := range m.UIDs {
			data[i] = 0x28
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *OrgsListOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgsListOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Member.Size()))
	n66, err := m.Member.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n66
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n67, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n67
	return i, nil
}

func (m *EmailAddrList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmailAddrList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EmailAddrs) > 0 {
		for _, msg := range m.EmailAddrs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OrgList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OrgList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Orgs) > 0 {
		for _, msg := range m.Orgs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreatedAccount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreatedAccount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.TemporaryAccessToken) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.TemporaryAccessToken)))
		i += copy(data[i:], m.TemporaryAccessToken)
	}
	return i, nil
}

func (m *PasswordResetToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PasswordResetToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	return i, nil
}

func (m *PendingPasswordReset) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PendingPasswordReset) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Link) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Link)))
		i += copy(data[i:], m.Link)
	}
	if m.Token != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Token.Size()))
		n68, err := m.Token.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.EmailSent {
		data[i] = 0x18
		i++
		if m.EmailSent {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Login) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	return i, nil
}

func (m *NewPassword) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewPassword) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Password) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	if m.Token != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Token.Size()))
		n69, err := m.Token.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}

func (m *NewAccount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewAccount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Login) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.Password) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	if m.UID != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	return i, nil
}

func (m *LoginCredentials) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LoginCredentials) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Login) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Password) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Password)))
		i += copy(data[i:], m.Password)
	}
	return i, nil
}

func (m *GitHubAuthCode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GitHubAuthCode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Code)))
		i += copy(data[i:], m.Code)
	}
	if len(m.Host) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	return i, nil
}

func (m *AccessTokenRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AccessTokenRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthorizationGrant != nil {
		nn70, err := m.AuthorizationGrant.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn70
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			data[i] = 0x8a
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *AccessTokenRequest_ResourceOwnerPassword) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.ResourceOwnerPassword != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ResourceOwnerPassword.Size()))
		n71, err := m.ResourceOwnerPassword.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}
func (m *AccessTokenRequest_GitHubAuthCode) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.GitHubAuthCode != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.GitHubAuthCode.Size()))
		n72, err := m.GitHubAuthCode.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}
func (m *AccessTokenResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AccessTokenResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessToken) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AccessToken)))
		i += copy(data[i:], m.AccessToken)
	}
	if len(m.TokenType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.TokenType)))
		i += copy(data[i:], m.TokenType)
	}
	if m.ExpiresInSec != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ExpiresInSec))
	}
	if len(m.RefreshToken) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.RefreshToken)))
		i += copy(data[i:], m.RefreshToken)
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.UID != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.GitHubAccessToken) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.GitHubAccessToken)))
		i += copy(data[i:], m.GitHubAccessToken)
	}
	if m.GitHubUser != nil {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.GitHubUser.Size()))
		n73, err := m.GitHubUser.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *GitHubUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GitHubUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ID))
	}
	if len(m.Login) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Email) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.Location) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Location)))
		i += copy(data[i:], m.Location)
	}
	if len(m.Company) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Company)))
		i += copy(data[i:], m.Company)
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	return i, nil
}

func (m *AuthInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Login) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Login)))
		i += copy(data[i:], m.Login)
	}
	if m.Write {
		data[i] = 0x28
		i++
		if m.Write {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Admin {
		data[i] = 0x30
		i++
		if m.Admin {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.IntercomHash) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.IntercomHash)))
		i += copy(data[i:], m.IntercomHash)
	}
	return i, nil
}

func (m *ExternalTokenSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExternalTokenSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Host) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	return i, nil
}

func (m *ExternalToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExternalToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UID != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.Host) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.Token) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	if len(m.Scope) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Scope)))
		i += copy(data[i:], m.Scope)
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if m.ExtUID != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ExtUID))
	}
	return i, nil
}

func (m *Def) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Def) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n74, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n74
	if m.DocHTML != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.DocHTML.Size()))
		n75, err := m.DocHTML.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.FmtStrings != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.FmtStrings.Size()))
		n76, err := m.FmtStrings.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if m.StartLine != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndLine))
	}
	return i, nil
}

func (m *DefGetOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefGetOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Doc {
		data[i] = 0x8
		i++
		if m.Doc {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ComputeLineRange {
		data[i] = 0x10
		i++
		if m.ComputeLineRange {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DefListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Query) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if m.ByteStart != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ByteStart))
	}
	if m.ByteEnd != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ByteEnd))
	}
	if len(m.DefKeys) > 0 {
		for _, msg := range m.DefKeys {
			data[i] = 0x2a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.Path) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.FilePathPrefix) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.FilePathPrefix)))
		i += copy(data[i:], m.FilePathPrefix)
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			data[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Exported {
		data[i] = 0x68
		i++
		if m.Exported {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Nonlocal {
		data[i] = 0x70
		i++
		if m.Nonlocal {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.IncludeTest {
		data[i] = 0x78
		i++
		if m.IncludeTest {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Doc {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		if m.Doc {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Fuzzy {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		if m.Fuzzy {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Sort) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Sort)))
		i += copy(data[i:], m.Sort)
	}
	if len(m.Direction) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Direction)))
		i += copy(data[i:], m.Direction)
	}
	data[i] = 0xa2
	i++
	data[i] = 0x1
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n77, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n77
	return i, nil
}

func (m *DefListRefsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListRefsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n78, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n78
	if len(m.CommitID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *DefSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	if len(m.Unit) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.Path) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *DefsGetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsGetOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n79, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n79
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n80, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}

func (m *DefList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, msg := range m.Defs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListResponse.Size()))
	n81, err := m.ListResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n81
	return i, nil
}

func (m *DefsListRefsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListRefsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n82, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n82
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n83, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *RefList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RefList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, msg := range m.Refs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n84, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n84
	return i, nil
}

func (m *DefListRefLocationsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListRefLocationsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, s := range m.Repos {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n85, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n85
	return i, nil
}

func (m *DefsListRefLocationsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListRefLocationsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n86, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n86
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n87, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	return i, nil
}

func (m *DefsListExamplesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListExamplesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n88, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n88
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n89, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n89
	return i, nil
}

func (m *RefLocationsList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RefLocationsList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoRefs) > 0 {
		for _, msg := range m.RepoRefs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.StreamResponse.Size()))
	n90, err := m.StreamResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n90
	if m.TotalRepos != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.TotalRepos))
	}
	return i, nil
}

func (m *DefRepoRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefRepoRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repo) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Count))
	}
	if m.Score != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.Score))))
	}
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			data[i] = 0x22
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DefFileRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefFileRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Count))
	}
	if m.Score != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.Score))))
	}
	return i, nil
}

func (m *Delta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Delta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Base.Size()))
	n91, err := m.Base.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n91
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Head.Size()))
	n92, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n92
	if m.BaseCommit != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BaseCommit.Size()))
		n93, err := m.BaseCommit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.HeadCommit != nil {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.HeadCommit.Size()))
		n94, err := m.HeadCommit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}

func (m *FileDiff) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileDiff) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.FileDiff.Size()))
	n95, err := m.FileDiff.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n95
	if len(m.FileDiffHunks) > 0 {
		for _, msg := range m.FileDiffHunks {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PreImage) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.PreImage)))
		i += copy(data[i:], m.PreImage)
	}
	if len(m.PostImage) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.PostImage)))
		i += copy(data[i:], m.PostImage)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Stats.Size()))
	n96, err := m.Stats.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n96
	if m.Filtered {
		data[i] = 0x30
		i++
		if m.Filtered {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DeltaFiles) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaFiles) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileDiffs) > 0 {
		for _, msg := range m.FileDiffs {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Delta != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Delta.Size()))
		n97, err := m.Delta.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Stats.Size()))
	n98, err := m.Stats.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n98
	return i, nil
}

func (m *DeltaFilter) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaFilter) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Unit) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Unit)))
		i += copy(data[i:], m.Unit)
	}
	if len(m.UnitType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UnitType)))
		i += copy(data[i:], m.UnitType)
	}
	return i, nil
}

func (m *DeltaListFilesOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaListFilesOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Filter)))
		i += copy(data[i:], m.Filter)
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DeltaFilter.Size()))
	n99, err := m.DeltaFilter.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n99
	if len(m.Ignore) > 0 {
		for _, s := range m.Ignore {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DeltaSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltaSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Base.Size()))
	n100, err := m.Base.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n100
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Head.Size()))
	n101, err := m.Head.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n101
	return i, nil
}

func (m *DeltasListFilesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeltasListFilesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Ds.Size()))
	n102, err := m.Ds.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n102
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n103, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	return i, nil
}

func (m *RepoTreeGetOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeGetOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContentsAsString {
		data[i] = 0x20
		i++
		if m.ContentsAsString {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	data[i] = 0x2a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.GetFileOptions.Size()))
	n104, err := m.GetFileOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n104
	return i, nil
}

func (m *GetFileOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetFileOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.FileRange.Size()))
	n105, err := m.FileRange.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n105
	if m.EntireFile {
		data[i] = 0x10
		i++
		if m.EntireFile {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.ExpandContextLines != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ExpandContextLines))
	}
	if m.FullLines {
		data[i] = 0x20
		i++
		if m.FullLines {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Recursive {
		data[i] = 0x28
		i++
		if m.Recursive {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RecurseSingleSubfolderLimit != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RecurseSingleSubfolderLimit))
	}
	return i, nil
}

func (m *RepoTreeSearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.SearchOptions.Size()))
	n106, err := m.SearchOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n106
	return i, nil
}

func (m *RepoTreeSearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.SearchResult.Size()))
	n107, err := m.SearchResult.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n107
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n108, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n108
	return i, nil
}

func (m *RepoTreeGetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeGetOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
	n109, err := m.Entry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n109
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n110, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	return i, nil
}

func (m *RepoTreeSearchOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeSearchOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Rev.Size()))
	n111, err := m.Rev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n111
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n112, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	return i, nil
}

func (m *RepoTreeListOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeListOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Rev.Size()))
	n113, err := m.Rev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n113
	return i, nil
}

func (m *RepoTreeListResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoTreeListResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *VCSSearchResultList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VCSSearchResultList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SearchResults) > 0 {
		for _, msg := range m.SearchResults {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListResponse.Size()))
	n114, err := m.ListResponse.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n114
	return i, nil
}

func (m *TreeEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BasicTreeEntry != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.BasicTreeEntry.Size()))
		n115, err := m.BasicTreeEntry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if m.FileRange != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.FileRange.Size()))
		n116, err := m.FileRange.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	if len(m.ContentsString) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ContentsString)))
		i += copy(data[i:], m.ContentsString)
	}
	return i, nil
}

func (m *BasicTreeEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BasicTreeEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Type != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Type))
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if len(m.Contents) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Contents)))
		i += copy(data[i:], m.Contents)
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0x32
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TreeEntrySpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TreeEntrySpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.RepoRev.Size()))
	n117, err := m.RepoRev.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n117
	if len(m.Path) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	return i, nil
}

func (m *FileRange) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileRange) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartLine != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndLine))
	}
	if m.StartByte != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndByte))
	}
	return i, nil
}

func (m *DefsRefreshIndexOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsRefreshIndexOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if m.RefreshRefLocations {
		data[i] = 0x10
		i++
		if m.RefreshRefLocations {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Force {
		data[i] = 0x18
		i++
		if m.Force {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	return i, nil
}

func (m *AsyncRefreshIndexesOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AsyncRefreshIndexesOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo))
	}
	if len(m.Source) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Source)))
		i += copy(data[i:], m.Source)
	}
	if m.Force {
		data[i] = 0x18
		i++
		if m.Force {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AuthorshipInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AuthorshipInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.LastCommitDate.Size()))
	n118, err := m.LastCommitDate.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n118
	if len(m.LastCommitID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.LastCommitID)))
		i += copy(data[i:], m.LastCommitID)
	}
	return i, nil
}

func (m *DefAuthor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.AvatarURL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AvatarURL)))
		i += copy(data[i:], m.AvatarURL)
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.DefAuthorship.Size()))
	n119, err := m.DefAuthorship.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n119
	return i, nil
}

func (m *DefAuthorship) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthorship) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.AuthorshipInfo.Size()))
	n120, err := m.AuthorshipInfo.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n120
	if m.Bytes != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Bytes))
	}
	if m.BytesProportion != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Sourcegraph(data, i, uint64(math.Float64bits(float64(m.BytesProportion))))
	}
	return i, nil
}

func (m *DefListAuthorsOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefListAuthorsOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n121, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n121
	return i, nil
}

func (m *DefsListAuthorsOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefsListAuthorsOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n122, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n122
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n123, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	return i, nil
}

func (m *DefAuthorList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefAuthorList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DefAuthors) > 0 {
		for _, msg := range m.DefAuthors {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Checklist) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Checklist) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Todo != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Todo))
	}
	if m.Done != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Done))
	}
	return i, nil
}

func (m *FileToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Entry != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
		n124, err := m.Entry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n124
	}
	return i, nil
}

func (m *ServerStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServerStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Info)))
		i += copy(data[i:], m.Info)
	}
	return i, nil
}

func (m *ServerConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServerConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.AppURL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AppURL)))
		i += copy(data[i:], m.AppURL)
	}
	if len(m.IDKey) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.IDKey)))
		i += copy(data[i:], m.IDKey)
	}
	return i, nil
}

func (m *UserEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UserEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.UID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.UID))
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if len(m.Service) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Service)))
		i += copy(data[i:], m.Service)
	}
	if len(m.Method) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Method)))
		i += copy(data[i:], m.Method)
	}
	if len(m.Result) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Result)))
		i += copy(data[i:], m.Result)
	}
	if m.CreatedAt != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.CreatedAt.Size()))
		n125, err := m.CreatedAt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n125
	}
	if len(m.Message) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if len(m.Version) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.URL) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	return i, nil
}

func (m *Event) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Event) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.UserID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.UserID)))
		i += copy(data[i:], m.UserID)
	}
	if len(m.DeviceID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.DeviceID)))
		i += copy(data[i:], m.DeviceID)
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if m.Timestamp != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Timestamp.Size()))
		n126, err := m.Timestamp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n126
	}
	if len(m.UserProperties) > 0 {
		for k, _ := range m.UserProperties {
			data[i] = 0x32
			i++
			v := m.UserProperties[k]
			mapSize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			i = encodeVarintSourcegraph(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.EventProperties) > 0 {
		for k, _ := range m.EventProperties {
			data[i] = 0x3a
			i++
			v := m.EventProperties[k]
			mapSize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			i = encodeVarintSourcegraph(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *EventList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EventList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.AppURL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.AppURL)))
		i += copy(data[i:], m.AppURL)
	}
	return i, nil
}

func (m *NotifyGenericEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NotifyGenericEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Actor != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Actor.Size()))
		n127, err := m.Actor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n127
	}
	if len(m.Recipients) > 0 {
		for _, msg := range m.Recipients {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ActionType) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ActionType)))
		i += copy(data[i:], m.ActionType)
	}
	if len(m.ActionContent) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ActionContent)))
		i += copy(data[i:], m.ActionContent)
	}
	if m.ObjectID != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.ObjectID))
	}
	if len(m.ObjectRepo) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectRepo)))
		i += copy(data[i:], m.ObjectRepo)
	}
	if len(m.ObjectType) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectType)))
		i += copy(data[i:], m.ObjectType)
	}
	if len(m.ObjectTitle) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectTitle)))
		i += copy(data[i:], m.ObjectTitle)
	}
	if len(m.ObjectURL) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.ObjectURL)))
		i += copy(data[i:], m.ObjectURL)
	}
	if len(m.SlackMsg) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.SlackMsg)))
		i += copy(data[i:], m.SlackMsg)
	}
	if len(m.EmailHTML) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.EmailHTML)))
		i += copy(data[i:], m.EmailHTML)
	}
	if m.NoEmail {
		data[i] = 0x68
		i++
		if m.NoEmail {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Annotation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Annotation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	if m.StartByte != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.EndByte))
	}
	if len(m.Class) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Class)))
		i += copy(data[i:], m.Class)
	}
	if m.WantInner != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.WantInner))
	}
	if len(m.URLs) > 0 {
		for _, s := range m.URLs {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Def {
		data[i] = 0x38
		i++
		if m.Def {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AnnotationList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnnotationList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, msg := range m.Annotations {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LineStartBytes) > 0 {
		for _, num := range m.LineStartBytes {
			data[i] = 0x10
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *AnnotationsListOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnnotationsListOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Entry.Size()))
	n128, err := m.Entry.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n128
	if m.Range != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Range.Size()))
		n129, err := m.Range.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n129
	}
	return i, nil
}

func (m *SearchOptions) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchOptions) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, num := range m.Repos {
			data[i] = 0x8
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	if len(m.NotRepos) > 0 {
		for _, num := range m.NotRepos {
			data[i] = 0x10
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	data[i] = 0x1a
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.ListOptions.Size()))
	n130, err := m.ListOptions.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n130
	if m.IncludeRepos {
		data[i] = 0x20
		i++
		if m.IncludeRepos {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.PrefixMatch {
		data[i] = 0x28
		i++
		if m.PrefixMatch {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.NotLanguages) > 0 {
		for _, s := range m.NotLanguages {
			data[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.NotKinds) > 0 {
		for _, s := range m.NotKinds {
			data[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.CommitID) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.CommitID)))
		i += copy(data[i:], m.CommitID)
	}
	if m.Fast {
		data[i] = 0x58
		i++
		if m.Fast {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Latest {
		data[i] = 0x60
		i++
		if m.Latest {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SearchOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if m.Opt != nil {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Opt.Size()))
		n131, err := m.Opt.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n131
	}
	return i, nil
}

func (m *RepoSearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RepoSearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Repo.Size()))
		n132, err := m.Repo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n132
	}
	return i, nil
}

func (m *DefSearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DefSearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Def.Size()))
	n133, err := m.Def.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n133
	if m.Score != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Sourcegraph(data, i, uint32(math.Float32bits(float32(m.Score))))
	}
	if m.RefCount != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.RefCount))
	}
	return i, nil
}

func (m *SearchResultsList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchResultsList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RepoResults) > 0 {
		for _, msg := range m.RepoResults {
			data[i] = 0xa
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DefResults) > 0 {
		for _, msg := range m.DefResults {
			data[i] = 0x12
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SearchQueryOptions) > 0 {
		for _, msg := range m.SearchQueryOptions {
			data[i] = 0x1a
			i++
			i = encodeVarintSourcegraph(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SearchRefreshIndexOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchRefreshIndexOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, num := range m.Repos {
			data[i] = 0x8
			i++
			i = encodeVarintSourcegraph(data, i, uint64(num))
		}
	}
	if m.RefreshCounts {
		data[i] = 0x10
		i++
		if m.RefreshCounts {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RefreshSearch {
		data[i] = 0x18
		i++
		if m.RefreshSearch {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChannelListenOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelListenOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Channel)))
		i += copy(data[i:], m.Channel)
	}
	return i, nil
}

func (m *ChannelAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Error)))
		i += copy(data[i:], m.Error)
	}
	if len(m.Fix) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Fix)))
		i += copy(data[i:], m.Fix)
	}
	if len(m.Package) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Package)))
		i += copy(data[i:], m.Package)
	}
	if len(m.Repo) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Repo)))
		i += copy(data[i:], m.Repo)
	}
	if len(m.Def) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Def)))
		i += copy(data[i:], m.Def)
	}
	if m.Status != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.Status))
	}
	if m.VersionMajor != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.VersionMajor))
	}
	if m.VersionMinor != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintSourcegraph(data, i, uint64(m.VersionMinor))
	}
	if len(m.EditorType) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.EditorType)))
		i += copy(data[i:], m.EditorType)
	}
	return i, nil
}

func (m *ChannelSendOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelSendOp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintSourcegraph(data, i, uint64(len(m.Channel)))
		i += copy(data[i:], m.Channel)
	}
	data[i] = 0x12
	i++
	i = encodeVarintSourcegraph(data, i, uint64(m.Action.Size()))
	n134, err := m.Action.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n134
	if m.CheckForListeners {
		data[i] = 0x18
		i++
		if m.CheckForListeners {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChannelSendResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChannelSendResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Sourcegraph(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sourcegraph(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSourcegraph(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Origin) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Service != 0 {
		n += 1 + sovSourcegraph(uint64(m.Service))
	}
	l = len(m.APIBaseURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *CombinedStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Statuses) > 0 {
		for _, e := range m.Statuses {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ListOptions) Size() (n int) {
	var l int
	_ = l
	if m.PerPage != 0 {
		n += 1 + sovSourcegraph(uint64(m.PerPage))
	}
	if m.Page != 0 {
		n += 1 + sovSourcegraph(uint64(m.Page))
	}
	return n
}

func (m *ListResponse) Size() (n int) {
	var l int
	_ = l
	if m.Total != 0 {
		n += 1 + sovSourcegraph(uint64(m.Total))
	}
	return n
}

func (m *StreamResponse) Size() (n int) {
	var l int
	_ = l
	if m.HasMore {
		n += 2
	}
	return n
}

func (m *RepoConfig) Size() (n int) {
	var l int
	_ = l
	if len(m.Apps) > 0 {
		for _, s := range m.Apps {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Repo) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTTPCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.SSHCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HomepageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Blocked {
		n += 2
	}
	if m.Deprecated {
		n += 2
	}
	if m.Fork {
		n += 2
	}
	if m.Mirror {
		n += 2
	}
	if m.Private {
		n += 2
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.PushedAt != nil {
		l = m.PushedAt.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	if m.ID != 0 {
		n += 2 + sovSourcegraph(uint64(m.ID))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTMLURL)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.URIs) > 0 {
		for _, s := range m.URIs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.NoFork {
		n += 2
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoRevSpec) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoSpec) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *RepoStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.TargetURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.UpdatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoStatusList) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoStatuses) > 0 {
		for _, e := range m.RepoStatuses {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *RepoStatusesCreateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Repo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Status.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoList) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *ReposResolveRevOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ResolvedRev) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReceivePackOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.AdvertiseRefs {
		n += 2
	}
	return n
}

func (m *UploadPackOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.AdvertiseRefs {
		n += 2
	}
	return n
}

func (m *Packet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoResolveOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Remote {
		n += 2
	}
	return n
}

func (m *RepoResolution) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.RemoteRepo != nil {
		l = m.RemoteRepo.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CanonicalPath)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposListRemoteOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RemoteRepoList) Size() (n int) {
	var l int
	_ = l
	if len(m.RemoteRepos) > 0 {
		for _, e := range m.RemoteRepos {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *SrclibDataVersion) Size() (n int) {
	var l int
	_ = l
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CommitsBehind != 0 {
		n += 1 + sovSourcegraph(uint64(m.CommitsBehind))
	}
	return n
}

func (m *RepoConfigureAppOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.App)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	return n
}

func (m *ReposCreateOp) Size() (n int) {
	var l int
	_ = l
	if m.Op != nil {
		n += m.Op.Size()
	}
	return n
}

func (m *ReposCreateOp_New) Size() (n int) {
	var l int
	_ = l
	if m.New != nil {
		l = m.New.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *ReposCreateOp_FromGitHubID) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovSourcegraph(uint64(m.FromGitHubID))
	return n
}
func (m *ReposCreateOp_Origin) Size() (n int) {
	var l int
	_ = l
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *ReposCreateOp_NewRepo) Size() (n int) {
	var l int
	_ = l
	l = len(m.URI)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.CloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Mirror {
		n += 2
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposUpdateOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Fork != 0 {
		n += 1 + sovSourcegraph(uint64(m.Fork))
	}
	if m.Private != 0 {
		n += 1 + sovSourcegraph(uint64(m.Private))
	}
	return n
}

func (m *ReposListCommitsOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListCommitsOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Head)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Base)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *CommitList) Size() (n int) {
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ReposListBranchesOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListBranchesOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.IncludeCommit {
		n += 2
	}
	l = len(m.BehindAheadBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ContainsCommit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BranchList) Size() (n int) {
	var l int
	_ = l
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *ReposListTagsOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ReposListCommittersOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoListCommittersOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Rev)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *CommitterList) Size() (n int) {
	var l int
	_ = l
	if len(m.Committers) > 0 {
		for _, e := range m.Committers {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoListTagsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *TagList) Size() (n int) {
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *MirrorReposRefreshVCSOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.AsUser != nil {
		l = m.AsUser.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *VCSCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pass)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RemoteRepo) Size() (n int) {
	var l int
	_ = l
	if m.GitHubID != 0 {
		n += 1 + sovSourcegraph(uint64(m.GitHubID))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.VCS)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HTTPCloneURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DefaultBranch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UpdatedAt != nil {
		l = m.UpdatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Private {
		n += 2
	}
	if m.Fork {
		n += 2
	}
	if m.Mirror {
		n += 2
	}
	if m.Stars != 0 {
		n += 1 + sovSourcegraph(uint64(m.Stars))
	}
	if m.PushedAt != nil {
		l = m.PushedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.OwnerIsOrg {
		n += 2
	}
	return n
}

func (m *Build) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeartbeatAt != nil {
		l = m.HeartbeatAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Killed {
		n += 2
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Purged {
		n += 2
	}
	l = m.BuildConfig.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildConfig) Size() (n int) {
	var l int
	_ = l
	if m.Queue {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovSourcegraph(uint64(m.Priority))
	}
	l = len(m.BuilderConfig)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildJob) Size() (n int) {
	var l int
	_ = l
	l = m.Spec.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AccessToken)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildGetLogOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.MinID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildListOptions) Size() (n int) {
	var l int
	_ = l
	if m.Queued {
		n += 2
	}
	if m.Active {
		n += 2
	}
	if m.Ended {
		n += 2
	}
	if m.Succeeded {
		n += 2
	}
	if m.Failed {
		n += 2
	}
	if m.Purged {
		n += 2
	}
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildSpec) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *BuildTask) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ParentID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ParentID))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.CreatedAt.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Skipped {
		n += 2
	}
	if m.Warnings {
		n += 2
	}
	return n
}

func (m *BuildTaskListOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildUpdate) Size() (n int) {
	var l int
	_ = l
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeartbeatAt != nil {
		l = m.HeartbeatAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Purged {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Killed {
		n += 2
	}
	if m.Priority != 0 {
		n += 1 + sovSourcegraph(uint64(m.Priority))
	}
	l = len(m.BuilderConfig)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FileScore != 0 {
		n += 5
	}
	if m.RefScore != 0 {
		n += 5
	}
	if m.TokDensity != 0 {
		n += 5
	}
	return n
}

func (m *BuildList) Size() (n int) {
	var l int
	_ = l
	if len(m.Builds) > 0 {
		for _, e := range m.Builds {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsCreateOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Config.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsUpdateOp) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Info.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsListBuildTasksOp) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildTaskList) Size() (n int) {
	var l int
	_ = l
	if len(m.BuildTasks) > 0 {
		for _, e := range m.BuildTasks {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *BuildsCreateTasksOp) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if len(m.Tasks) > 0 {
		for _, e := range m.Tasks {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *BuildsUpdateTaskOp) Size() (n int) {
	var l int
	_ = l
	l = m.Task.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Info.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *BuildsGetTaskLogOp) Size() (n int) {
	var l int
	_ = l
	l = m.Task.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BuildsDequeueNextOp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EmailAddr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Verified {
		n += 2
	}
	if m.Primary {
		n += 2
	}
	if m.Guessed {
		n += 2
	}
	if m.Blacklisted {
		n += 2
	}
	return n
}

func (m *LogEntries) Size() (n int) {
	var l int
	_ = l
	l = len(m.MaxID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, s := range m.Entries {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Org) Size() (n int) {
	var l int
	_ = l
	l = m.User.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *OrgListMembersOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *OrgSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Org)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *OrgsListMembersOp) Size() (n int) {
	var l int
	_ = l
	l = m.Org.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UserList) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *UserCount) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovSourcegraph(uint64(m.Count))
	}
	return n
}

func (m *Person) Size() (n int) {
	var l int
	_ = l
	l = m.PersonSpec.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.FullName)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *PersonSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *TaskSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Build.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	return n
}

func (m *TaskUpdate) Size() (n int) {
	var l int
	_ = l
	if m.StartedAt != nil {
		l = m.StartedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EndedAt != nil {
		l = m.EndedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Success {
		n += 2
	}
	if m.Failure {
		n += 2
	}
	if m.Skipped {
		n += 2
	}
	if m.Warnings {
		n += 2
	}
	return n
}

func (m *User) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.IsOrganization {
		n += 2
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Company)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.HomepageURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Disabled {
		n += 2
	}
	if m.RegisteredAt != nil {
		l = m.RegisteredAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Admin {
		n += 2
	}
	if m.Write {
		n += 2
	}
	return n
}

func (m *UserSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *UsersListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if len(m.UIDs) > 0 {
		for _, e := range m.UIDs {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	return n
}

func (m *OrgsListOp) Size() (n int) {
	var l int
	_ = l
	l = m.Member.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *EmailAddrList) Size() (n int) {
	var l int
	_ = l
	if len(m.EmailAddrs) > 0 {
		for _, e := range m.EmailAddrs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *OrgList) Size() (n int) {
	var l int
	_ = l
	if len(m.Orgs) > 0 {
		for _, e := range m.Orgs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *CreatedAccount) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.TemporaryAccessToken)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *PasswordResetToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *PendingPasswordReset) Size() (n int) {
	var l int
	_ = l
	l = len(m.Link)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.EmailSent {
		n += 2
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *NewPassword) Size() (n int) {
	var l int
	_ = l
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *NewAccount) Size() (n int) {
	var l int
	_ = l
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	return n
}

func (m *LoginCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *GitHubAuthCode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *AccessTokenRequest) Size() (n int) {
	var l int
	_ = l
	if m.AuthorizationGrant != nil {
		n += m.AuthorizationGrant.Size()
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			l = len(s)
			n += 2 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *AccessTokenRequest_ResourceOwnerPassword) Size() (n int) {
	var l int
	_ = l
	if m.ResourceOwnerPassword != nil {
		l = m.ResourceOwnerPassword.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *AccessTokenRequest_GitHubAuthCode) Size() (n int) {
	var l int
	_ = l
	if m.GitHubAuthCode != nil {
		l = m.GitHubAuthCode.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}
func (m *AccessTokenResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ExpiresInSec != 0 {
		n += 1 + sovSourcegraph(uint64(m.ExpiresInSec))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Scope) > 0 {
		for _, s := range m.Scope {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.GitHubAccessToken)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.GitHubUser != nil {
		l = m.GitHubUser.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *GitHubUser) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ID))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Location)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Company)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *AuthInfo) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Login)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Write {
		n += 2
	}
	if m.Admin {
		n += 2
	}
	l = len(m.IntercomHash)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ExternalTokenSpec) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ExternalToken) Size() (n int) {
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ExtUID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ExtUID))
	}
	return n
}

func (m *Def) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.DocHTML != nil {
		l = m.DocHTML.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FmtStrings != nil {
		l = m.FmtStrings.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.StartLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndLine))
	}
	return n
}

func (m *DefGetOptions) Size() (n int) {
	var l int
	_ = l
	if m.Doc {
		n += 2
	}
	if m.ComputeLineRange {
		n += 2
	}
	return n
}

func (m *DefListOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ByteStart != 0 {
		n += 1 + sovSourcegraph(uint64(m.ByteStart))
	}
	if m.ByteEnd != 0 {
		n += 1 + sovSourcegraph(uint64(m.ByteEnd))
	}
	if len(m.DefKeys) > 0 {
		for _, e := range m.DefKeys {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.RepoRevs) > 0 {
		for _, s := range m.RepoRevs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.FilePathPrefix)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Exported {
		n += 2
	}
	if m.Nonlocal {
		n += 2
	}
	if m.IncludeTest {
		n += 2
	}
	if m.Doc {
		n += 3
	}
	if m.Fuzzy {
		n += 3
	}
	l = len(m.Sort)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Direction)
	if l > 0 {
		n += 2 + l + sovSourcegraph(uint64(l))
	}
	l = m.ListOptions.Size()
	n += 2 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListRefsOptions) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefSpec) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefsGetOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefList) Size() (n int) {
	var l int
	_ = l
	if len(m.Defs) > 0 {
		for _, e := range m.Defs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListRefsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RefList) Size() (n int) {
	var l int
	_ = l
	if len(m.Refs) > 0 {
		for _, e := range m.Refs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefListRefLocationsOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, s := range m.Repos {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListRefLocationsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefsListExamplesOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RefLocationsList) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoRefs) > 0 {
		for _, e := range m.RepoRefs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.StreamResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.TotalRepos != 0 {
		n += 1 + sovSourcegraph(uint64(m.TotalRepos))
	}
	return n
}

func (m *DefRepoRef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovSourcegraph(uint64(m.Count))
	}
	if m.Score != 0 {
		n += 5
	}
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DefFileRef) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovSourcegraph(uint64(m.Count))
	}
	if m.Score != 0 {
		n += 5
	}
	return n
}

func (m *Delta) Size() (n int) {
	var l int
	_ = l
	l = m.Base.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Head.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.BaseCommit != nil {
		l = m.BaseCommit.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.HeadCommit != nil {
		l = m.HeadCommit.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *FileDiff) Size() (n int) {
	var l int
	_ = l
	l = m.FileDiff.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if len(m.FileDiffHunks) > 0 {
		for _, e := range m.FileDiffHunks {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.PreImage)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.PostImage)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Stats.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Filtered {
		n += 2
	}
	return n
}

func (m *DeltaFiles) Size() (n int) {
	var l int
	_ = l
	if len(m.FileDiffs) > 0 {
		for _, e := range m.FileDiffs {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Delta != nil {
		l = m.Delta.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Stats.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DeltaFilter) Size() (n int) {
	var l int
	_ = l
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UnitType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DeltaListFilesOptions) Size() (n int) {
	var l int
	_ = l
	l = len(m.Filter)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.DeltaFilter.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if len(m.Ignore) > 0 {
		for _, s := range m.Ignore {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *DeltaSpec) Size() (n int) {
	var l int
	_ = l
	l = m.Base.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.Head.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DeltasListFilesOp) Size() (n int) {
	var l int
	_ = l
	l = m.Ds.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeGetOptions) Size() (n int) {
	var l int
	_ = l
	if m.ContentsAsString {
		n += 2
	}
	l = m.GetFileOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *GetFileOptions) Size() (n int) {
	var l int
	_ = l
	l = m.FileRange.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.EntireFile {
		n += 2
	}
	if m.ExpandContextLines != 0 {
		n += 1 + sovSourcegraph(uint64(m.ExpandContextLines))
	}
	if m.FullLines {
		n += 2
	}
	if m.Recursive {
		n += 2
	}
	if m.RecurseSingleSubfolderLimit != 0 {
		n += 1 + sovSourcegraph(uint64(m.RecurseSingleSubfolderLimit))
	}
	return n
}

func (m *RepoTreeSearchOptions) Size() (n int) {
	var l int
	_ = l
	l = m.SearchOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeSearchResult) Size() (n int) {
	var l int
	_ = l
	l = m.SearchResult.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeGetOp) Size() (n int) {
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeSearchOp) Size() (n int) {
	var l int
	_ = l
	l = m.Rev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoTreeListOp) Size() (n int) {
	var l int
	_ = l
	l = m.Rev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *RepoTreeListResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *VCSSearchResultList) Size() (n int) {
	var l int
	_ = l
	if len(m.SearchResults) > 0 {
		for _, e := range m.SearchResults {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = m.ListResponse.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *TreeEntry) Size() (n int) {
	var l int
	_ = l
	if m.BasicTreeEntry != nil {
		l = m.BasicTreeEntry.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.FileRange != nil {
		l = m.FileRange.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ContentsString)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *BasicTreeEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovSourcegraph(uint64(m.Type))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Contents)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *TreeEntrySpec) Size() (n int) {
	var l int
	_ = l
	l = m.RepoRev.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *FileRange) Size() (n int) {
	var l int
	_ = l
	if m.StartLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartLine))
	}
	if m.EndLine != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndLine))
	}
	if m.StartByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndByte))
	}
	return n
}

func (m *DefsRefreshIndexOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	if m.RefreshRefLocations {
		n += 2
	}
	if m.Force {
		n += 2
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *AsyncRefreshIndexesOp) Size() (n int) {
	var l int
	_ = l
	if m.Repo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Repo))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Force {
		n += 2
	}
	return n
}

func (m *AuthorshipInfo) Size() (n int) {
	var l int
	_ = l
	l = m.LastCommitDate.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	l = len(m.LastCommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefAuthor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AvatarURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.DefAuthorship.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefAuthorship) Size() (n int) {
	var l int
	_ = l
	l = m.AuthorshipInfo.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Bytes != 0 {
		n += 1 + sovSourcegraph(uint64(m.Bytes))
	}
	if m.BytesProportion != 0 {
		n += 9
	}
	return n
}

func (m *DefListAuthorsOptions) Size() (n int) {
	var l int
	_ = l
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	return n
}

func (m *DefsListAuthorsOp) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefAuthorList) Size() (n int) {
	var l int
	_ = l
	if len(m.DefAuthors) > 0 {
		for _, e := range m.DefAuthors {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *Checklist) Size() (n int) {
	var l int
	_ = l
	if m.Todo != 0 {
		n += 1 + sovSourcegraph(uint64(m.Todo))
	}
	if m.Done != 0 {
		n += 1 + sovSourcegraph(uint64(m.Done))
	}
	return n
}

func (m *FileToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Entry != nil {
		l = m.Entry.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ServerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ServerConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AppURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.IDKey)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *UserEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.UID != 0 {
		n += 1 + sovSourcegraph(uint64(m.UID))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Service)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *Event) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.DeviceID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.UserProperties) > 0 {
		for k, v := range m.UserProperties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovSourcegraph(uint64(mapEntrySize))
		}
	}
	if len(m.EventProperties) > 0 {
		for k, v := range m.EventProperties {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovSourcegraph(uint64(len(k))) + 1 + len(v) + sovSourcegraph(uint64(len(v)))
			n += mapEntrySize + 1 + sovSourcegraph(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventList) Size() (n int) {
	var l int
	_ = l
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.AppURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *NotifyGenericEvent) Size() (n int) {
	var l int
	_ = l
	if m.Actor != nil {
		l = m.Actor.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if len(m.Recipients) > 0 {
		for _, e := range m.Recipients {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.ActionType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ActionContent)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.ObjectID != 0 {
		n += 1 + sovSourcegraph(uint64(m.ObjectID))
	}
	l = len(m.ObjectRepo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ObjectType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ObjectTitle)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.ObjectURL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.SlackMsg)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.EmailHTML)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.NoEmail {
		n += 2
	}
	return n
}

func (m *Annotation) Size() (n int) {
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.StartByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.StartByte))
	}
	if m.EndByte != 0 {
		n += 1 + sovSourcegraph(uint64(m.EndByte))
	}
	l = len(m.Class)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.WantInner != 0 {
		n += 1 + sovSourcegraph(uint64(m.WantInner))
	}
	if len(m.URLs) > 0 {
		for _, s := range m.URLs {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if m.Def {
		n += 2
	}
	return n
}

func (m *AnnotationList) Size() (n int) {
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for _, e := range m.Annotations {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.LineStartBytes) > 0 {
		for _, e := range m.LineStartBytes {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	return n
}

func (m *AnnotationsListOptions) Size() (n int) {
	var l int
	_ = l
	l = m.Entry.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *SearchOptions) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	if len(m.NotRepos) > 0 {
		for _, e := range m.NotRepos {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	l = m.ListOptions.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.IncludeRepos {
		n += 2
	}
	if m.PrefixMatch {
		n += 2
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.NotLanguages) > 0 {
		for _, s := range m.NotLanguages {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.Kinds) > 0 {
		for _, s := range m.Kinds {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.NotKinds) > 0 {
		for _, s := range m.NotKinds {
			l = len(s)
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Fast {
		n += 2
	}
	if m.Latest {
		n += 2
	}
	return n
}

func (m *SearchOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Opt != nil {
		l = m.Opt.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *RepoSearchResult) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *DefSearchResult) Size() (n int) {
	var l int
	_ = l
	l = m.Def.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.Score != 0 {
		n += 5
	}
	if m.RefCount != 0 {
		n += 1 + sovSourcegraph(uint64(m.RefCount))
	}
	return n
}

func (m *SearchResultsList) Size() (n int) {
	var l int
	_ = l
	if len(m.RepoResults) > 0 {
		for _, e := range m.RepoResults {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.DefResults) > 0 {
		for _, e := range m.DefResults {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	if len(m.SearchQueryOptions) > 0 {
		for _, e := range m.SearchQueryOptions {
			l = e.Size()
			n += 1 + l + sovSourcegraph(uint64(l))
		}
	}
	return n
}

func (m *SearchRefreshIndexOp) Size() (n int) {
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			n += 1 + sovSourcegraph(uint64(e))
		}
	}
	if m.RefreshCounts {
		n += 2
	}
	if m.RefreshSearch {
		n += 2
	}
	return n
}

func (m *ChannelListenOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ChannelAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Fix)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Package)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = len(m.Def)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovSourcegraph(uint64(m.Status))
	}
	if m.VersionMajor != 0 {
		n += 1 + sovSourcegraph(uint64(m.VersionMajor))
	}
	if m.VersionMinor != 0 {
		n += 1 + sovSourcegraph(uint64(m.VersionMinor))
	}
	l = len(m.EditorType)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	return n
}

func (m *ChannelSendOp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovSourcegraph(uint64(l))
	}
	l = m.Action.Size()
	n += 1 + l + sovSourcegraph(uint64(l))
	if m.CheckForListeners {
		n += 2
	}
	return n
}

func (m *ChannelSendResult) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovSourcegraph(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSourcegraph(x uint64) (n int) {
	return sovSourcegraph(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Origin) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Origin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Origin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Service |= (Origin_ServiceType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIBaseURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIBaseURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CombinedStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CombinedStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CombinedStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statuses = append(m.Statuses, &RepoStatus{})
			if err := m.Statuses[len(m.Statuses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerPage", wireType)
			}
			m.PerPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PerPage |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Page |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Repo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTPCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SSHCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SSHCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomepageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomepageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blocked = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deprecated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deprecated = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fork = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Private = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &pbtypes.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushedAt == nil {
				m.PushedAt = &pbtypes.Timestamp{}
			}
			if err := m.PushedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &Origin{}
			}
			if err := m.Origin.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTMLURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTMLURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URIs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URIs = append(m.URIs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoFork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoFork = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoRevSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoRevSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoRevSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatusList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatusList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatusList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoStatuses = append(m.RepoStatuses, &RepoStatus{})
			if err := m.RepoStatuses[len(m.RepoStatuses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoStatusesCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoStatusesCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoStatusesCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repos = append(m.Repos, &Repo{})
			if err := m.Repos[len(m.Repos)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposResolveRevOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposResolveRevOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposResolveRevOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolvedRev) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolvedRev: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolvedRev: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceivePackOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceivePackOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceivePackOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseRefs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvertiseRefs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadPackOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadPackOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadPackOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdvertiseRefs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdvertiseRefs = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Packet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Packet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoResolveOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoResolveOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoResolveOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remote = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoResolution) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoResolution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoResolution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemoteRepo == nil {
				m.RemoteRepo = &RemoteRepo{}
			}
			if err := m.RemoteRepo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanonicalPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CanonicalPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListRemoteOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListRemoteOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListRemoteOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteRepoList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteRepoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteRepoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteRepos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteRepos = append(m.RemoteRepos, &RemoteRepo{})
			if err := m.RemoteRepos[len(m.RemoteRepos)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SrclibDataVersion) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SrclibDataVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SrclibDataVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitsBehind", wireType)
			}
			m.CommitsBehind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommitsBehind |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoConfigureAppOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoConfigureAppOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoConfigureAppOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.App = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReposCreateOp_NewRepo{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &ReposCreateOp_New{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromGitHubID", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &ReposCreateOp_FromGitHubID{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Origin{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &ReposCreateOp_Origin{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposCreateOp_NewRepo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewRepo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewRepo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposUpdateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposUpdateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposUpdateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			m.Fork = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Fork |= (ReposUpdateOp_BoolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			m.Private = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Private |= (ReposUpdateOp_BoolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListCommitsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListCommitsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListCommitsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListCommitsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListCommitsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListCommitsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListCommitsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Head = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Base = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &vcs.Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListBranchesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListBranchesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListBranchesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListBranchesOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListBranchesOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListBranchesOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListBranchesOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeCommit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeCommit = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BehindAheadBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BehindAheadBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainsCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainsCommit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, &vcs.Branch{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListTagsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListTagsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListTagsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListTagsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReposListCommittersOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReposListCommittersOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReposListCommittersOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoListCommittersOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListCommittersOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListCommittersOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListCommittersOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rev = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitterList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitterList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitterList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Committers = append(m.Committers, &vcs.Committer{})
			if err := m.Committers[len(m.Committers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoListTagsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoListTagsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoListTagsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &vcs.Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MirrorReposRefreshVCSOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MirrorReposRefreshVCSOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MirrorReposRefreshVCSOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AsUser == nil {
				m.AsUser = &UserSpec{}
			}
			if err := m.AsUser.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VCSCredentials) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VCSCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VCSCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pass = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteRepo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteRepo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteRepo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHubID", wireType)
			}
			m.GitHubID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GitHubID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VCS", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VCS = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HTTPCloneURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HTTPCloneURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultBranch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = &pbtypes.Timestamp{}
			}
			if err := m.UpdatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Private = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fork = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mirror", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mirror = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stars", wireType)
			}
			m.Stars = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Stars |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushedAt == nil {
				m.PushedAt = &pbtypes.Timestamp{}
			}
			if err := m.PushedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerIsOrg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OwnerIsOrg = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Build) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Build: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Build: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatAt == nil {
				m.HeartbeatAt = &pbtypes.Timestamp{}
			}
			if err := m.HeartbeatAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Killed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Killed = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purged = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BuildConfig.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Queue = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuilderConfig = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildJob) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildGetLogOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildGetLogOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildGetLogOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queued", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Queued = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ended", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ended = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeeded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Succeeded = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purged = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildTask) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentID", wireType)
			}
			m.ParentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ParentID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skipped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skipped = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Warnings = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildTaskListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildTaskListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildTaskListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatAt == nil {
				m.HeartbeatAt = &pbtypes.Timestamp{}
			}
			if err := m.HeartbeatAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purged = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Killed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Killed = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Priority |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuilderConfig", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuilderConfig = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.FileScore = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.RefScore = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokDensity", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TokDensity = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Builds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Builds = append(m.Builds, &Build{})
			if err := m.Builds[len(m.Builds)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsCreateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsCreateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsCreateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Config.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsUpdateOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsUpdateOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsUpdateOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsListBuildTasksOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsListBuildTasksOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsListBuildTasksOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &BuildTaskListOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildTaskList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildTaskList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildTaskList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildTasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BuildTasks = append(m.BuildTasks, &BuildTask{})
			if err := m.BuildTasks[len(m.BuildTasks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsCreateTasksOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsCreateTasksOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsCreateTasksOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tasks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tasks = append(m.Tasks, &BuildTask{})
			if err := m.Tasks[len(m.Tasks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsUpdateTaskOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsUpdateTaskOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsUpdateTaskOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Task.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsGetTaskLogOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsGetTaskLogOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsGetTaskLogOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Task.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &BuildGetLogOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildsDequeueNextOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildsDequeueNextOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildsDequeueNextOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailAddr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Primary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Primary = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guessed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Guessed = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blacklisted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blacklisted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntries) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Org) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Org: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Org: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgListMembersOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgListMembersOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgListMembersOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Org", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Org = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgsListMembersOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgsListMembersOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgsListMembersOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Org", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Org.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &OrgListMembersOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Person) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Person: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Person: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersonSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PersonSpec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FullName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersonSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersonSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersonSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Build", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Build.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = &pbtypes.Timestamp{}
			}
			if err := m.StartedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndedAt == nil {
				m.EndedAt = &pbtypes.Timestamp{}
			}
			if err := m.EndedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failure = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skipped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Skipped = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Warnings", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Warnings = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *User) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOrganization", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOrganization = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Company = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomepageURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomepageURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegisteredAt == nil {
				m.RegisteredAt = &pbtypes.Timestamp{}
			}
			if err := m.RegisteredAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UIDs", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UIDs = append(m.UIDs, v)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgsListOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgsListOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgsListOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Member.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmailAddrList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmailAddrList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmailAddrList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailAddrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailAddrs = append(m.EmailAddrs, &EmailAddr{})
			if err := m.EmailAddrs[len(m.EmailAddrs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orgs = append(m.Orgs, &Org{})
			if err := m.Orgs[len(m.Orgs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatedAccount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatedAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatedAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemporaryAccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TemporaryAccessToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordResetToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordResetToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordResetToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PendingPasswordReset) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PendingPasswordReset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PendingPasswordReset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &PasswordResetToken{}
			}
			if err := m.Token.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailSent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmailSent = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewPassword) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewPassword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewPassword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &PasswordResetToken{}
			}
			if err := m.Token.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewAccount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginCredentials) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitHubAuthCode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitHubAuthCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitHubAuthCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessTokenRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceOwnerPassword", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LoginCredentials{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthorizationGrant = &AccessTokenRequest_ResourceOwnerPassword{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHubAuthCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GitHubAuthCode{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.AuthorizationGrant = &AccessTokenRequest_GitHubAuthCode{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = append(m.Scope, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessTokenResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresInSec", wireType)
			}
			m.ExpiresInSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpiresInSec |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = append(m.Scope, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHubAccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitHubAccessToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitHubUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GitHubUser == nil {
				m.GitHubUser = &GitHubUser{}
			}
			if err := m.GitHubUser.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitHubUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitHubUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitHubUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Company", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Company = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Login", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Login = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Write", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Write = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Admin = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntercomHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntercomHash = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalTokenSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalTokenSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalTokenSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtUID", wireType)
			}
			m.ExtUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExtUID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Def) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Def: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Def: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocHTML", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocHTML == nil {
				m.DocHTML = &pbtypes2.HTML{}
			}
			if err := m.DocHTML.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FmtStrings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FmtStrings == nil {
				m.FmtStrings = &graph.DefFormatStrings{}
			}
			if err := m.FmtStrings.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartLine |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndLine", wireType)
			}
			m.EndLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndLine |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefGetOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefGetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefGetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Doc = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputeLineRange", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ComputeLineRange = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteStart", wireType)
			}
			m.ByteStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteStart |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteEnd", wireType)
			}
			m.ByteEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteEnd |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefKeys = append(m.DefKeys, &graph.DefKey{})
			if err := m.DefKeys[len(m.DefKeys)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRevs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoRevs = append(m.RepoRevs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePathPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePathPrefix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exported = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonlocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nonlocal = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeTest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeTest = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Doc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Doc = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fuzzy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fuzzy = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Direction = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListRefsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListRefsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListRefsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsGetOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsGetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsGetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefGetOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Defs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Defs = append(m.Defs, &Def{})
			if err := m.Defs[len(m.Defs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListRefsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListRefsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListRefsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListRefsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refs = append(m.Refs, &graph1.Ref{})
			if err := m.Refs[len(m.Refs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListRefLocationsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListRefLocationsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListRefLocationsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repos = append(m.Repos, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListRefLocationsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListRefLocationsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListRefLocationsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListRefLocationsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListExamplesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListExamplesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListExamplesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefLocationsList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefLocationsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefLocationsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoRefs = append(m.RepoRefs, &DefRepoRef{})
			if err := m.RepoRefs[len(m.RepoRefs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StreamResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRepos", wireType)
			}
			m.TotalRepos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalRepos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefRepoRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefRepoRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefRepoRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &DefFileRef{})
			if err := m.Files[len(m.Files)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefFileRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefFileRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefFileRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Base.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseCommit == nil {
				m.BaseCommit = &vcs.Commit{}
			}
			if err := m.BaseCommit.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeadCommit == nil {
				m.HeadCommit = &vcs.Commit{}
			}
			if err := m.HeadCommit.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDiff) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDiff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileDiff.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDiffHunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileDiffHunks = append(m.FileDiffHunks, &diff.Hunk{})
			if err := m.FileDiffHunks[len(m.FileDiffHunks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreImage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostImage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filtered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Filtered = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaFiles) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaFiles: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaFiles: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDiffs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileDiffs = append(m.FileDiffs, &FileDiff{})
			if err := m.FileDiffs[len(m.FileDiffs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delta == nil {
				m.Delta = &Delta{}
			}
			if err := m.Delta.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaFilter) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnitType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaListFilesOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaListFilesOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaListFilesOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeltaFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeltaFilter.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ignore = append(m.Ignore, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltaSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltaSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltaSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Base.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeltasListFilesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeltasListFilesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeltasListFilesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ds.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DeltaListFilesOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeGetOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeGetOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeGetOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentsAsString", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContentsAsString = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetFileOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetFileOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntireFile", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EntireFile = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpandContextLines", wireType)
			}
			m.ExpandContextLines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpandContextLines |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullLines", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullLines = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recursive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recursive = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecurseSingleSubfolderLimit", wireType)
			}
			m.RecurseSingleSubfolderLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RecurseSingleSubfolderLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SearchOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SearchResult.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeGetOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeGetOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeGetOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoTreeGetOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeSearchOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeSearchOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeSearchOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &RepoTreeSearchOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeListOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeListOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeListOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoTreeListResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoTreeListResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoTreeListResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VCSSearchResultList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VCSSearchResultList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VCSSearchResultList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchResults = append(m.SearchResults, &vcs.SearchResult{})
			if err := m.SearchResults[len(m.SearchResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListResponse.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasicTreeEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BasicTreeEntry == nil {
				m.BasicTreeEntry = &BasicTreeEntry{}
			}
			if err := m.BasicTreeEntry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileRange == nil {
				m.FileRange = &FileRange{}
			}
			if err := m.FileRange.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentsString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentsString = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicTreeEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicTreeEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicTreeEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (TreeEntryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contents", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contents = append(m.Contents[:0], data[iNdEx:postIndex]...)
			if m.Contents == nil {
				m.Contents = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &BasicTreeEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeEntrySpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeEntrySpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeEntrySpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoRev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RepoRev.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileRange) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartLine", wireType)
			}
			m.StartLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartLine |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndLine", wireType)
			}
			m.EndLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndLine |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartByte", wireType)
			}
			m.StartByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartByte |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndByte", wireType)
			}
			m.EndByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndByte |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsRefreshIndexOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsRefreshIndexOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsRefreshIndexOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshRefLocations", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshRefLocations = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AsyncRefreshIndexesOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AsyncRefreshIndexesOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AsyncRefreshIndexesOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			m.Repo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Repo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorshipInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorshipInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorshipInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastCommitDate.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvatarURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvatarURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefAuthorship", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DefAuthorship.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthorship) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthorship: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthorship: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorshipInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AuthorshipInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Bytes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesProportion", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.BytesProportion = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefListAuthorsOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefListAuthorsOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefListAuthorsOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefsListAuthorsOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefsListAuthorsOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefsListAuthorsOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &DefListAuthorsOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefAuthorList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefAuthorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefAuthorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefAuthors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefAuthors = append(m.DefAuthors, &DefAuthor{})
			if err := m.DefAuthors[len(m.DefAuthors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Checklist) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Checklist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Checklist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Todo", wireType)
			}
			m.Todo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Todo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			m.Done = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Done |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entry == nil {
				m.Entry = &BasicTreeEntry{}
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServerConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Service = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &pbtypes.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &pbtypes.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.UserProperties == nil {
				m.UserProperties = make(map[string]string)
			}
			m.UserProperties[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.EventProperties == nil {
				m.EventProperties = make(map[string]string)
			}
			m.EventProperties[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotifyGenericEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotifyGenericEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotifyGenericEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Actor == nil {
				m.Actor = &UserSpec{}
			}
			if err := m.Actor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipients = append(m.Recipients, &UserSpec{})
			if err := m.Recipients[len(m.Recipients)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionContent = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectID", wireType)
			}
			m.ObjectID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ObjectID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectRepo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectRepo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectTitle = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectURL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlackMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlackMsg = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailHTML", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailHTML = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoEmail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoEmail = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Annotation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Annotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Annotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartByte", wireType)
			}
			m.StartByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartByte |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndByte", wireType)
			}
			m.EndByte = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndByte |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Class = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantInner", wireType)
			}
			m.WantInner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WantInner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URLs = append(m.URLs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Def = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotationList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotationList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotationList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, &Annotation{})
			if err := m.Annotations[len(m.Annotations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineStartBytes", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LineStartBytes = append(m.LineStartBytes, v)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnotationsListOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnotationsListOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnotationsListOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Entry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &FileRange{}
			}
			if err := m.Range.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchOptions) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Repos = append(m.Repos, v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotRepos", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotRepos = append(m.NotRepos, v)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ListOptions.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeRepos", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeRepos = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefixMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrefixMatch = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotLanguages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotLanguages = append(m.NotLanguages, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kinds = append(m.Kinds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotKinds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotKinds = append(m.NotKinds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fast = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latest", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Latest = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Opt == nil {
				m.Opt = &SearchOptions{}
			}
			if err := m.Opt.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoSearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DefSearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DefSearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DefSearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Def.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Score = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefCount", wireType)
			}
			m.RefCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RefCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResultsList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResultsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResultsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoResults = append(m.RepoResults, &RepoSearchResult{})
			if err := m.RepoResults[len(m.RepoResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefResults = append(m.DefResults, &DefSearchResult{})
			if err := m.DefResults[len(m.DefResults)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchQueryOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SearchQueryOptions = append(m.SearchQueryOptions, &SearchOptions{})
			if err := m.SearchQueryOptions[len(m.SearchQueryOptions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRefreshIndexOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRefreshIndexOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRefreshIndexOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Repos = append(m.Repos, v)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshCounts", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshCounts = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshSearch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RefreshSearch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelListenOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelListenOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelListenOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Package = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Def", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Def = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionMajor", wireType)
			}
			m.VersionMajor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VersionMajor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionMinor", wireType)
			}
			m.VersionMinor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VersionMinor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EditorType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelSendOp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelSendOp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelSendOp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSourcegraph
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Action.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckForListeners", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CheckForListeners = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelSendResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelSendResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelSendResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSourcegraph(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSourcegraph
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSourcegraph(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSourcegraph
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSourcegraph
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSourcegraph
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSourcegraph
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSourcegraph(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSourcegraph = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSourcegraph   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorSourcegraph = []byte{
	// 6893 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x7c, 0x5d, 0x6c, 0x1c, 0x47,
	0x72, 0xb0, 0xf6, 0x97, 0xbb, 0xcd, 0x1f, 0x91, 0x23, 0x8a, 0xa2, 0x56, 0xb6, 0x28, 0x8d, 0xff,
	0x64, 0x5b, 0xa6, 0x74, 0xd4, 0xf9, 0x7c, 0xbe, 0x3b, 0xdb, 0x47, 0x6a, 0x49, 0x93, 0x67, 0x89,
	0xe2, 0x71, 0x29, 0xd9, 0x77, 0xc0, 0x07, 0x7f, 0xc3, 0xdd, 0x21, 0x39, 0xa7, 0xdd, 0x99, 0xbd,
	0x99, 0x59, 0x5a, 0x74, 0x90, 0x03, 0x82, 0x00, 0x49, 0x80, 0x3c, 0xe4, 0x21, 0x41, 0x02, 0x04,
	0x08, 0x10, 0xe4, 0x10, 0x20, 0x40, 0x80, 0x00, 0x77, 0x08, 0x82, 0x00, 0x01, 0x12, 0x24, 0x4f,
	0xf7, 0x92, 0xe0, 0x5e, 0x92, 0xbc, 0x19, 0xb9, 0x4b, 0x82, 0x00, 0x09, 0x82, 0x00, 0x79, 0x0f,
	0x92, 0xaa, 0xea, 0xee, 0x99, 0x9e, 0x9e, 0x1f, 0x2e, 0x2d, 0xf9, 0x41, 0x36, 0xb7, 0xbb, 0xba,
	0xba, 0xbb, 0xaa, 0xba, 0xfe, 0xba, 0x7a, 0xd8, 0x5c, 0xe0, 0x8d, 0xfc, 0xae, 0x7d, 0xe8, 0x5b,
	0xc3, 0xa3, 0xe5, 0xa1, 0xef, 0x85, 0x9e, 0x31, 0xa9, 0x34, 0xb5, 0xde, 0x38, 0x74, 0xc2, 0xa3,
	0xd1, 0xfe, 0x72, 0xd7, 0x1b, 0xdc, 0x3a, 0xf4, 0x0e, 0xbd, 0x5b, 0x04, 0xb3, 0x3f, 0x3a, 0xa0,
	0x5f, 0xf4, 0x83, 0xfe, 0xe2, 0x63, 0x5b, 0x77, 0x54, 0x74, 0x38, 0x46, 0xf9, 0x0d, 0x70, 0x6f,
	0xf4, 0x9c, 0x83, 0x83, 0x5b, 0xd1, 0x7f, 0xc4, 0xa0, 0xb7, 0x8b, 0x06, 0xa9, 0x7f, 0x0f, 0x1f,
	0x1f, 0xde, 0x3a, 0xee, 0x06, 0xf8, 0x4f, 0x0c, 0x5d, 0x29, 0x1c, 0xea, 0x77, 0xfb, 0xce, 0xfe,
	0x2d, 0xfe, 0xa3, 0x67, 0x1f, 0x9c, 0x79, 0x8c, 0x1f, 0x8d, 0x79, 0x3d, 0x35, 0xe6, 0xfb, 0xc1,
	0xad, 0xe1, 0x7e, 0x78, 0x32, 0xb4, 0x83, 0x5b, 0xa1, 0x33, 0xb0, 0x83, 0xd0, 0x1a, 0x0c, 0x05,
	0xf0, 0xcb, 0x45, 0xc0, 0xc7, 0x9e, 0xd3, 0x1b, 0x07, 0xee, 0x28, 0x1c, 0xf4, 0x05, 0xdc, 0xfa,
	0x59, 0xe8, 0xe3, 0xb8, 0xc7, 0xb6, 0x1b, 0x7a, 0xfe, 0x49, 0xfc, 0x17, 0x47, 0x63, 0xfe, 0x02,
	0xab, 0x3f, 0xf0, 0x9d, 0x43, 0xc7, 0x35, 0x18, 0x2b, 0x6f, 0xb5, 0x17, 0x4b, 0xd7, 0x4a, 0x37,
	0x9a, 0xc6, 0x57, 0xd8, 0x44, 0xc7, 0xf6, 0x8f, 0x9d, 0xae, 0xbd, 0x58, 0x86, 0x86, 0x99, 0x95,
	0xa5, 0x65, 0x75, 0x3a, 0x3e, 0x62, 0x59, 0x80, 0xec, 0xc1, 0xd2, 0xd6, 0xaa, 0xff, 0xfe, 0xd9,
	0xd2, 0x39, 0x03, 0x90, 0xac, 0xee, 0x6c, 0xad, 0x59, 0x81, 0xfd, 0x70, 0xf7, 0xde, 0x62, 0x05,
	0x71, 0x99, 0x97, 0xd9, 0xa4, 0x02, 0x08, 0x10, 0xf5, 0xf7, 0x9d, 0x70, 0x73, 0xb4, 0x3f, 0x7b,
	0xce, 0x74, 0xd8, 0xcc, 0x5d, 0x6f, 0xb0, 0xef, 0xb8, 0x76, 0xaf, 0x13, 0x5a, 0xe1, 0x28, 0x30,
	0x66, 0x59, 0x03, 0x5a, 0x06, 0x4e, 0x18, 0x2d, 0x65, 0x9a, 0xd5, 0xb0, 0x8f, 0x2f, 0xa4, 0x69,
	0xbc, 0xca, 0x1a, 0x1c, 0xd4, 0x0e, 0x00, 0x7f, 0xe5, 0xc6, 0xe4, 0xca, 0xa5, 0xc4, 0xd2, 0x76,
	0xed, 0xa1, 0x27, 0x70, 0x4d, 0xb2, 0xca, 0xae, 0x7d, 0xbc, 0x58, 0xa5, 0x55, 0x7c, 0xc4, 0x26,
	0xef, 0x39, 0x41, 0xf8, 0x60, 0x18, 0x3a, 0x9e, 0x1b, 0x18, 0x2f, 0xb1, 0x89, 0x1d, 0xdb, 0xdf,
	0xb1, 0x0e, 0x6d, 0x9a, 0xa6, 0xb6, 0x36, 0xff, 0xdf, 0x9f, 0x2d, 0xcd, 0x8e, 0xfc, 0xfe, 0xd7,
	0xcc, 0x9b, 0x1e, 0x4c, 0x6f, 0x0f, 0x86, 0xe1, 0x89, 0x69, 0x98, 0xac, 0x4a, 0x30, 0xe5, 0x7c,
	0x18, 0xf3, 0x0e, 0x9b, 0x42, 0xcc, 0xbb, 0x76, 0x30, 0x04, 0xcc, 0xb6, 0xf1, 0x02, 0xab, 0xed,
	0x79, 0xa1, 0xd5, 0x2f, 0x42, 0x6c, 0xbe, 0xc5, 0x66, 0x3a, 0xa1, 0x6f, 0x5b, 0x83, 0x68, 0x18,
	0xac, 0x68, 0xd3, 0x0a, 0xee, 0x7b, 0x3e, 0x5f, 0x51, 0x23, 0x67, 0x60, 0x8b, 0x31, 0xdc, 0xe2,
	0x5d, 0xcf, 0x3d, 0x70, 0x0e, 0x8d, 0x29, 0x56, 0x5d, 0x1d, 0x0e, 0x03, 0x18, 0x51, 0x81, 0x3d,
	0xfe, 0x79, 0x85, 0x55, 0xb1, 0x13, 0x77, 0xfe, 0x70, 0x77, 0x2b, 0x26, 0xe0, 0x83, 0x4f, 0x5c,
	0xdb, 0x17, 0x04, 0x84, 0x21, 0xdb, 0xd6, 0xc0, 0xe6, 0xcc, 0x31, 0x2e, 0xb0, 0xc9, 0xb6, 0x1d,
	0x74, 0x7d, 0x87, 0xe8, 0xc2, 0x69, 0x65, 0xcc, 0xb3, 0xa9, 0xcd, 0xbd, 0xbd, 0x9d, 0xbb, 0x7d,
	0xcf, 0x25, 0x3e, 0xd6, 0x24, 0x68, 0xa7, 0xb3, 0x19, 0x35, 0xd6, 0x65, 0xe3, 0xa6, 0x37, 0xb0,
	0x87, 0x40, 0x24, 0x6c, 0x9c, 0xa0, 0xc6, 0x8b, 0x6c, 0xba, 0x6d, 0x1f, 0x58, 0xa3, 0x7e, 0xb8,
	0xe6, 0x5b, 0x6e, 0xf7, 0x68, 0xb1, 0x41, 0xcd, 0xc0, 0xdb, 0x7b, 0x96, 0x7b, 0x38, 0x42, 0x82,
	0x36, 0xa9, 0xe5, 0x3c, 0x9b, 0x58, 0xeb, 0x7b, 0xdd, 0xc7, 0x76, 0x6f, 0x91, 0xe1, 0x9e, 0x51,
	0x7e, 0xda, 0xf6, 0xd0, 0xb7, 0xbb, 0xc0, 0xf0, 0xde, 0xe2, 0x24, 0xb5, 0xc1, 0x82, 0x37, 0x3c,
	0xff, 0xf1, 0xe2, 0x14, 0xfd, 0x9a, 0x61, 0xf5, 0xfb, 0x8e, 0xef, 0x7b, 0xfe, 0xe2, 0x34, 0xfd,
	0x06, 0x14, 0x3b, 0xbe, 0x73, 0x8c, 0x02, 0x32, 0x43, 0x0d, 0x2f, 0xb1, 0xe6, 0x5d, 0x20, 0x2c,
	0x8c, 0x5f, 0x0d, 0x17, 0xcf, 0x43, 0xd3, 0xe4, 0x8a, 0xb1, 0x2c, 0xce, 0xcf, 0xf2, 0x9e, 0x3c,
	0x94, 0x08, 0xf6, 0x70, 0xd8, 0x13, 0x60, 0xb3, 0xb9, 0x60, 0x2f, 0xb2, 0xc6, 0xce, 0x28, 0x38,
	0x22, 0xa8, 0xb9, 0x5c, 0x28, 0x7e, 0x74, 0x0c, 0xe4, 0x37, 0xb0, 0x5f, 0x1c, 0xa8, 0xc5, 0x0b,
	0x04, 0x7f, 0x21, 0xe3, 0xe4, 0xe0, 0xaa, 0x37, 0xf7, 0xee, 0xdf, 0x43, 0x92, 0x2d, 0x90, 0x78,
	0xfe, 0x4f, 0x99, 0x9d, 0x47, 0xd6, 0xa9, 0x32, 0x6a, 0x0a, 0x4e, 0x11, 0x1b, 0x73, 0x04, 0x14,
	0x84, 0xed, 0xdb, 0x23, 0xdb, 0x3f, 0xe1, 0xcc, 0xcd, 0x01, 0xba, 0xc1, 0xaa, 0x20, 0x0e, 0xfc,
	0xbc, 0x34, 0xd7, 0x5a, 0x00, 0xb3, 0xc0, 0x61, 0x40, 0x6d, 0x0c, 0x2c, 0x4d, 0xde, 0x3b, 0x9e,
	0x1f, 0x72, 0x8e, 0xe7, 0x60, 0x7b, 0x85, 0x35, 0xdb, 0x0e, 0xb0, 0x88, 0x04, 0xa6, 0x5e, 0x00,
	0xf8, 0x22, 0xab, 0x6f, 0x7b, 0xc4, 0xba, 0x89, 0x7c, 0x81, 0xc6, 0x29, 0x51, 0x2f, 0x70, 0x19,
	0xc9, 0xdf, 0x25, 0x17, 0x61, 0x56, 0x00, 0xf4, 0xf5, 0xc4, 0x09, 0x27, 0xe1, 0x99, 0x5c, 0x59,
	0x4c, 0x50, 0x5f, 0xe9, 0x5f, 0x9b, 0xfa, 0x09, 0x28, 0xac, 0x9f, 0x7e, 0xb6, 0x54, 0x42, 0xc5,
	0x65, 0xbe, 0xc1, 0x26, 0x91, 0xfc, 0xa0, 0x2f, 0x3a, 0x43, 0xbb, 0x8b, 0x32, 0x87, 0x3f, 0xf9,
	0x11, 0x4e, 0x28, 0x25, 0xa2, 0xb3, 0xb9, 0xc0, 0x1a, 0xa4, 0x68, 0x10, 0x36, 0xd6, 0x9b, 0x35,
	0xf3, 0x4f, 0x4a, 0xfc, 0x78, 0x0a, 0x0d, 0xa4, 0xe9, 0xae, 0x39, 0xd6, 0xdc, 0xb3, 0xfc, 0x43,
	0x3b, 0x8c, 0x94, 0x63, 0xf6, 0xf9, 0x03, 0xe9, 0x80, 0xf3, 0x1d, 0xda, 0x4f, 0x04, 0x23, 0x8c,
	0xd7, 0x55, 0x99, 0xae, 0xe7, 0x89, 0xe1, 0x5a, 0x15, 0xb7, 0x84, 0xc0, 0xb1, 0x64, 0x4f, 0x14,
	0x03, 0x9b, 0xef, 0xb1, 0x99, 0x78, 0xbd, 0x48, 0x1e, 0xe3, 0x0d, 0x36, 0x15, 0xb7, 0xd8, 0x5c,
	0xb5, 0xe4, 0x2b, 0x59, 0x33, 0x60, 0xf3, 0x2a, 0x38, 0x5f, 0xe6, 0x83, 0xa1, 0x71, 0x53, 0xa1,
	0xa0, 0xce, 0x06, 0x85, 0xd2, 0x62, 0xcd, 0x6f, 0xb0, 0x3a, 0xc7, 0x40, 0x94, 0xca, 0x9f, 0x4e,
	0xac, 0xfa, 0x26, 0x27, 0x3f, 0xad, 0xf7, 0x1a, 0xab, 0xe1, 0xdf, 0x72, 0xa1, 0x73, 0xa9, 0x91,
	0xe6, 0x32, 0x9b, 0x23, 0x08, 0x50, 0xb5, 0x5e, 0xff, 0xd8, 0x86, 0x99, 0x61, 0x7d, 0xc0, 0x61,
	0x3f, 0xe6, 0x30, 0x28, 0x4c, 0x1f, 0x4c, 0x05, 0x67, 0xee, 0x12, 0xca, 0x02, 0x81, 0xf6, 0x00,
	0x36, 0x6d, 0x92, 0xcc, 0x35, 0x36, 0xbd, 0x6b, 0x77, 0x6d, 0xe7, 0xd8, 0xde, 0xb1, 0xba, 0x8f,
	0x53, 0xc8, 0xe0, 0x17, 0x90, 0xdf, 0x22, 0x0e, 0x4f, 0xa1, 0x32, 0xb4, 0x7a, 0xc7, 0xb6, 0x1f,
	0x3a, 0x01, 0x4c, 0x7d, 0x10, 0x10, 0x8f, 0x1b, 0xe6, 0x2a, 0x9b, 0x7a, 0x38, 0xec, 0x7b, 0x56,
	0xef, 0xf3, 0xa3, 0x58, 0x60, 0x75, 0x1c, 0x6c, 0x87, 0x11, 0x38, 0x0e, 0x9e, 0x02, 0x59, 0x9e,
	0xe6, 0x14, 0xa6, 0x3d, 0x70, 0xdc, 0x43, 0x2b, 0x3c, 0x12, 0xf6, 0x00, 0x34, 0xa8, 0x6f, 0x0f,
	0x3c, 0x21, 0x95, 0x0d, 0x73, 0x9f, 0x8b, 0x00, 0x81, 0x8f, 0x50, 0x0a, 0x35, 0xe9, 0x7f, 0x1d,
	0x45, 0x1a, 0xe1, 0xa9, 0x2d, 0x9b, 0x3f, 0xb2, 0x1b, 0x97, 0x7a, 0xd7, 0x72, 0x3d, 0xd7, 0xe9,
	0x5a, 0xfd, 0x1d, 0x9c, 0x93, 0xfb, 0x00, 0x0f, 0xd9, 0x02, 0xb1, 0x80, 0x1b, 0x4a, 0x84, 0x96,
	0x4a, 0x4e, 0x3b, 0xb5, 0xa5, 0x33, 0x9d, 0xda, 0x77, 0x71, 0xe9, 0x72, 0x6e, 0x92, 0x86, 0x9b,
	0xc8, 0x3b, 0xd9, 0x92, 0x27, 0xbc, 0xb2, 0xdf, 0xfc, 0x06, 0x9b, 0xeb, 0x90, 0x6b, 0xd7, 0x06,
	0xea, 0x3d, 0xb2, 0xfd, 0x00, 0x77, 0x9f, 0x76, 0x41, 0x70, 0x53, 0xd4, 0x12, 0xac, 0xd9, 0x47,
	0x8e, 0xdb, 0xe3, 0xee, 0x00, 0x9c, 0x1d, 0x23, 0x36, 0xc5, 0x23, 0xdf, 0x06, 0x4b, 0xcc, 0x89,
	0xbd, 0x9b, 0x10, 0x2c, 0x68, 0x16, 0xe7, 0x1f, 0x28, 0xbf, 0xee, 0x5a, 0xfb, 0x7d, 0x6e, 0x7c,
	0x1b, 0xe6, 0x2f, 0x97, 0x39, 0xa7, 0xe2, 0x53, 0xf3, 0x25, 0x56, 0xd9, 0xb6, 0x3f, 0x11, 0x54,
	0x30, 0x53, 0xa2, 0x1c, 0x01, 0x2e, 0x03, 0x14, 0x36, 0x6c, 0x9e, 0x33, 0x5a, 0x6c, 0x6a, 0xc3,
	0xf7, 0x06, 0xdc, 0xa7, 0x12, 0x0a, 0xaa, 0xb6, 0x56, 0x5e, 0x2c, 0x41, 0xdf, 0x4b, 0x91, 0x2d,
	0xaa, 0xe4, 0xda, 0xa2, 0xcd, 0x73, 0xad, 0x63, 0x36, 0x21, 0xf0, 0x25, 0x3d, 0x07, 0xa4, 0x84,
	0x34, 0xf7, 0x95, 0x6c, 0xcb, 0x5e, 0x95, 0x1b, 0x13, 0x46, 0xb9, 0x46, 0x36, 0x58, 0xd3, 0x6a,
	0xf5, 0x94, 0xf9, 0x27, 0x3f, 0x61, 0xad, 0xca, 0xca, 0x0f, 0x86, 0xe6, 0x7f, 0x95, 0x04, 0x15,
	0xb8, 0xd6, 0x4a, 0x91, 0x50, 0x43, 0x56, 0x4e, 0x21, 0xcb, 0x59, 0x1a, 0x9f, 0xf5, 0x4b, 0xc2,
	0x7b, 0x98, 0x20, 0x37, 0xf6, 0x85, 0x34, 0x49, 0xe5, 0xac, 0xcb, 0x6b, 0x9e, 0xd7, 0x27, 0x0f,
	0xf5, 0xcb, 0xb1, 0x4b, 0xd1, 0x18, 0x7b, 0x94, 0x09, 0x8e, 0x69, 0x84, 0xa1, 0x01, 0x96, 0xfb,
	0xc1, 0xf6, 0xfa, 0xec, 0x39, 0xfc, 0x6b, 0x6f, 0xf7, 0xe1, 0xfa, 0x6c, 0xc9, 0x68, 0xb2, 0xda,
	0xc6, 0xea, 0xbd, 0xce, 0xfa, 0x6c, 0xd9, 0xdc, 0xe3, 0x82, 0x43, 0xa7, 0x41, 0x08, 0x56, 0x6a,
	0xd7, 0xb7, 0x59, 0x05, 0x64, 0x5e, 0x1c, 0xb7, 0xf4, 0x02, 0x12, 0x43, 0xe9, 0x68, 0x98, 0x7f,
	0x5d, 0xe2, 0x87, 0x2c, 0xdd, 0x85, 0x36, 0x76, 0xd3, 0xb6, 0x7a, 0x85, 0x9e, 0x04, 0xc0, 0xa0,
	0xdf, 0x5e, 0xe8, 0x48, 0x68, 0x87, 0xb5, 0x72, 0x96, 0xc3, 0xca, 0x7d, 0xe9, 0x50, 0x88, 0x4c,
	0x8e, 0x77, 0x3b, 0x60, 0x8c, 0x2f, 0x9d, 0x0e, 0xf3, 0x73, 0x68, 0x07, 0x69, 0x23, 0xe2, 0x20,
	0x4f, 0x2e, 0x63, 0x90, 0xc7, 0xdb, 0x8c, 0x55, 0xdd, 0x85, 0x16, 0xc4, 0xba, 0x92, 0x58, 0x4f,
	0x12, 0x44, 0xd3, 0x1f, 0x8f, 0xd8, 0x85, 0x88, 0x11, 0x5c, 0x6a, 0xec, 0x34, 0x27, 0xbe, 0xa4,
	0x72, 0xe2, 0xc5, 0x4c, 0x4e, 0xc4, 0x63, 0x39, 0x2b, 0x7e, 0xbf, 0xc4, 0x2e, 0xe5, 0xf4, 0x3d,
	0x1d, 0x0d, 0x41, 0xc8, 0xb7, 0xdc, 0x6e, 0x7f, 0xd4, 0xb3, 0x39, 0x11, 0xb8, 0x25, 0x30, 0x2e,
	0xb3, 0x39, 0xae, 0x99, 0x56, 0x8f, 0x80, 0xcd, 0x42, 0xfe, 0xb9, 0xeb, 0xb0, 0x80, 0x21, 0x96,
	0x1b, 0x5a, 0x8e, 0x1b, 0x88, 0x21, 0x74, 0x2e, 0x4c, 0x97, 0x31, 0x0e, 0x47, 0x94, 0x7e, 0x1e,
	0x84, 0x57, 0xac, 0x33, 0x41, 0x6a, 0xde, 0xf8, 0x2c, 0x48, 0xbd, 0xcd, 0xfd, 0x5b, 0x22, 0xf5,
	0x9e, 0x75, 0x98, 0x26, 0xf3, 0x1b, 0x2a, 0x99, 0xaf, 0x65, 0x92, 0x99, 0x8f, 0xe3, 0x24, 0xfe,
	0x2e, 0xbb, 0xa8, 0x9d, 0xa1, 0x10, 0xf4, 0x77, 0x0a, 0xeb, 0x1d, 0x15, 0xeb, 0xcb, 0x05, 0xc7,
	0x88, 0x8f, 0xe6, 0xb8, 0x6d, 0x76, 0x39, 0xb7, 0x53, 0x46, 0x95, 0x5c, 0x43, 0x6a, 0xcc, 0x2c,
	0x9f, 0xc9, 0x7a, 0x1d, 0x4b, 0xb3, 0x02, 0xe8, 0x89, 0x0b, 0xa6, 0x94, 0x7e, 0x9c, 0x4f, 0xf0,
	0x61, 0x46, 0x11, 0x79, 0x68, 0x7e, 0x16, 0xac, 0xd8, 0xe5, 0x52, 0xaf, 0x51, 0xf4, 0xa9, 0x04,
	0xd3, 0xec, 0xb1, 0x09, 0xc0, 0x45, 0xbb, 0x58, 0x00, 0x95, 0x07, 0x68, 0xc5, 0xfa, 0x1b, 0xb4,
	0x7e, 0x68, 0x78, 0x16, 0x2b, 0xdf, 0x63, 0x97, 0xb8, 0x9d, 0x11, 0xfe, 0xdc, 0x81, 0x6f, 0x07,
	0x47, 0x8f, 0xee, 0x76, 0x52, 0x6c, 0x07, 0xc3, 0xb7, 0x1a, 0x3c, 0x0c, 0x20, 0x62, 0xe0, 0xdb,
	0xb8, 0x98, 0x98, 0x03, 0x3b, 0xd0, 0xf9, 0xfc, 0x56, 0xb5, 0x51, 0x9e, 0xad, 0x98, 0x57, 0xd9,
	0x0c, 0xe0, 0x00, 0xd3, 0xda, 0xb3, 0xdd, 0xd0, 0xb1, 0xfa, 0x01, 0x22, 0xdb, 0xb1, 0x82, 0x40,
	0xb8, 0x7b, 0x7f, 0x51, 0x56, 0x3d, 0x20, 0x34, 0x3d, 0x91, 0xb1, 0xe5, 0xb3, 0x15, 0x46, 0xd8,
	0x20, 0x2f, 0x80, 0xbd, 0x30, 0xb2, 0xce, 0x31, 0x5d, 0x9a, 0xe1, 0x9b, 0x48, 0x19, 0x3e, 0x1e,
	0x56, 0x27, 0x22, 0xd9, 0x66, 0x6e, 0x8c, 0xaa, 0x04, 0xca, 0x2c, 0x11, 0x57, 0x4f, 0x6a, 0x71,
	0x35, 0x8f, 0xb3, 0x79, 0xe8, 0x02, 0x62, 0x38, 0x4d, 0x5b, 0x54, 0xe3, 0xe0, 0x99, 0xdc, 0x39,
	0x20, 0x16, 0x22, 0x42, 0x6c, 0x05, 0x0f, 0xfc, 0x43, 0x0a, 0xbe, 0x1b, 0xe6, 0xff, 0x96, 0x59,
	0x6d, 0x6d, 0xe4, 0xf4, 0x7b, 0x1a, 0x8b, 0x78, 0xd8, 0x84, 0x14, 0xab, 0x26, 0x5c, 0xae, 0x4a,
	0x3a, 0xe2, 0xa9, 0x9e, 0x12, 0xf1, 0x00, 0x05, 0x70, 0xad, 0x1c, 0xb8, 0x96, 0xbb, 0xba, 0x17,
	0xd8, 0xc4, 0xba, 0xdb, 0x2b, 0x8e, 0xa1, 0x20, 0xba, 0x9d, 0x04, 0x53, 0xe9, 0x87, 0xfb, 0x30,
	0x79, 0x51, 0xfc, 0x84, 0xf4, 0xec, 0x8c, 0xba, 0x5d, 0x1b, 0xc4, 0xa4, 0x21, 0x33, 0x11, 0x1b,
	0x96, 0xd3, 0x07, 0x47, 0x90, 0xb8, 0x40, 0x24, 0xfd, 0xc0, 0xe9, 0xf7, 0xa3, 0xe4, 0x06, 0xec,
	0x7f, 0xd3, 0x0b, 0x42, 0x22, 0x38, 0xf9, 0x4c, 0x3b, 0x23, 0x08, 0x06, 0x7b, 0x82, 0xe0, 0x70,
	0xfc, 0x88, 0x4c, 0xdc, 0x9d, 0x24, 0xb2, 0xeb, 0xc7, 0x4f, 0xe9, 0xd7, 0xec, 0x02, 0x20, 0x13,
	0xa2, 0x33, 0x23, 0x85, 0x0e, 0x8e, 0x1c, 0x71, 0xa0, 0x69, 0xae, 0x27, 0x30, 0x23, 0x67, 0xbf,
	0x3d, 0xb2, 0x47, 0xc2, 0xfd, 0x47, 0xda, 0x83, 0x5c, 0x78, 0xbe, 0x13, 0x9e, 0x10, 0xa1, 0x6b,
	0x28, 0x8e, 0x04, 0x6f, 0xfb, 0x62, 0x2d, 0xb3, 0x84, 0xe6, 0x53, 0xb0, 0x11, 0xd8, 0xfc, 0x2d,
	0x6f, 0xdf, 0x78, 0x8d, 0x55, 0xf1, 0x00, 0x09, 0x47, 0x75, 0x21, 0xbd, 0x4a, 0x25, 0xb6, 0x4b,
	0x33, 0xb7, 0x68, 0xb5, 0x28, 0xf5, 0xab, 0x44, 0xd6, 0x3d, 0xef, 0xb1, 0xed, 0x8a, 0xb9, 0x5f,
	0x60, 0x06, 0xa1, 0x7d, 0xdf, 0x0e, 0xef, 0x79, 0x87, 0x52, 0x63, 0xc1, 0x4e, 0xee, 0x3b, 0x6e,
	0x14, 0x96, 0xfd, 0x5d, 0x85, 0xcd, 0x12, 0x94, 0x9a, 0x44, 0x79, 0x91, 0xd5, 0x69, 0xb7, 0xbd,
	0xa2, 0xac, 0x1a, 0x42, 0xad, 0x76, 0x43, 0x08, 0xe8, 0x38, 0x51, 0xf2, 0xd3, 0x10, 0x24, 0x40,
	0xdc, 0x7d, 0xcf, 0x4f, 0x8f, 0x90, 0x5c, 0xd8, 0x08, 0x58, 0x2d, 0x9e, 0x13, 0xe5, 0x05, 0xa0,
	0x6a, 0xc5, 0x50, 0x42, 0x4c, 0xea, 0xc5, 0x49, 0x14, 0x3a, 0x5a, 0x13, 0x05, 0xb9, 0xcc, 0x97,
	0x15, 0x3e, 0x34, 0x8a, 0x1d, 0x41, 0xca, 0x01, 0x35, 0xc7, 0xcd, 0x01, 0x7d, 0x61, 0x49, 0x19,
	0x38, 0xd7, 0x91, 0x30, 0xe5, 0x6b, 0x0f, 0xf3, 0x87, 0x65, 0x01, 0xb7, 0x67, 0x05, 0x8f, 0x95,
	0x74, 0x4c, 0x15, 0xb4, 0x08, 0x57, 0x3d, 0xc2, 0xd2, 0x9c, 0x2a, 0xa7, 0x3b, 0x96, 0x0f, 0x26,
	0x40, 0xc8, 0x69, 0x15, 0xe5, 0xeb, 0x9e, 0xb5, 0x6f, 0xf7, 0x85, 0xf2, 0x4e, 0xe8, 0xa4, 0xda,
	0x59, 0x74, 0x52, 0x7d, 0x1c, 0x9d, 0xf4, 0x34, 0xaa, 0x06, 0x21, 0x1e, 0x3b, 0xc3, 0x61, 0xa4,
	0x6b, 0x60, 0x33, 0x1f, 0x5a, 0xbe, 0xeb, 0xb8, 0x87, 0x9c, 0xe8, 0x0d, 0xb3, 0xc3, 0xe6, 0x23,
	0x22, 0xa9, 0x07, 0xe4, 0xa9, 0x02, 0xf0, 0x3f, 0x2d, 0x0b, 0xdd, 0xc2, 0x2d, 0x50, 0x72, 0xd7,
	0xa5, 0x71, 0x76, 0x5d, 0x1e, 0x57, 0x13, 0x57, 0x72, 0x01, 0xa5, 0x5e, 0x8d, 0x92, 0x67, 0x92,
	0x58, 0x35, 0xa9, 0x86, 0xd5, 0x13, 0xa4, 0x12, 0x6f, 0x42, 0xd3, 0xd3, 0x8d, 0x94, 0x46, 0x6c,
	0x66, 0x6b, 0x44, 0x26, 0xf3, 0x79, 0x1b, 0x70, 0x80, 0x3b, 0x5d, 0x4c, 0xda, 0x23, 0x95, 0xcb,
	0x38, 0x16, 0xdc, 0x12, 0xde, 0x32, 0x45, 0x2d, 0x20, 0x90, 0xa0, 0xc9, 0xda, 0xb6, 0x1b, 0x20,
	0x3e, 0x54, 0xeb, 0x65, 0xd3, 0x17, 0x02, 0x2b, 0xbc, 0xbe, 0x3a, 0xfd, 0x90, 0x1e, 0x93, 0x91,
	0x96, 0xd2, 0x67, 0xe1, 0x3b, 0xfd, 0x22, 0x9b, 0xe1, 0xd3, 0x44, 0xc9, 0x86, 0x53, 0x92, 0x9c,
	0x8a, 0x9a, 0xae, 0xa8, 0x6a, 0x9a, 0x93, 0x79, 0x99, 0xd5, 0x05, 0x2d, 0x6a, 0xa7, 0x58, 0x2a,
	0x9e, 0xb2, 0x7b, 0x2c, 0xa7, 0x8f, 0xa2, 0xfc, 0xe8, 0x70, 0x8e, 0x63, 0x44, 0x6e, 0xb2, 0xea,
	0x96, 0x7b, 0xe0, 0x65, 0x7a, 0xd8, 0x8a, 0x00, 0x8a, 0xc9, 0x46, 0x6c, 0x81, 0x4f, 0x46, 0x01,
	0x98, 0x94, 0xfa, 0xe0, 0xac, 0x93, 0x2e, 0xab, 0xc1, 0xc3, 0xf5, 0x34, 0xa8, 0x76, 0x94, 0xcc,
	0xaf, 0x0b, 0x31, 0x91, 0xed, 0x60, 0x26, 0x59, 0x3c, 0xbb, 0x60, 0xef, 0x42, 0x36, 0x1e, 0xd3,
	0x61, 0x17, 0x54, 0xfe, 0x7c, 0xae, 0x05, 0xbf, 0xc4, 0x6a, 0x7c, 0xaa, 0x72, 0xe1, 0x54, 0x7d,
	0x61, 0x4d, 0x05, 0x2f, 0xb0, 0x0d, 0x66, 0x7a, 0x15, 0xfd, 0xf6, 0xe0, 0xb1, 0x98, 0x28, 0xe9,
	0x31, 0x63, 0x87, 0x32, 0xcf, 0xeb, 0x09, 0x6e, 0x5c, 0x4a, 0x81, 0x26, 0x98, 0x31, 0x90, 0xb3,
	0x81, 0xf1, 0x26, 0xca, 0xa0, 0x01, 0x3f, 0xcb, 0x6c, 0x37, 0x55, 0x36, 0x2c, 0xa5, 0xf7, 0x94,
	0x70, 0x0a, 0xcc, 0x8b, 0x92, 0x8e, 0x6d, 0xfb, 0xfb, 0x68, 0xf8, 0xb7, 0xed, 0x27, 0xc0, 0x20,
	0xb3, 0xcb, 0x9a, 0xeb, 0x03, 0x38, 0xf6, 0xab, 0xbd, 0x9e, 0x8f, 0x8a, 0x9d, 0x7e, 0xc4, 0x79,
	0xae, 0x47, 0xb6, 0xef, 0x1c, 0x38, 0x76, 0x4f, 0x38, 0x45, 0xdc, 0x59, 0x1e, 0x58, 0xfe, 0x09,
	0xb7, 0xf5, 0xd8, 0xf0, 0xfe, 0x08, 0x74, 0x8a, 0xb4, 0xe9, 0xe8, 0xa6, 0xac, 0xf5, 0xad, 0xee,
	0xe3, 0x3e, 0xf0, 0x59, 0x9a, 0x70, 0xf3, 0x26, 0x63, 0xb0, 0x92, 0x75, 0x37, 0xf4, 0x1d, 0x9b,
	0xbb, 0x27, 0xd6, 0x93, 0x28, 0x8b, 0x78, 0x1e, 0x95, 0x1e, 0xf5, 0x10, 0x7b, 0x9a, 0xe6, 0x97,
	0x61, 0x5f, 0xfe, 0x21, 0x04, 0xbe, 0x55, 0x8a, 0x54, 0x38, 0x25, 0xe6, 0x52, 0x91, 0x4a, 0x2a,
	0x06, 0xba, 0x08, 0xa3, 0x50, 0xbc, 0xee, 0xdb, 0x83, 0x7d, 0x25, 0x30, 0x7d, 0x2a, 0x45, 0x0e,
	0x1a, 0x19, 0xb0, 0x92, 0xa1, 0x9d, 0xa4, 0x65, 0x89, 0x45, 0x63, 0x3e, 0x50, 0x26, 0x15, 0x81,
	0x93, 0x73, 0xd0, 0x13, 0x24, 0xe6, 0x06, 0x35, 0x1d, 0x81, 0x4f, 0xae, 0xcc, 0x6b, 0x09, 0xc6,
	0x43, 0x85, 0x8d, 0xb7, 0x54, 0x36, 0x9a, 0x3a, 0x60, 0x7a, 0x43, 0x98, 0xe5, 0xc7, 0xfd, 0xcb,
	0x2c, 0x3f, 0xfe, 0x9d, 0x9d, 0xe5, 0xc7, 0x1e, 0xb3, 0x05, 0x61, 0x50, 0x80, 0x0a, 0x7a, 0xe4,
	0x86, 0x48, 0x7a, 0xfa, 0x43, 0x5c, 0xcb, 0x1c, 0x81, 0x09, 0x80, 0xc1, 0x9e, 0x6b, 0xbc, 0xcd,
	0x18, 0xff, 0x4b, 0x71, 0x5f, 0x93, 0xf2, 0x1b, 0x77, 0x6b, 0x3e, 0x36, 0x48, 0xc9, 0xc6, 0xa8,
	0xdf, 0xa7, 0xd0, 0x2e, 0xba, 0xcf, 0x59, 0x85, 0x80, 0xca, 0xf2, 0xe3, 0xcb, 0xee, 0xb7, 0x54,
	0xfc, 0xba, 0x9c, 0xa1, 0x3f, 0xe1, 0x61, 0x36, 0xb6, 0xac, 0xd2, 0xb6, 0x42, 0x4b, 0xbc, 0xcb,
	0x1a, 0x52, 0xec, 0xcf, 0x76, 0xe6, 0x55, 0x4f, 0xe8, 0xf7, 0x4a, 0x60, 0x6c, 0xa2, 0xf3, 0xf7,
	0x4c, 0xad, 0xb1, 0x62, 0x56, 0x2b, 0xba, 0x19, 0xad, 0xea, 0x3e, 0x48, 0x2d, 0xe5, 0x83, 0x90,
	0xe9, 0x35, 0xff, 0xb3, 0xc4, 0x65, 0x5d, 0x6e, 0x3d, 0x0a, 0x9f, 0x55, 0xb2, 0xc8, 0xf0, 0xb9,
	0x2a, 0xf3, 0x57, 0x14, 0x4d, 0x5a, 0xae, 0xf3, 0xa9, 0x45, 0xee, 0x26, 0x47, 0x9e, 0xa0, 0x7d,
	0x9c, 0x60, 0xf6, 0xba, 0x96, 0x12, 0x2c, 0xd3, 0x45, 0xda, 0x60, 0x68, 0xb9, 0x27, 0x22, 0x56,
	0xd6, 0xae, 0xab, 0x9b, 0x72, 0x5c, 0xdb, 0x09, 0x30, 0x2f, 0x2f, 0xbd, 0xa7, 0x1b, 0x78, 0x07,
	0x76, 0x88, 0x27, 0xdb, 0x27, 0xb2, 0x4c, 0xe6, 0x92, 0x05, 0xd6, 0xbe, 0xda, 0x1b, 0xc0, 0xda,
	0xa3, 0xa8, 0xf9, 0x43, 0xf0, 0x1b, 0x6c, 0x7e, 0x39, 0x6d, 0xbe, 0xcc, 0x25, 0x58, 0xca, 0x02,
	0xdf, 0x65, 0xc6, 0xc1, 0xfa, 0xd7, 0x12, 0x9b, 0x25, 0xf1, 0x56, 0x1d, 0xb3, 0xe8, 0x6a, 0xb7,
	0x34, 0x86, 0xb3, 0x5e, 0x1e, 0xd7, 0x59, 0xaf, 0x8c, 0xef, 0xac, 0x57, 0xcf, 0x9a, 0xde, 0x85,
	0x0d, 0xa1, 0xd3, 0x55, 0xc9, 0xad, 0x7a, 0x38, 0x66, 0x4c, 0x2a, 0x10, 0x32, 0x6d, 0x75, 0x7e,
	0xe2, 0x33, 0x8d, 0x80, 0x24, 0x9c, 0x10, 0xf3, 0xa7, 0xca, 0xb4, 0x81, 0x61, 0x8e, 0x94, 0xbf,
	0x34, 0xcc, 0x51, 0x43, 0xb6, 0x61, 0x8e, 0xba, 0xcd, 0x57, 0x49, 0x35, 0xd2, 0xb0, 0xab, 0xac,
	0x8a, 0xeb, 0x17, 0x03, 0x66, 0x75, 0x1d, 0x06, 0xf3, 0xcc, 0xc8, 0x08, 0xa1, 0xdb, 0x25, 0x45,
	0x94, 0x10, 0xf4, 0xe7, 0xd8, 0xfc, 0x1e, 0x50, 0xc2, 0xf3, 0xc1, 0xae, 0xa8, 0x31, 0x6e, 0x59,
	0xc6, 0xb8, 0x98, 0x74, 0xfa, 0xc4, 0xf3, 0x7b, 0xe0, 0xc2, 0x81, 0xad, 0xc4, 0x3e, 0x14, 0x1b,
	0x0e, 0xc4, 0x63, 0xdc, 0x63, 0x36, 0xbf, 0x63, 0xbb, 0x3d, 0x38, 0x53, 0x09, 0x58, 0x3c, 0x34,
	0xf7, 0x1c, 0xf7, 0xb1, 0x10, 0xae, 0x65, 0x39, 0x28, 0xcb, 0x66, 0x66, 0x4c, 0x32, 0x27, 0x8c,
	0x63, 0x07, 0xa2, 0x1f, 0x71, 0xbc, 0x23, 0x71, 0xe5, 0xe5, 0x33, 0x0f, 0xd8, 0xe4, 0xb6, 0xfd,
	0x89, 0x1c, 0xca, 0x63, 0x25, 0xfe, 0xf7, 0xe7, 0x9b, 0xd2, 0xdc, 0x62, 0x0c, 0x10, 0x4a, 0x32,
	0x69, 0x87, 0x23, 0xd2, 0x9b, 0xd1, 0x65, 0x4f, 0x34, 0x5b, 0x45, 0x3d, 0x3d, 0x94, 0xaf, 0x30,
	0xef, 0xb0, 0x59, 0x1a, 0xac, 0x66, 0xf0, 0x34, 0x84, 0x2a, 0x06, 0x4e, 0xed, 0x9b, 0x6c, 0x86,
	0x67, 0xf1, 0x56, 0x47, 0xe1, 0xd1, 0x5d, 0xaf, 0x67, 0x23, 0x09, 0xf1, 0xff, 0x62, 0x84, 0x0c,
	0x2a, 0x38, 0xf4, 0x8f, 0x4a, 0xcc, 0x50, 0x38, 0xb6, 0x8b, 0xae, 0x05, 0xc8, 0xc3, 0xbb, 0x98,
	0x84, 0xe6, 0x1b, 0xa5, 0xbc, 0x57, 0x62, 0x8e, 0xc9, 0x95, 0xe7, 0x93, 0xe2, 0xa9, 0xad, 0x71,
	0xf3, 0x9c, 0xf1, 0xa6, 0xbe, 0x08, 0x11, 0xe5, 0x24, 0xdd, 0xfa, 0x24, 0x08, 0x0c, 0xc3, 0xdc,
	0x5c, 0xd7, 0x1b, 0xda, 0x8b, 0x73, 0x54, 0xd0, 0x01, 0x1e, 0x8f, 0x05, 0x9d, 0x10, 0xb0, 0x70,
	0x0d, 0xf9, 0x31, 0x0c, 0x73, 0x43, 0xf3, 0x6f, 0x4b, 0xec, 0x42, 0x62, 0xcd, 0xa2, 0xd0, 0x48,
	0x4b, 0xb0, 0x94, 0xa2, 0xd2, 0x04, 0xfc, 0x49, 0xa5, 0x18, 0x65, 0x99, 0xab, 0x5c, 0x7f, 0x32,
	0x04, 0xc5, 0x11, 0x6c, 0xb9, 0x1d, 0x30, 0x96, 0x64, 0xa7, 0xb0, 0x55, 0xe4, 0x5d, 0xf9, 0xf0,
	0x6a, 0x54, 0xa4, 0x45, 0x2b, 0xc2, 0xd3, 0x1f, 0xb1, 0xa7, 0x4e, 0x23, 0x2e, 0xb3, 0x39, 0xb1,
	0x03, 0x65, 0xd6, 0x09, 0x11, 0x51, 0x33, 0xde, 0x45, 0x0e, 0x50, 0x23, 0xc3, 0x1a, 0xc7, 0xdd,
	0xe6, 0xa7, 0x2a, 0xb0, 0x5a, 0x75, 0x91, 0x67, 0x40, 0x2a, 0x49, 0x59, 0xaa, 0xa6, 0x8c, 0x44,
	0x4d, 0x37, 0x12, 0xf5, 0xb4, 0x59, 0xa7, 0x85, 0x9a, 0xdf, 0x65, 0x0d, 0xa4, 0x3f, 0x3a, 0xbd,
	0x09, 0xcd, 0xad, 0x1d, 0x93, 0x58, 0xff, 0xd7, 0xe4, 0x21, 0xe2, 0xd6, 0x81, 0x47, 0x9e, 0x40,
	0xbb, 0x2d, 0x17, 0x6c, 0x4a, 0xd7, 0x1b, 0x6c, 0x5a, 0xc1, 0x91, 0xc0, 0xfd, 0x11, 0x9b, 0x5b,
	0x7f, 0x02, 0xad, 0xae, 0xd5, 0x27, 0xda, 0x90, 0xb5, 0x98, 0x67, 0x95, 0x91, 0xd3, 0x13, 0x25,
	0x64, 0x13, 0x3f, 0xff, 0x6c, 0x09, 0xe7, 0xc4, 0x9d, 0x1d, 0x45, 0x42, 0x69, 0x2c, 0xb1, 0x66,
	0xb7, 0xef, 0x80, 0x34, 0x7d, 0xec, 0x88, 0x73, 0xb1, 0x36, 0x05, 0x90, 0x8d, 0xbb, 0xd4, 0xb8,
	0xd5, 0x36, 0x7f, 0xa3, 0x04, 0x7a, 0x4f, 0x45, 0x3d, 0x16, 0x5a, 0x58, 0x74, 0x48, 0x3c, 0x8a,
	0xe8, 0x17, 0x10, 0x6b, 0xab, 0xe9, 0x49, 0x6b, 0xe9, 0x49, 0x8d, 0x2b, 0x6c, 0x02, 0x3c, 0xee,
	0x8f, 0x71, 0x1a, 0xe2, 0xff, 0x1a, 0x83, 0xee, 0x3a, 0x2c, 0x03, 0x66, 0x42, 0x07, 0xa5, 0xd2,
	0xb6, 0x0f, 0xc0, 0x33, 0xc1, 0xff, 0x09, 0xbd, 0xcf, 0x96, 0x39, 0xaf, 0xa1, 0x45, 0xb3, 0x29,
	0x57, 0xd9, 0x44, 0xdb, 0xeb, 0x62, 0xa5, 0x94, 0x38, 0x51, 0xd3, 0x91, 0x09, 0xc6, 0x46, 0x94,
	0x9f, 0x8d, 0x41, 0x08, 0x61, 0x2f, 0xf9, 0x18, 0x15, 0x21, 0x3f, 0x11, 0xb6, 0x0d, 0xcf, 0x1f,
	0x58, 0xb2, 0x1b, 0xd9, 0x4a, 0xde, 0x10, 0xe8, 0x49, 0xbe, 0x99, 0x69, 0xee, 0x92, 0xf7, 0xa8,
	0x01, 0xb7, 0x32, 0x6d, 0xee, 0x53, 0x26, 0x1e, 0x02, 0x0a, 0x69, 0x84, 0xaf, 0xc3, 0x42, 0xbd,
	0x6e, 0x61, 0xee, 0x70, 0x99, 0xcd, 0xa2, 0xfc, 0x8c, 0x42, 0x1b, 0x11, 0xed, 0x5a, 0xee, 0x61,
	0x61, 0x16, 0xd1, 0xfc, 0x95, 0x3a, 0x9b, 0x81, 0x49, 0xbe, 0x90, 0x4a, 0x2f, 0xd8, 0xe3, 0xda,
	0x49, 0x68, 0xd3, 0x3e, 0x89, 0x1e, 0xb4, 0x47, 0x6c, 0x82, 0x7d, 0x8a, 0x4d, 0x23, 0x51, 0xed,
	0x83, 0x0f, 0xec, 0x13, 0x6e, 0xab, 0x91, 0xa8, 0x11, 0xc5, 0xa0, 0xd5, 0x10, 0xc5, 0x35, 0xbb,
	0xf6, 0x31, 0xba, 0x6d, 0x5a, 0xc5, 0x58, 0x34, 0x17, 0xaf, 0x1d, 0xa3, 0xac, 0xe2, 0x43, 0xd7,
	0x09, 0x49, 0x6f, 0x4c, 0x14, 0x3b, 0x2a, 0x08, 0x77, 0x5a, 0xe6, 0x91, 0x6e, 0x88, 0x9b, 0xc5,
	0x64, 0xc0, 0x9c, 0x4b, 0x00, 0x9e, 0x5a, 0x25, 0x17, 0x08, 0x94, 0x3b, 0x02, 0x21, 0xb2, 0x1d,
	0xdf, 0x3e, 0x70, 0x9e, 0xf0, 0x9c, 0x7b, 0x0e, 0xf4, 0xab, 0xac, 0xf6, 0x81, 0xe3, 0xf6, 0x02,
	0xf0, 0xe1, 0xc6, 0xd8, 0x2d, 0xe8, 0x44, 0x0f, 0x5d, 0x6a, 0xee, 0xe2, 0xe5, 0xe7, 0x5a, 0xb7,
	0x3d, 0xb7, 0x0f, 0x8a, 0xa6, 0xcf, 0xcb, 0x12, 0x73, 0xa7, 0x9e, 0x14, 0xf7, 0xb9, 0x7b, 0x60,
	0x4f, 0xf8, 0x8d, 0x49, 0x0e, 0xa8, 0x90, 0xc4, 0xd9, 0xe2, 0xfc, 0xf4, 0xc6, 0xe8, 0xd3, 0x4f,
	0x4f, 0xa8, 0x52, 0xb1, 0x71, 0x8a, 0xc7, 0x68, 0x8c, 0xeb, 0x31, 0x5e, 0x18, 0xdf, 0x63, 0x9c,
	0x3f, 0x93, 0x57, 0xf6, 0x37, 0x60, 0x54, 0xc5, 0x41, 0xc0, 0xaa, 0x26, 0xe5, 0x30, 0xc4, 0x69,
	0xa9, 0xd3, 0xa4, 0xa0, 0x5c, 0x20, 0x05, 0x4f, 0x75, 0xd3, 0xae, 0x66, 0xcb, 0x8b, 0x2a, 0x16,
	0x3e, 0xa4, 0xd3, 0x34, 0x4e, 0xd1, 0x20, 0xb6, 0x44, 0x47, 0xa5, 0x22, 0x2d, 0x15, 0x1d, 0x8a,
	0xaa, 0xfc, 0x45, 0xe2, 0x4f, 0x5a, 0xd5, 0xfc, 0x7f, 0xc0, 0x03, 0xa0, 0x0a, 0xe9, 0x22, 0x0c,
	0xb2, 0x63, 0x7d, 0x99, 0x0c, 0xb2, 0xc5, 0xec, 0xc2, 0x4d, 0x7e, 0x45, 0x0d, 0xb2, 0x5b, 0x3a,
	0x60, 0xac, 0xd8, 0x20, 0x24, 0x9e, 0x10, 0xb4, 0x47, 0xaf, 0x16, 0x67, 0xca, 0xf4, 0x6a, 0x51,
	0x59, 0xbf, 0x93, 0x2c, 0x70, 0x16, 0xc8, 0x2f, 0xa7, 0x08, 0x99, 0x93, 0x78, 0x3c, 0x24, 0x75,
	0x17, 0xc4, 0x6c, 0x1e, 0x7f, 0x37, 0x05, 0x99, 0x9f, 0xb4, 0xe0, 0x98, 0x07, 0x6c, 0x62, 0x57,
	0x6c, 0x69, 0x11, 0x59, 0x11, 0x6d, 0x49, 0x1a, 0x18, 0x68, 0x7a, 0x16, 0x99, 0xd4, 0x1f, 0xb0,
	0x56, 0x3c, 0xbb, 0x74, 0x26, 0x02, 0x25, 0x6c, 0x8b, 0x6b, 0xcf, 0xbe, 0x08, 0xd1, 0x34, 0x3f,
	0x61, 0x0b, 0x0a, 0x41, 0x95, 0x05, 0x8c, 0x4f, 0xd8, 0x2f, 0xab, 0x84, 0x7d, 0x25, 0x87, 0xb0,
	0xfa, 0xd6, 0xc0, 0x03, 0x33, 0xe4, 0xc4, 0xeb, 0x4f, 0x20, 0xfa, 0xed, 0xdb, 0x67, 0x9a, 0xf4,
	0xa9, 0x42, 0xb8, 0xdf, 0x82, 0x10, 0x59, 0x5d, 0x13, 0xb1, 0xf9, 0x55, 0x69, 0xaa, 0x0e, 0xb2,
	0x4b, 0xfd, 0x60, 0x7e, 0xd1, 0xff, 0x0c, 0xf8, 0xce, 0x33, 0xf9, 0xa1, 0xd5, 0xe7, 0xec, 0xe5,
	0x69, 0x9b, 0xff, 0x8f, 0x05, 0xeb, 0xd1, 0x24, 0xaa, 0x06, 0x68, 0xc6, 0x49, 0xa8, 0xc8, 0x55,
	0xe4, 0xf7, 0x02, 0x15, 0xba, 0x17, 0x78, 0x59, 0xaa, 0xb0, 0x6a, 0xf6, 0xc2, 0xb1, 0x13, 0x70,
	0x9a, 0x5f, 0xa5, 0x19, 0xc4, 0xaf, 0x48, 0x47, 0x8c, 0x31, 0x83, 0xf9, 0x87, 0x25, 0x56, 0x6b,
	0xdb, 0xfd, 0xd0, 0xc2, 0xec, 0x39, 0xd5, 0x76, 0x8d, 0x57, 0x8c, 0x7b, 0x53, 0x54, 0x8b, 0x95,
	0xc7, 0x82, 0x5e, 0x62, 0x0c, 0x71, 0x8b, 0xe2, 0x22, 0x2e, 0xc9, 0x89, 0x3a, 0x2d, 0x00, 0x40,
	0x74, 0x4a, 0xc1, 0x52, 0x12, 0x00, 0xb3, 0x1f, 0x0d, 0xdc, 0x5f, 0xdb, 0x39, 0x38, 0x00, 0x6f,
	0x2a, 0xfa, 0x5b, 0x2c, 0x77, 0x66, 0x99, 0x5e, 0x05, 0xc9, 0x56, 0x8d, 0x29, 0xd7, 0xd9, 0xb4,
	0xec, 0xd9, 0x1c, 0xb9, 0x51, 0xea, 0x9b, 0xf1, 0x41, 0xd8, 0x64, 0x5c, 0xc3, 0xfb, 0x1c, 0x7b,
	0x6b, 0x10, 0xd5, 0x0a, 0xae, 0xcd, 0xc0, 0x50, 0x16, 0x9f, 0x47, 0x40, 0xd2, 0xdc, 0x01, 0x07,
	0x98, 0x83, 0x54, 0x33, 0x41, 0x96, 0x78, 0x29, 0x77, 0x20, 0xae, 0x3b, 0x04, 0x7e, 0x6c, 0x12,
	0x74, 0xb8, 0x46, 0x0b, 0xa7, 0x8c, 0x91, 0xb8, 0xaa, 0xd5, 0x50, 0x60, 0x00, 0x43, 0xec, 0x20,
	0xb6, 0x1b, 0x37, 0xf8, 0xe5, 0x11, 0x2e, 0x5c, 0x0a, 0x6f, 0x32, 0x01, 0x12, 0x91, 0xe4, 0xba,
	0x60, 0x63, 0x94, 0x9d, 0x4b, 0x4a, 0x0a, 0x32, 0x38, 0x5a, 0x5d, 0x25, 0x7b, 0x75, 0xe6, 0x77,
	0xb0, 0x96, 0x84, 0xcf, 0x8d, 0x55, 0x44, 0xd2, 0x1b, 0x2b, 0x72, 0x38, 0x55, 0xcf, 0xae, 0xc0,
	0xe7, 0xc4, 0x62, 0xb7, 0x8b, 0x84, 0x1b, 0x8f, 0x24, 0xed, 0x4d, 0xb9, 0x7b, 0xe7, 0xf3, 0x9d,
	0x56, 0x54, 0xa8, 0x2c, 0x2d, 0xf3, 0x3a, 0x49, 0xe9, 0xd7, 0xd8, 0x0f, 0x53, 0x6c, 0x1d, 0xba,
	0x28, 0xf3, 0xf5, 0x7c, 0x75, 0x0b, 0x26, 0xa8, 0x49, 0x28, 0xc8, 0x4c, 0x7f, 0x81, 0x87, 0xc1,
	0x74, 0xd9, 0x1c, 0x4d, 0x14, 0x28, 0xb4, 0x00, 0x4e, 0x97, 0xdb, 0x41, 0x66, 0x2e, 0x37, 0x5a,
	0xd4, 0xe9, 0x29, 0xf2, 0x4c, 0x0a, 0x9b, 0xbf, 0x5a, 0xe2, 0xa5, 0xa4, 0x7b, 0xbe, 0x6d, 0x2b,
	0x51, 0x0b, 0x85, 0x24, 0x10, 0x69, 0xba, 0x61, 0xb0, 0x1a, 0xf0, 0xf8, 0xa7, 0xb0, 0x14, 0x01,
	0x94, 0x23, 0x8c, 0x46, 0xcc, 0x52, 0x39, 0xd7, 0xb2, 0xf2, 0x10, 0x09, 0x10, 0x4d, 0x3f, 0xff,
	0xb8, 0xac, 0xe3, 0x30, 0xde, 0xe2, 0x12, 0xce, 0x23, 0xa2, 0xac, 0xed, 0x47, 0xbd, 0x1a, 0x53,
	0x6f, 0x30, 0xb6, 0xee, 0x86, 0xe0, 0x80, 0x22, 0x40, 0x61, 0x45, 0xc6, 0x6d, 0x66, 0x80, 0x3f,
	0x6e, 0xb9, 0x3d, 0xf1, 0x5e, 0x02, 0x23, 0x30, 0xa1, 0x9a, 0xf3, 0x5d, 0x5b, 0xcc, 0xe2, 0x73,
	0xc0, 0x6a, 0x71, 0x1d, 0xc7, 0xae, 0xdd, 0x1d, 0xf9, 0x01, 0x56, 0x85, 0x14, 0x55, 0x68, 0xbc,
	0xcd, 0xae, 0x70, 0x40, 0xbb, 0x03, 0x74, 0xee, 0xdb, 0x9d, 0xd1, 0xfe, 0x81, 0x87, 0x77, 0xc5,
	0xf7, 0x1c, 0x59, 0x6e, 0x99, 0x97, 0x0f, 0xdd, 0xe1, 0x45, 0x8c, 0xc8, 0xbd, 0x8e, 0x6d, 0xf9,
	0xdd, 0xa3, 0x98, 0x74, 0xd3, 0x89, 0x86, 0x28, 0x7b, 0x8f, 0x6a, 0x33, 0xd1, 0x93, 0xf2, 0x4d,
	0xe6, 0x93, 0x18, 0xc1, 0x96, 0x8d, 0xfa, 0xa1, 0xf1, 0x26, 0x9b, 0x52, 0x7f, 0x47, 0x97, 0x4d,
	0x31, 0x3e, 0xde, 0xa1, 0x71, 0xe2, 0x16, 0xba, 0x54, 0x24, 0xe4, 0x63, 0x1f, 0x80, 0xe9, 0x84,
	0x3c, 0x02, 0x86, 0x1a, 0xde, 0x7a, 0x9d, 0x88, 0x19, 0x93, 0x2e, 0x29, 0x82, 0x51, 0xef, 0x78,
	0x3e, 0x5f, 0x5a, 0xd2, 0xcd, 0x21, 0x7a, 0x05, 0x49, 0x0a, 0x1a, 0xaf, 0xc7, 0x15, 0x9a, 0xa7,
	0x9f, 0xef, 0x82, 0x23, 0x97, 0xc9, 0x1a, 0xf3, 0x1d, 0xfe, 0x5c, 0x02, 0x3b, 0xa2, 0x3c, 0xf6,
	0xf8, 0xf3, 0x61, 0x96, 0x57, 0x1d, 0x2e, 0xd8, 0x33, 0x2d, 0x9d, 0x01, 0xfe, 0x90, 0xef, 0x07,
	0xec, 0xc2, 0xa3, 0xbb, 0x1d, 0x95, 0x2f, 0xe4, 0xee, 0xdc, 0x90, 0x52, 0xc1, 0xdb, 0xe2, 0xcb,
	0x30, 0x9d, 0x8b, 0x4f, 0xeb, 0xb2, 0xff, 0x4e, 0x89, 0x35, 0x23, 0xde, 0x00, 0xb2, 0x19, 0x50,
	0x98, 0x4e, 0x37, 0x6a, 0x11, 0x5b, 0x4d, 0x6a, 0x87, 0x24, 0xc8, 0x5a, 0x23, 0x92, 0xa1, 0x3b,
	0xaa, 0x1a, 0x28, 0x17, 0xaa, 0x81, 0x78, 0x90, 0x28, 0x5b, 0x46, 0x0d, 0x26, 0xf4, 0x17, 0xbf,
	0x5f, 0xfb, 0xdd, 0x92, 0xbe, 0x98, 0x28, 0xdd, 0xc7, 0x5d, 0xa2, 0x1b, 0xe2, 0x39, 0x19, 0x7f,
	0xb6, 0x9a, 0x23, 0x6e, 0x54, 0xa4, 0x9f, 0xae, 0x4b, 0xa3, 0x16, 0x3e, 0x29, 0x9d, 0xf8, 0x29,
	0x10, 0xc6, 0xe8, 0xce, 0xb6, 0x4e, 0xb4, 0x2e, 0xda, 0xb3, 0xb9, 0xcd, 0xa6, 0x13, 0x12, 0xad,
	0x1e, 0x9f, 0xf1, 0xa4, 0x51, 0xba, 0x77, 0x3c, 0xeb, 0xfc, 0xc7, 0x25, 0x85, 0x74, 0x54, 0x58,
	0x16, 0xe5, 0xaf, 0x10, 0x5d, 0x25, 0x47, 0x21, 0xbd, 0x14, 0x67, 0xb5, 0xca, 0x05, 0x60, 0x12,
	0x1f, 0x66, 0x87, 0x88, 0x00, 0xc5, 0xf8, 0x08, 0xac, 0x9a, 0x0f, 0x06, 0xae, 0x30, 0x45, 0x07,
	0x22, 0x3b, 0xbc, 0xe5, 0xf6, 0xec, 0x27, 0xa9, 0x22, 0x93, 0x2b, 0x58, 0x7a, 0x4c, 0xfd, 0xaa,
	0x2f, 0x2f, 0x2e, 0xdd, 0xf1, 0x10, 0x78, 0x40, 0x1c, 0x71, 0x03, 0x31, 0xab, 0x47, 0xe0, 0x66,
	0x9b, 0x5d, 0x5c, 0x0d, 0x4e, 0xdc, 0xae, 0x3a, 0x45, 0x46, 0xc1, 0xfe, 0x0c, 0xab, 0x77, 0x88,
	0xca, 0x71, 0x42, 0x53, 0xc1, 0x6b, 0x7e, 0xc4, 0x66, 0x56, 0x29, 0x5d, 0x1e, 0x1c, 0x39, 0x43,
	0xca, 0xe8, 0xde, 0x66, 0x33, 0xf7, 0x2c, 0x59, 0xeb, 0xdd, 0xc6, 0x0a, 0xd9, 0xd2, 0x29, 0xd5,
	0x5d, 0xf3, 0x70, 0xbe, 0xa2, 0x11, 0xd1, 0xab, 0x40, 0x97, 0x42, 0x76, 0x8e, 0x5c, 0xbf, 0xfb,
	0x4d, 0x24, 0x95, 0xf9, 0xba, 0xde, 0xa3, 0x64, 0x63, 0xbc, 0x16, 0xe1, 0xbc, 0xa5, 0xa2, 0xf6,
	0x18, 0x42, 0x3b, 0xa6, 0x9f, 0x6a, 0x08, 0xd0, 0x8e, 0x27, 0xb7, 0x96, 0x79, 0x52, 0x93, 0x20,
	0x9a, 0xc6, 0x87, 0x65, 0x23, 0xa7, 0x85, 0x11, 0x35, 0x2e, 0xb1, 0xf3, 0xf4, 0x73, 0xc7, 0xf7,
	0x30, 0xed, 0x25, 0xdf, 0x28, 0x96, 0xb0, 0x0c, 0x41, 0x44, 0x8a, 0x02, 0xdd, 0x33, 0x29, 0x43,
	0x18, 0xa0, 0xff, 0xc4, 0x23, 0xcc, 0x08, 0xed, 0xf8, 0x01, 0x66, 0xa1, 0xfb, 0x94, 0xb1, 0x56,
	0xbc, 0x17, 0x8c, 0x08, 0x28, 0xef, 0x05, 0x63, 0x8a, 0x66, 0xde, 0x0b, 0x46, 0xdd, 0x26, 0x9c,
	0x9f, 0xbb, 0x47, 0x36, 0xaf, 0x00, 0x41, 0x09, 0xdc, 0xf3, 0x7a, 0xca, 0xf3, 0xbd, 0xb6, 0x27,
	0x8e, 0x5f, 0xcd, 0x5c, 0xe7, 0xa7, 0x98, 0x67, 0xe0, 0x93, 0x01, 0xdc, 0x6b, 0xd2, 0x3a, 0x96,
	0x4f, 0xd5, 0xa8, 0xe6, 0x73, 0x68, 0xc2, 0xfd, 0x63, 0xdb, 0x17, 0x8f, 0x4b, 0xa7, 0x44, 0x11,
	0x0e, 0xbf, 0x18, 0x7c, 0x57, 0xf6, 0x8a, 0x2a, 0xdf, 0xf3, 0x6c, 0x42, 0x3c, 0x68, 0x8b, 0x9f,
	0xfd, 0xad, 0x0e, 0x87, 0xb1, 0xf4, 0x01, 0xa3, 0xb7, 0xda, 0x1f, 0xd8, 0x27, 0xe2, 0x16, 0xe2,
	0xaf, 0x4a, 0xbc, 0x7e, 0x62, 0x1d, 0x3f, 0x0f, 0x40, 0xdb, 0x41, 0x2d, 0x9a, 0xbe, 0xab, 0xe6,
	0x8f, 0xc2, 0x9c, 0xb8, 0x4c, 0x92, 0x57, 0xdc, 0x89, 0x8f, 0x05, 0xc4, 0xcf, 0xc1, 0x6c, 0xa0,
	0x91, 0xb8, 0x20, 0xc0, 0xdf, 0xc2, 0xed, 0xa8, 0xcb, 0x8a, 0xf5, 0xb8, 0x90, 0xb2, 0xb0, 0xec,
	0xf1, 0xbe, 0x1d, 0x04, 0x71, 0xa5, 0xbb, 0xb2, 0xa7, 0x66, 0xb4, 0x30, 0xd8, 0x10, 0x55, 0xe3,
	0x99, 0x3f, 0x2b, 0x03, 0x31, 0x33, 0x56, 0x0f, 0xb3, 0xe3, 0xc6, 0xd4, 0x34, 0x5c, 0xdb, 0xc6,
	0xd5, 0x26, 0xf4, 0xbe, 0xdc, 0x52, 0x55, 0xae, 0x30, 0x5a, 0x47, 0x41, 0x45, 0xf9, 0xbb, 0x6c,
	0x06, 0x51, 0xe3, 0xe1, 0xc0, 0xd7, 0x99, 0x91, 0x95, 0x48, 0x3e, 0x34, 0xa1, 0x45, 0x2d, 0x27,
	0x01, 0xb9, 0xe9, 0xfa, 0x26, 0x3b, 0x4f, 0x9d, 0x0a, 0x82, 0x09, 0x42, 0xf0, 0x4a, 0x06, 0x02,
	0x0d, 0x92, 0x30, 0xb4, 0xde, 0x64, 0x17, 0xb2, 0x10, 0x03, 0x61, 0x1e, 0xdb, 0x27, 0x71, 0x96,
	0xe0, 0xd8, 0xea, 0x8b, 0x82, 0xef, 0xe6, 0xd7, 0xca, 0x5f, 0x2d, 0xb5, 0xbe, 0xc2, 0xe6, 0xb3,
	0xd0, 0x9d, 0x36, 0x0e, 0x1c, 0xd6, 0x26, 0x8d, 0x93, 0x85, 0x8b, 0xf4, 0x23, 0xbb, 0x70, 0x91,
	0xb3, 0x42, 0x61, 0x59, 0x59, 0x13, 0x43, 0x6e, 0xd0, 0xff, 0xa8, 0xcc, 0x8c, 0x6d, 0x2f, 0x74,
	0x0e, 0x4e, 0xde, 0xb7, 0x5d, 0xdb, 0x77, 0xba, 0x7c, 0xdc, 0x8b, 0xac, 0xb6, 0xda, 0x0d, 0xbd,
	0xe2, 0xd2, 0x00, 0xe3, 0x55, 0x7c, 0x98, 0xd1, 0x75, 0x86, 0x0e, 0xad, 0xa2, 0x9c, 0x11, 0x44,
	0x47, 0xa0, 0xf8, 0x65, 0x0a, 0xca, 0x67, 0x2b, 0xe9, 0xd7, 0x8b, 0x6c, 0x9a, 0xb7, 0x09, 0xab,
	0x1f, 0x5f, 0x11, 0x3e, 0xd8, 0xff, 0x9e, 0xdd, 0x45, 0x71, 0x40, 0xde, 0x57, 0xe8, 0x5d, 0x03,
	0xb5, 0x90, 0x95, 0xe1, 0x42, 0x1c, 0xb5, 0xc5, 0x57, 0x1f, 0x78, 0xb5, 0x2a, 0xda, 0x9c, 0xb0,
	0x2f, 0xa5, 0x16, 0x34, 0x3f, 0x6f, 0x4c, 0x54, 0x9c, 0x74, 0xb0, 0x78, 0xec, 0x7e, 0xa0, 0x94,
	0x92, 0x92, 0xb5, 0xa0, 0xbb, 0xae, 0x49, 0x29, 0xed, 0xdb, 0x1e, 0x37, 0x21, 0xbc, 0x9a, 0xe4,
	0xb7, 0x4b, 0xb0, 0x07, 0xd7, 0xf5, 0x42, 0xb2, 0x9a, 0x52, 0xf8, 0x39, 0xaf, 0xae, 0xa9, 0xc6,
	0x1c, 0x29, 0x3d, 0xbd, 0x36, 0x0d, 0x1a, 0x35, 0x6e, 0xc4, 0xc7, 0x74, 0xd2, 0x8a, 0xd3, 0xc5,
	0xd0, 0xda, 0x24, 0xf4, 0xcb, 0x26, 0xca, 0x24, 0xf5, 0xf1, 0xc9, 0x4b, 0x55, 0x2e, 0xe7, 0x43,
	0x0b, 0xce, 0x83, 0xeb, 0x8a, 0x88, 0x9c, 0x74, 0x1a, 0x4c, 0x27, 0xae, 0x84, 0x70, 0x72, 0xd4,
	0xc9, 0x54, 0x40, 0x6b, 0x3e, 0x02, 0xb3, 0x13, 0xad, 0x4b, 0x3e, 0xc3, 0x8d, 0x5b, 0xb2, 0x73,
	0x73, 0xca, 0x4e, 0xc0, 0xd9, 0x43, 0x6f, 0x25, 0x5a, 0x2b, 0x67, 0xe5, 0x34, 0x38, 0xf7, 0x0b,
	0x0a, 0x16, 0xf5, 0xc2, 0xec, 0xcc, 0x51, 0xc5, 0x4b, 0xac, 0x36, 0x86, 0x03, 0x6a, 0xfe, 0x65,
	0x59, 0x0b, 0xbc, 0x92, 0xe9, 0xdc, 0x5a, 0xd1, 0x75, 0x4f, 0xc8, 0xe1, 0xca, 0x05, 0x70, 0x4f,
	0x75, 0x23, 0x41, 0xb7, 0xc7, 0x74, 0x57, 0xc4, 0x27, 0x8a, 0xea, 0x10, 0xf9, 0x15, 0xd7, 0x7d,
	0x2b, 0x14, 0x8f, 0xfe, 0xa8, 0x38, 0x4a, 0x3e, 0x12, 0x92, 0x0c, 0x83, 0xd1, 0xb0, 0xc4, 0xb8,
	0x75, 0x82, 0x5a, 0xa7, 0xe5, 0xd5, 0x57, 0x83, 0x7e, 0xce, 0xd2, 0x3e, 0x78, 0x4b, 0x53, 0xb6,
	0x44, 0x4e, 0x0e, 0x93, 0xb7, 0x14, 0x1b, 0x96, 0x78, 0xc5, 0x42, 0xb5, 0xd3, 0xf7, 0x40, 0x91,
	0xc3, 0x6f, 0x2a, 0x80, 0x32, 0xd7, 0x40, 0xb2, 0x65, 0x1c, 0x36, 0x9d, 0x28, 0x60, 0x2a, 0xba,
	0x9a, 0x48, 0x46, 0x58, 0x77, 0x78, 0x4c, 0x97, 0x08, 0x68, 0x96, 0x12, 0x9f, 0x13, 0xc8, 0x78,
	0xe4, 0xff, 0x31, 0x3b, 0x8f, 0xce, 0x80, 0x3a, 0xe6, 0x75, 0xd5, 0x6f, 0x48, 0x5d, 0x6b, 0xa4,
	0xfd, 0x1e, 0x9e, 0x3b, 0x2d, 0x2b, 0x75, 0xdc, 0x3c, 0xb9, 0xca, 0x33, 0xbd, 0x3f, 0x2a, 0xb1,
	0xb9, 0x44, 0xf4, 0x45, 0x82, 0xbe, 0x22, 0xbf, 0x1b, 0xa1, 0x06, 0x64, 0xcf, 0xa7, 0xbf, 0x5e,
	0xa0, 0xae, 0xeb, 0xb6, 0xc8, 0x19, 0xf3, 0x21, 0x5c, 0x6b, 0x3d, 0x97, 0x72, 0x6b, 0xd4, 0x11,
	0x5f, 0x61, 0x06, 0xff, 0x4d, 0xf4, 0x8c, 0xc5, 0xa7, 0x72, 0x0a, 0x25, 0x3b, 0x6c, 0x5e, 0xe2,
	0x49, 0x38, 0xe5, 0xd3, 0x09, 0xa1, 0x46, 0x3d, 0x28, 0x00, 0x68, 0xc3, 0xd2, 0x1f, 0x8f, 0x9b,
	0x39, 0x12, 0xe1, 0x3f, 0x9b, 0xec, 0xfc, 0xdd, 0x23, 0x0b, 0x34, 0x43, 0x1f, 0x29, 0x60, 0xbb,
	0x0f, 0xc8, 0x52, 0x8b, 0x26, 0xe1, 0x8d, 0xfc, 0x63, 0x89, 0x4d, 0x8b, 0x16, 0xae, 0x61, 0xc9,
	0x1d, 0xa6, 0xe7, 0x65, 0x91, 0x4b, 0xb1, 0xe1, 0x3c, 0x11, 0x36, 0x01, 0xab, 0x6d, 0x41, 0x1b,
	0xc6, 0x6f, 0xb9, 0xa5, 0x3f, 0x5f, 0x95, 0xb0, 0xc8, 0x47, 0xee, 0x4b, 0xb4, 0xa2, 0x2f, 0x45,
	0x88, 0xea, 0x02, 0xe0, 0x9e, 0x68, 0x81, 0x63, 0x38, 0x25, 0x8c, 0xcd, 0x7d, 0xeb, 0x7b, 0x30,
	0x15, 0x7f, 0x0d, 0x33, 0x0b, 0x10, 0x89, 0x76, 0x15, 0xce, 0x71, 0x3d, 0x5e, 0x78, 0xa2, 0xc1,
	0x61, 0x3b, 0xaa, 0xf8, 0xf5, 0x9e, 0x03, 0x56, 0x88, 0x54, 0x3c, 0xa9, 0x6e, 0xf0, 0x50, 0xe5,
	0xc6, 0x3a, 0xb6, 0xdb, 0xcb, 0xd8, 0x3b, 0xb0, 0xb7, 0xce, 0xf7, 0x9c, 0x29, 0xea, 0x09, 0xaa,
	0x08, 0xe5, 0x74, 0x99, 0xcd, 0x91, 0x27, 0xb9, 0xc1, 0xbd, 0x50, 0xb4, 0x83, 0xa2, 0xca, 0xd2,
	0xbc, 0x80, 0x5d, 0xd1, 0x74, 0x5c, 0x1c, 0x5e, 0xfb, 0x48, 0x89, 0x33, 0x29, 0x94, 0x9d, 0xe6,
	0x1e, 0x26, 0x35, 0xcc, 0x62, 0x14, 0xd9, 0x68, 0x3b, 0x3e, 0xff, 0x55, 0x02, 0x51, 0x9e, 0xea,
	0x9c, 0x0c, 0xfa, 0x8e, 0xfb, 0x98, 0xb7, 0xe0, 0x93, 0x84, 0x99, 0xce, 0x68, 0x7f, 0xe0, 0xf5,
	0x46, 0x72, 0x4c, 0xa5, 0x55, 0xfd, 0xb5, 0x1f, 0x5e, 0x3d, 0xb7, 0xf2, 0xf7, 0xa5, 0xe4, 0xd7,
	0x3f, 0x8c, 0x36, 0x9b, 0x7c, 0xdf, 0x0e, 0xe5, 0x47, 0x9a, 0x8c, 0xdc, 0xf8, 0xb5, 0x95, 0x74,
	0x5d, 0xb5, 0xaf, 0x3a, 0xbd, 0x2d, 0xb0, 0x80, 0x7b, 0x0a, 0x4c, 0x36, 0xe2, 0x2a, 0x8e, 0x47,
	0x9e, 0xd3, 0xd3, 0x86, 0x6a, 0x9f, 0x23, 0x69, 0xb3, 0x3a, 0xf7, 0x15, 0x8d, 0xeb, 0x39, 0x60,
	0xf1, 0x47, 0x47, 0x5a, 0x79, 0x9f, 0x0d, 0x59, 0xf9, 0xe7, 0xa6, 0x90, 0x78, 0x8c, 0x11, 0x60,
	0x29, 0xc6, 0xc5, 0x34, 0x24, 0xee, 0x22, 0xad, 0x58, 0x8c, 0x35, 0x8c, 0xe1, 0xe9, 0x4b, 0x1a,
	0x46, 0x2b, 0x63, 0xf7, 0xe2, 0x1b, 0x1b, 0x19, 0x9b, 0x50, 0x3e, 0xa8, 0xf1, 0x75, 0xac, 0xce,
	0xc3, 0x07, 0xed, 0x99, 0x0f, 0x90, 0xc5, 0x69, 0x6d, 0x5d, 0xcc, 0xec, 0x35, 0xb6, 0x19, 0x8b,
	0x3f, 0x9b, 0x61, 0x64, 0x7c, 0x8b, 0x20, 0xf5, 0x51, 0x8d, 0xd4, 0x62, 0x12, 0x9f, 0xc8, 0x78,
	0x2b, 0xa2, 0x68, 0x2b, 0xff, 0x03, 0x13, 0x59, 0x94, 0x80, 0x81, 0xa2, 0xb0, 0xb8, 0x95, 0xff,
	0x41, 0x84, 0xac, 0x81, 0xcb, 0xac, 0xde, 0xb6, 0xfb, 0x36, 0x0c, 0xcc, 0x21, 0x7b, 0x52, 0x20,
	0x80, 0x5c, 0x4d, 0x12, 0x17, 0x0a, 0x64, 0x72, 0x86, 0xa4, 0x59, 0x2d, 0xe0, 0x57, 0xc4, 0x60,
	0xba, 0x7b, 0xca, 0x97, 0xd7, 0xc4, 0x15, 0xd5, 0x06, 0xfa, 0x91, 0xf2, 0xe3, 0x30, 0xc6, 0xd5,
	0xf4, 0xee, 0xd4, 0x4f, 0xc7, 0xb4, 0x74, 0xa4, 0xf1, 0xa7, 0x62, 0xde, 0xe7, 0xf6, 0x5d, 0x7c,
	0xb4, 0xc0, 0x58, 0xca, 0xe6, 0x55, 0xf4, 0x71, 0x06, 0x6d, 0x13, 0xca, 0x97, 0x0f, 0xb6, 0x78,
	0xfe, 0x4e, 0xbe, 0xc9, 0x37, 0xae, 0x65, 0x63, 0x8a, 0xbf, 0x2d, 0xa0, 0xa1, 0x52, 0x9e, 0xf6,
	0xbf, 0xcb, 0x1a, 0xf2, 0xa5, 0x77, 0x86, 0xfc, 0x29, 0xef, 0xf1, 0x5b, 0xf3, 0xda, 0x23, 0x0c,
	0x5e, 0xf3, 0xba, 0x83, 0xce, 0x99, 0xfa, 0x10, 0xde, 0x30, 0x8b, 0xb6, 0xc5, 0x9f, 0xca, 0xb7,
	0x5a, 0x19, 0x3b, 0x93, 0xcf, 0xdc, 0xbf, 0xc3, 0xae, 0x00, 0x87, 0x52, 0x1f, 0x5e, 0x01, 0xed,
	0x87, 0x91, 0xb1, 0x51, 0xe0, 0xcc, 0xb5, 0x92, 0xac, 0x49, 0x7f, 0xbb, 0x05, 0xa2, 0x60, 0xf5,
	0x73, 0x2c, 0x19, 0x1c, 0x48, 0x7e, 0xad, 0x45, 0x97, 0x3c, 0x18, 0x0f, 0x4b, 0xdb, 0x92, 0xdf,
	0xc8, 0x2b, 0x90, 0x9f, 0xf9, 0xe5, 0xf8, 0x4b, 0x7a, 0x31, 0xfc, 0xbb, 0xe8, 0x0e, 0x44, 0x5f,
	0x06, 0x4a, 0x9d, 0x13, 0xe5, 0x9b, 0x41, 0xad, 0x0b, 0x5a, 0x85, 0x2c, 0x7d, 0xc8, 0xe7, 0x1b,
	0x8c, 0xc5, 0x5f, 0x05, 0x32, 0x92, 0xf9, 0x5a, 0xf5, 0x73, 0x41, 0x99, 0xa3, 0x57, 0x76, 0xd8,
	0xa4, 0xf2, 0x3c, 0xde, 0x58, 0x45, 0xa9, 0x96, 0x4f, 0xe4, 0x8d, 0xe4, 0x97, 0x2b, 0x72, 0x9e,
	0xd1, 0x6b, 0xf4, 0x58, 0xf9, 0xb7, 0xaa, 0x7c, 0x9c, 0x86, 0x9f, 0xc1, 0x40, 0xc5, 0x99, 0xf3,
	0x18, 0xa1, 0x95, 0xf5, 0x6a, 0xed, 0x1d, 0xa1, 0xf6, 0x9e, 0x4f, 0xf7, 0xa9, 0x7a, 0x6f, 0x21,
	0xbb, 0x1b, 0xac, 0x86, 0x54, 0x54, 0x57, 0xd2, 0x10, 0xb1, 0xa6, 0xca, 0x9a, 0xf9, 0xed, 0x48,
	0x55, 0x65, 0x0d, 0x8d, 0x74, 0x55, 0xd6, 0xd0, 0x6f, 0x73, 0x79, 0x8f, 0xdf, 0x6d, 0x69, 0x2a,
	0x37, 0xfb, 0x61, 0x99, 0x26, 0xf0, 0xc9, 0x67, 0x60, 0x1f, 0xb0, 0x49, 0xe5, 0x51, 0x97, 0x76,
	0x98, 0x33, 0x1e, 0x7d, 0x15, 0x22, 0x5b, 0x47, 0x11, 0x91, 0xcf, 0xb6, 0x8c, 0xa5, 0xdc, 0xed,
	0xf1, 0x57, 0x5d, 0xad, 0x9c, 0x37, 0x60, 0xa8, 0xf2, 0xe2, 0xf7, 0x58, 0x99, 0x68, 0xd4, 0xe7,
	0x5a, 0x9a, 0x7a, 0x51, 0x1e, 0x39, 0x6d, 0xe0, 0xed, 0x6d, 0xf4, 0xd0, 0x2a, 0x73, 0x6f, 0x89,
	0x87, 0x58, 0x9a, 0x95, 0x93, 0x2f, 0xca, 0x57, 0x7e, 0x5c, 0xe2, 0xb5, 0xf5, 0xf8, 0x1d, 0x10,
	0x94, 0xb3, 0xcc, 0x97, 0x44, 0xad, 0x54, 0xc9, 0xbd, 0xf1, 0xa6, 0x90, 0xb1, 0x4b, 0x7a, 0x8f,
	0x88, 0x17, 0x5b, 0xf3, 0x59, 0x2f, 0x8d, 0xd0, 0xaf, 0x51, 0x5e, 0x1c, 0x69, 0x2a, 0x3f, 0xf5,
	0xc8, 0xa9, 0x95, 0x4e, 0x2a, 0x60, 0xff, 0xca, 0x3b, 0xf8, 0xae, 0xc8, 0x1b, 0xf6, 0x6d, 0xfc,
	0xce, 0x08, 0xae, 0x3a, 0xef, 0x29, 0x91, 0x7e, 0x5e, 0xa9, 0x63, 0xe5, 0xcf, 0xca, 0xac, 0x21,
	0x2a, 0xe0, 0x03, 0x50, 0x1d, 0x52, 0xda, 0x93, 0x48, 0xe2, 0x2a, 0x79, 0xdd, 0xc7, 0x4a, 0xbe,
	0x34, 0xd8, 0xc5, 0x9b, 0x3f, 0x2a, 0x4b, 0x4f, 0xbe, 0x0c, 0xc8, 0x5d, 0xd2, 0x75, 0xad, 0x23,
	0xe3, 0x55, 0xc1, 0x57, 0x31, 0x02, 0x80, 0x3f, 0xa2, 0xba, 0xff, 0x45, 0x7d, 0x69, 0xb2, 0x47,
	0x57, 0xa4, 0xaf, 0x45, 0x07, 0x30, 0xfd, 0x54, 0x4b, 0x87, 0xbd, 0x1d, 0xb9, 0x07, 0xb9, 0x6b,
	0xd5, 0xd4, 0xd2, 0x1f, 0x94, 0xc5, 0x73, 0xb0, 0x6c, 0x77, 0x4e, 0x26, 0x7d, 0x5a, 0xe9, 0xb9,
	0x41, 0x33, 0xa0, 0x86, 0xff, 0xd0, 0x09, 0x8f, 0x28, 0xb5, 0x62, 0xe4, 0xbc, 0xfa, 0xc8, 0x1a,
	0xfa, 0x1e, 0x77, 0xc4, 0x08, 0x26, 0xc8, 0x9b, 0xb2, 0x95, 0x8d, 0x8f, 0x84, 0xee, 0x1b, 0x99,
	0xfa, 0x50, 0x7f, 0xf8, 0x93, 0x23, 0x6c, 0xf8, 0xc2, 0x42, 0x3c, 0x6e, 0x4b, 0xba, 0xcf, 0x0b,
	0x29, 0x70, 0x02, 0x5b, 0xf9, 0x8f, 0x32, 0xab, 0x62, 0xaa, 0xda, 0xe8, 0xd0, 0xcd, 0xbc, 0x52,
	0x7d, 0xaf, 0x1d, 0xf7, 0xf4, 0xc3, 0x86, 0xd6, 0xb5, 0x7c, 0x00, 0xf1, 0x8a, 0xe0, 0x36, 0x6b,
	0x6c, 0xd1, 0x4b, 0x86, 0x83, 0x13, 0x7d, 0x41, 0x17, 0x53, 0xb7, 0x0d, 0x74, 0xcb, 0xb2, 0xcd,
	0x66, 0x61, 0x19, 0xc9, 0x7a, 0xf4, 0xe4, 0xb9, 0x4b, 0x95, 0xc1, 0xeb, 0xd4, 0x4c, 0x8c, 0x7d,
	0x87, 0xcd, 0x76, 0x74, 0x7c, 0x05, 0xf0, 0xba, 0xd4, 0xdd, 0x67, 0xcf, 0x71, 0xa9, 0x5b, 0xc5,
	0xb8, 0xea, 0x18, 0x40, 0xce, 0xb6, 0x34, 0x4d, 0x24, 0xff, 0xa5, 0xc2, 0xab, 0x28, 0xa5, 0x44,
	0xa6, 0x6e, 0x0d, 0x78, 0x25, 0x67, 0x2b, 0x5d, 0x5e, 0xf9, 0xb6, 0x90, 0x8a, 0x2b, 0x59, 0x17,
	0x16, 0x52, 0x26, 0xe6, 0xb3, 0x3a, 0x81, 0x04, 0x0d, 0x59, 0x04, 0x99, 0x1e, 0xae, 0x54, 0x5c,
	0x6a, 0xc3, 0x65, 0x95, 0xe4, 0x23, 0x36, 0xab, 0x97, 0xfa, 0x69, 0xc6, 0x2e, 0xbb, 0xce, 0xb0,
	0xf5, 0x7c, 0x0a, 0x5d, 0xa2, 0x2c, 0x6f, 0x9b, 0x7b, 0xaf, 0xb2, 0x46, 0xd0, 0x58, 0xca, 0xc4,
	0x19, 0x97, 0x10, 0x9e, 0x86, 0x6f, 0x8b, 0x2b, 0x6b, 0x71, 0x2d, 0xa3, 0x71, 0x26, 0x75, 0x5f,
	0xd4, 0xca, 0xb9, 0x40, 0x13, 0xde, 0xf0, 0x94, 0x9a, 0x0b, 0xc9, 0x58, 0x5a, 0x32, 0x55, 0xa2,
	0xb3, 0xf9, 0x1e, 0xab, 0xd1, 0x15, 0xa4, 0x71, 0x17, 0xcb, 0x00, 0xd4, 0x6b, 0x48, 0xcd, 0x2d,
	0xce, 0xbc, 0xa8, 0xd4, 0xb1, 0xfd, 0x52, 0x89, 0x54, 0x5f, 0x68, 0xe5, 0xb8, 0x57, 0x51, 0x7d,
	0x50, 0x2b, 0xab, 0xe8, 0xab, 0xcd, 0x9a, 0x51, 0x41, 0x50, 0x8a, 0x28, 0x5a, 0x11, 0x52, 0xeb,
	0x52, 0x66, 0x41, 0x95, 0x1d, 0xac, 0xfc, 0x43, 0x89, 0x17, 0x51, 0xa2, 0xa3, 0x0d, 0xb2, 0x48,
	0xab, 0x68, 0xe5, 0x97, 0x5d, 0x68, 0xea, 0x26, 0xbe, 0x86, 0xdf, 0x62, 0x75, 0x9e, 0x26, 0x32,
	0x9e, 0x2f, 0xac, 0xa2, 0xd0, 0x74, 0x4b, 0x56, 0x9d, 0x43, 0x3b, 0xf3, 0x44, 0x24, 0xab, 0x2e,
	0x5a, 0x4b, 0xb9, 0x9d, 0x1c, 0xd3, 0x8a, 0xcb, 0xaa, 0xf7, 0x6d, 0x20, 0xd3, 0x8a, 0xcc, 0x18,
	0xe9, 0x7a, 0xea, 0xb2, 0x96, 0x39, 0x53, 0xee, 0xd6, 0x56, 0xe4, 0xd7, 0x0d, 0xc6, 0x19, 0xc3,
	0x21, 0x57, 0x36, 0xf1, 0x73, 0xb7, 0xa4, 0x0f, 0x29, 0x8a, 0x50, 0x2e, 0x33, 0x92, 0x4b, 0x4d,
	0xdf, 0x76, 0xe8, 0x62, 0xf1, 0x61, 0x22, 0x7b, 0x6e, 0x6c, 0x0a, 0x72, 0xbc, 0x90, 0x93, 0x3f,
	0x4f, 0x18, 0x8f, 0x2b, 0x39, 0x40, 0xe4, 0xaf, 0xfc, 0x7a, 0x29, 0x62, 0xd2, 0x7b, 0xd1, 0x5f,
	0x17, 0x33, 0x13, 0x88, 0x7a, 0xa8, 0x95, 0xca, 0x7c, 0x7e, 0x53, 0x3b, 0x49, 0xd7, 0x33, 0xe1,
	0x8b, 0xce, 0xd2, 0x6f, 0x96, 0xa2, 0xd4, 0x19, 0xa6, 0x79, 0x78, 0xea, 0x4b, 0x8b, 0x51, 0xb5,
	0x4c, 0x63, 0xab, 0x20, 0x99, 0x76, 0xbb, 0x64, 0xac, 0xb1, 0x2a, 0xa6, 0xc9, 0x8c, 0x4c, 0x28,
	0x9e, 0xaf, 0xd3, 0xf6, 0x95, 0x4a, 0xae, 0xad, 0xcd, 0xfe, 0xe4, 0x67, 0x57, 0xcf, 0xfd, 0xe4,
	0xe7, 0x57, 0x4b, 0x3f, 0x85, 0x7f, 0xff, 0x04, 0xff, 0xf6, 0xeb, 0xf4, 0xa5, 0xf4, 0x3b, 0xff,
	0x17, 0x00, 0x00, 0xff, 0xff, 0x5a, 0x7b, 0xf8, 0xb8, 0x16, 0x5f, 0x00, 0x00,
}
