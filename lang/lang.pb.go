// Code generated by protoc-gen-gogo.
// source: lang.proto
// DO NOT EDIT!

/*
Package lang is a generated protocol buffer package.

It is generated from these files:
	lang.proto

It has these top-level messages:
	Def
	Ref
	Target
	Span
	IndexOp
	IndexResult
*/
package lang

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type Def struct {
	Ident       string `protobuf:"bytes,1,opt,name=ident,proto3" json:"ident,omitempty"`
	ParentIdent string `protobuf:"bytes,2,opt,name=parent_ident,proto3" json:"parent_ident,omitempty"`
	Title       string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Kind        string `protobuf:"bytes,4,opt,name=kind,proto3" json:"kind,omitempty"`
	Global      bool   `protobuf:"varint,5,opt,name=global,proto3" json:"global,omitempty"`
	Span        *Span  `protobuf:"bytes,6,opt,name=span" json:"span,omitempty"`
	NameSpan    *Span  `protobuf:"bytes,7,opt,name=name_span" json:"name_span,omitempty"`
}

func (m *Def) Reset()                    { *m = Def{} }
func (m *Def) String() string            { return proto.CompactTextString(m) }
func (*Def) ProtoMessage()               {}
func (*Def) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{0} }

type Ref struct {
	Span   *Span   `protobuf:"bytes,1,opt,name=span" json:"span,omitempty"`
	Target *Target `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *Ref) Reset()                    { *m = Ref{} }
func (m *Ref) String() string            { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()               {}
func (*Ref) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{1} }

// Target contains information that can be used to determine which def
// a ref points to.
type Target struct {
	Ident   string `protobuf:"bytes,1,opt,name=ident,proto3" json:"ident,omitempty"`
	Context string `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
	Span    *Span  `protobuf:"bytes,3,opt,name=span" json:"span,omitempty"`
	Path    string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	Exact   bool   `protobuf:"varint,5,opt,name=exact,proto3" json:"exact,omitempty"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{2} }

type Span struct {
	StartByte uint32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:"start_byte,omitempty"`
	ByteLen   uint32 `protobuf:"varint,2,opt,name=byte_len,proto3" json:"byte_len,omitempty"`
	StartLine uint32 `protobuf:"varint,3,opt,name=start_line,proto3" json:"start_line,omitempty"`
	StartCol  uint32 `protobuf:"varint,4,opt,name=start_col,proto3" json:"start_col,omitempty"`
	EndLine   uint32 `protobuf:"varint,5,opt,name=end_line,proto3" json:"end_line,omitempty"`
	EndCol    uint32 `protobuf:"varint,6,opt,name=end_col,proto3" json:"end_col,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{3} }

type IndexOp struct {
	Sources map[string][]byte `protobuf:"bytes,1,rep,name=sources" json:"sources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Targets []string          `protobuf:"bytes,2,rep,name=targets" json:"targets,omitempty"`
}

func (m *IndexOp) Reset()                    { *m = IndexOp{} }
func (m *IndexOp) String() string            { return proto.CompactTextString(m) }
func (*IndexOp) ProtoMessage()               {}
func (*IndexOp) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{4} }

type IndexResult struct {
	Files    map[string]*IndexResult_IndexData `protobuf:"bytes,1,rep,name=files" json:"files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Messages []string                          `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
	Complete bool                              `protobuf:"varint,3,opt,name=complete,proto3" json:"complete,omitempty"`
}

func (m *IndexResult) Reset()                    { *m = IndexResult{} }
func (m *IndexResult) String() string            { return proto.CompactTextString(m) }
func (*IndexResult) ProtoMessage()               {}
func (*IndexResult) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{5} }

type IndexResult_IndexData struct {
	Defs []*Def `protobuf:"bytes,1,rep,name=defs" json:"defs,omitempty"`
	Refs []*Ref `protobuf:"bytes,2,rep,name=refs" json:"refs,omitempty"`
}

func (m *IndexResult_IndexData) Reset()                    { *m = IndexResult_IndexData{} }
func (m *IndexResult_IndexData) String() string            { return proto.CompactTextString(m) }
func (*IndexResult_IndexData) ProtoMessage()               {}
func (*IndexResult_IndexData) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{5, 0} }

func init() {
	proto.RegisterType((*Def)(nil), "lang.Def")
	proto.RegisterType((*Ref)(nil), "lang.Ref")
	proto.RegisterType((*Target)(nil), "lang.Target")
	proto.RegisterType((*Span)(nil), "lang.Span")
	proto.RegisterType((*IndexOp)(nil), "lang.IndexOp")
	proto.RegisterType((*IndexResult)(nil), "lang.IndexResult")
	proto.RegisterType((*IndexResult_IndexData)(nil), "lang.IndexResult.IndexData")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Indexer service

type IndexerClient interface {
	Index(ctx context.Context, in *IndexOp, opts ...grpc.CallOption) (*IndexResult, error)
}

type indexerClient struct {
	cc *grpc.ClientConn
}

func NewIndexerClient(cc *grpc.ClientConn) IndexerClient {
	return &indexerClient{cc}
}

func (c *indexerClient) Index(ctx context.Context, in *IndexOp, opts ...grpc.CallOption) (*IndexResult, error) {
	out := new(IndexResult)
	err := grpc.Invoke(ctx, "/lang.Indexer/Index", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Indexer service

type IndexerServer interface {
	Index(context.Context, *IndexOp) (*IndexResult, error)
}

func RegisterIndexerServer(s *grpc.Server, srv IndexerServer) {
	s.RegisterService(&_Indexer_serviceDesc, srv)
}

func _Indexer_Index_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(IndexOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(IndexerServer).Index(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Indexer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lang.Indexer",
	HandlerType: (*IndexerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Index",
			Handler:    _Indexer_Index_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptorLang = []byte{
	// 500 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x64, 0x53, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xc5, 0xb5, 0xf3, 0xe1, 0x49, 0x0c, 0x74, 0x85, 0x84, 0x65, 0x0a, 0x42, 0x3e, 0x15, 0x10,
	0xae, 0x14, 0x38, 0x20, 0xa4, 0x5e, 0x50, 0x41, 0xea, 0x09, 0xa9, 0xe5, 0x6e, 0xad, 0xed, 0x89,
	0x6b, 0x75, 0xb3, 0xb6, 0xec, 0x75, 0x49, 0xfe, 0x05, 0x3f, 0x8b, 0xbf, 0xc1, 0x8d, 0x9f, 0xc1,
	0xee, 0xac, 0x53, 0x92, 0xe6, 0xb6, 0xf3, 0xde, 0xcc, 0xbc, 0xf7, 0x46, 0x36, 0x80, 0xe0, 0xb2,
	0x4c, 0x9a, 0xb6, 0x56, 0x35, 0xf3, 0xcc, 0x3b, 0x7a, 0x5f, 0x56, 0xea, 0xa6, 0xcf, 0x92, 0xbc,
	0x5e, 0x9d, 0x95, 0x75, 0x59, 0x9f, 0x11, 0x99, 0xf5, 0x4b, 0xaa, 0xa8, 0xa0, 0x97, 0x1d, 0x8a,
	0x7f, 0x39, 0xe0, 0x5e, 0xe0, 0x92, 0x05, 0x30, 0xaa, 0x0a, 0x94, 0x2a, 0x74, 0x5e, 0x3b, 0xa7,
	0x3e, 0x7b, 0x06, 0xf3, 0x86, 0xb7, 0xba, 0x4e, 0x2d, 0x7a, 0x44, 0xa8, 0x6e, 0x52, 0x95, 0x12,
	0x18, 0xba, 0x54, 0xce, 0xc1, 0xbb, 0xad, 0x64, 0x11, 0x7a, 0x54, 0x3d, 0x86, 0x71, 0x29, 0xea,
	0x8c, 0x8b, 0x70, 0xa4, 0xeb, 0x29, 0x0b, 0xc1, 0xeb, 0x1a, 0x2e, 0xc3, 0xb1, 0xae, 0x66, 0x0b,
	0x48, 0xc8, 0xe9, 0xb5, 0x46, 0xd8, 0x4b, 0xf0, 0x25, 0x5f, 0x61, 0x4a, 0xf4, 0xe4, 0x21, 0x1d,
	0x9f, 0x83, 0x7b, 0xa5, 0x1d, 0x6d, 0xe7, 0x9d, 0x83, 0xf9, 0x13, 0x18, 0x2b, 0xde, 0x96, 0x68,
	0x6d, 0xcd, 0x16, 0x73, 0xcb, 0xfd, 0x20, 0x2c, 0x4e, 0x61, 0x6c, 0x5f, 0x0f, 0x33, 0x3d, 0x81,
	0x49, 0x5e, 0x4b, 0x85, 0xeb, 0x6d, 0x9c, 0xad, 0x82, 0x7b, 0xa0, 0xa0, 0x93, 0x35, 0x5c, 0xdd,
	0x0c, 0xc9, 0xf4, 0x1e, 0x5c, 0xf3, 0x5c, 0xd9, 0x60, 0xf1, 0x1d, 0x78, 0xd4, 0xc4, 0x00, 0x3a,
	0xed, 0x43, 0xa5, 0xd9, 0x46, 0x21, 0x69, 0x04, 0xec, 0x29, 0x4c, 0x4d, 0x95, 0x0a, 0x94, 0x24,
	0x12, 0xfc, 0xef, 0x12, 0x95, 0xb4, 0x87, 0x0b, 0xd8, 0x31, 0xf8, 0x16, 0xcb, 0x6b, 0x41, 0x1a,
	0x34, 0x88, 0xb2, 0xb0, 0x4d, 0x23, 0x42, 0xb4, 0x5d, 0x83, 0x98, 0x16, 0x73, 0xc2, 0x20, 0xfe,
	0x09, 0x93, 0x4b, 0x59, 0xe0, 0xfa, 0x7b, 0xc3, 0xde, 0xc1, 0xa4, 0xab, 0xfb, 0x36, 0xc7, 0x4e,
	0xeb, 0xba, 0xda, 0x7c, 0x64, 0xcd, 0x0f, 0x7c, 0x72, 0x6d, 0xc9, 0xaf, 0x52, 0xb5, 0x1b, 0xb3,
	0xc8, 0x9e, 0xab, 0xd3, 0x96, 0xdc, 0x53, 0x3f, 0x4a, 0x60, 0xbe, 0xd7, 0x30, 0x03, 0xf7, 0x16,
	0x37, 0xc3, 0x95, 0x74, 0xd8, 0x3b, 0x2e, 0x7a, 0x24, 0xfb, 0xf3, 0xcf, 0x47, 0x9f, 0x9c, 0xf8,
	0xaf, 0x03, 0x33, 0xda, 0x7c, 0x85, 0x5d, 0x2f, 0x94, 0x56, 0x1f, 0x2d, 0x2b, 0x71, 0xaf, 0x7d,
	0xb2, 0xa3, 0x6d, 0x3b, 0x92, 0x6f, 0x86, 0xb6, 0xcb, 0x75, 0xb0, 0x15, 0x76, 0x1d, 0x2f, 0x71,
	0x90, 0x37, 0x88, 0xfe, 0x38, 0x1b, 0x81, 0xca, 0xde, 0x63, 0x1a, 0x9d, 0x83, 0x4f, 0xd3, 0x17,
	0x5c, 0x71, 0xf6, 0x1c, 0xbc, 0x02, 0x97, 0xdb, 0xe5, 0xbe, 0x5d, 0x6e, 0x3e, 0x51, 0x4d, 0xb4,
	0x86, 0x38, 0xda, 0x25, 0xf4, 0x97, 0x12, 0x5d, 0x02, 0xec, 0x08, 0xee, 0xa5, 0x79, 0xbb, 0x9b,
	0x66, 0xb6, 0x78, 0x71, 0x68, 0xf5, 0x5e, 0xd8, 0x44, 0x5d, 0x7c, 0x1c, 0x6e, 0x8c, 0x2d, 0x7b,
	0x03, 0x23, 0x7a, 0xb2, 0x60, 0xef, 0xb6, 0xd1, 0xf1, 0xc1, 0x8e, 0x2f, 0xde, 0xef, 0x3f, 0xaf,
	0x1e, 0x65, 0x63, 0xfa, 0xa3, 0x3e, 0xfc, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x05, 0xb0, 0x66,
	0x94, 0x03, 0x00, 0x00,
}
