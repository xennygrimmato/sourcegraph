// Code generated by protoc-gen-gogo.
// source: lang.proto
// DO NOT EDIT!

/*
Package lang is a generated protocol buffer package.

It is generated from these files:
	lang.proto

It has these top-level messages:
	Def
	Ref
	Target
	Span
	DefsOp
	DefsResult
	RefsOp
	Refs
	RefsResult
	ToksOp
	Tok
	ToksResult
*/
package lang

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.GoGoProtoPackageIsVersion1

type Tok_TokType int32

const (
	Tok_KEYWORD                Tok_TokType = 0
	Tok_KEYWORD_CONSTANT       Tok_TokType = 1
	Tok_KEYWORD_DECLARATION    Tok_TokType = 2
	Tok_KEYWORD_NAMESPACE      Tok_TokType = 3
	Tok_KEYWORD_PSEUDO         Tok_TokType = 4
	Tok_KEYWORD_RESERVED       Tok_TokType = 5
	Tok_KEYWORD_TYPE           Tok_TokType = 6
	Tok_NAME                   Tok_TokType = 7
	Tok_NAME_ATTRIBUTE         Tok_TokType = 8
	Tok_NAME_BUILTIN           Tok_TokType = 9
	Tok_NAME_BUILTIN_PSEUDO    Tok_TokType = 10
	Tok_NAME_CLASS             Tok_TokType = 11
	Tok_NAME_CONSTANT          Tok_TokType = 12
	Tok_NAME_DECORATOR         Tok_TokType = 13
	Tok_NAME_ENTITY            Tok_TokType = 14
	Tok_NAME_EXCEPTION         Tok_TokType = 15
	Tok_NAME_FUNCTION          Tok_TokType = 16
	Tok_NAME_LABEL             Tok_TokType = 17
	Tok_NAME_NAMESPACE         Tok_TokType = 18
	Tok_NAME_OTHER             Tok_TokType = 19
	Tok_NAME_TAG               Tok_TokType = 20
	Tok_NAME_VARIABLE          Tok_TokType = 21
	Tok_NAME_VARIABLE_CLASS    Tok_TokType = 22
	Tok_NAME_VARIABLE_GLOBAL   Tok_TokType = 23
	Tok_NAME_VARIABLE_INSTANCE Tok_TokType = 24
	Tok_LITERAL                Tok_TokType = 25
	Tok_LITERAL_DATE           Tok_TokType = 26
	Tok_STRING                 Tok_TokType = 27
	Tok_STRING_BACKTICK        Tok_TokType = 28
	Tok_STRING_CHAR            Tok_TokType = 29
	Tok_STRING_DOC             Tok_TokType = 30
	Tok_STRING_DOUBLE          Tok_TokType = 31
	Tok_STRING_ESCAPE          Tok_TokType = 32
	Tok_STRING_HEREDOC         Tok_TokType = 33
	Tok_STRING_INTERPOL        Tok_TokType = 34
	Tok_STRING_OTHER           Tok_TokType = 35
	Tok_STRING_REGEX           Tok_TokType = 36
	Tok_STRING_SINGLE          Tok_TokType = 37
	Tok_STRING_SYMBOL          Tok_TokType = 38
	Tok_NUMBER                 Tok_TokType = 39
	Tok_NUMBER_BIN             Tok_TokType = 40
	Tok_NUMBER_FLOAT           Tok_TokType = 41
	Tok_NUMBER_HEX             Tok_TokType = 42
	Tok_NUMBER_INTEGER         Tok_TokType = 43
	Tok_NUMBER_INTEGER_LONG    Tok_TokType = 44
	Tok_NUMBER_OCT             Tok_TokType = 45
	Tok_OPERATOR               Tok_TokType = 46
	Tok_OPERATOR_WORD          Tok_TokType = 47
	Tok_PUNCTUATION            Tok_TokType = 48
	Tok_COMMENT                Tok_TokType = 49
	Tok_COMMENT_HASHBANG       Tok_TokType = 50
	Tok_COMMENT_MULTILINE      Tok_TokType = 51
	Tok_COMMENT_PREPROC        Tok_TokType = 52
	Tok_COMMENT_SINGLE         Tok_TokType = 53
	Tok_COMMENT_SPECIAL        Tok_TokType = 54
	Tok_GENERIC                Tok_TokType = 55
	Tok_GENERIC_DELETED        Tok_TokType = 56
	Tok_GENERIC_EMPH           Tok_TokType = 57
	Tok_GENERIC_ERROR          Tok_TokType = 58
	Tok_GENERIC_HEADING        Tok_TokType = 59
	Tok_GENERIC_INSERTED       Tok_TokType = 60
	Tok_GENERIC_OUTPUT         Tok_TokType = 61
	Tok_GENERIC_PROMPT         Tok_TokType = 62
	Tok_GENERIC_STRONG         Tok_TokType = 63
	Tok_GENERIC_SUBHEADING     Tok_TokType = 64
	Tok_GENERIC_TRACEBACK      Tok_TokType = 65
)

var Tok_TokType_name = map[int32]string{
	0:  "KEYWORD",
	1:  "KEYWORD_CONSTANT",
	2:  "KEYWORD_DECLARATION",
	3:  "KEYWORD_NAMESPACE",
	4:  "KEYWORD_PSEUDO",
	5:  "KEYWORD_RESERVED",
	6:  "KEYWORD_TYPE",
	7:  "NAME",
	8:  "NAME_ATTRIBUTE",
	9:  "NAME_BUILTIN",
	10: "NAME_BUILTIN_PSEUDO",
	11: "NAME_CLASS",
	12: "NAME_CONSTANT",
	13: "NAME_DECORATOR",
	14: "NAME_ENTITY",
	15: "NAME_EXCEPTION",
	16: "NAME_FUNCTION",
	17: "NAME_LABEL",
	18: "NAME_NAMESPACE",
	19: "NAME_OTHER",
	20: "NAME_TAG",
	21: "NAME_VARIABLE",
	22: "NAME_VARIABLE_CLASS",
	23: "NAME_VARIABLE_GLOBAL",
	24: "NAME_VARIABLE_INSTANCE",
	25: "LITERAL",
	26: "LITERAL_DATE",
	27: "STRING",
	28: "STRING_BACKTICK",
	29: "STRING_CHAR",
	30: "STRING_DOC",
	31: "STRING_DOUBLE",
	32: "STRING_ESCAPE",
	33: "STRING_HEREDOC",
	34: "STRING_INTERPOL",
	35: "STRING_OTHER",
	36: "STRING_REGEX",
	37: "STRING_SINGLE",
	38: "STRING_SYMBOL",
	39: "NUMBER",
	40: "NUMBER_BIN",
	41: "NUMBER_FLOAT",
	42: "NUMBER_HEX",
	43: "NUMBER_INTEGER",
	44: "NUMBER_INTEGER_LONG",
	45: "NUMBER_OCT",
	46: "OPERATOR",
	47: "OPERATOR_WORD",
	48: "PUNCTUATION",
	49: "COMMENT",
	50: "COMMENT_HASHBANG",
	51: "COMMENT_MULTILINE",
	52: "COMMENT_PREPROC",
	53: "COMMENT_SINGLE",
	54: "COMMENT_SPECIAL",
	55: "GENERIC",
	56: "GENERIC_DELETED",
	57: "GENERIC_EMPH",
	58: "GENERIC_ERROR",
	59: "GENERIC_HEADING",
	60: "GENERIC_INSERTED",
	61: "GENERIC_OUTPUT",
	62: "GENERIC_PROMPT",
	63: "GENERIC_STRONG",
	64: "GENERIC_SUBHEADING",
	65: "GENERIC_TRACEBACK",
}
var Tok_TokType_value = map[string]int32{
	"KEYWORD":                0,
	"KEYWORD_CONSTANT":       1,
	"KEYWORD_DECLARATION":    2,
	"KEYWORD_NAMESPACE":      3,
	"KEYWORD_PSEUDO":         4,
	"KEYWORD_RESERVED":       5,
	"KEYWORD_TYPE":           6,
	"NAME":                   7,
	"NAME_ATTRIBUTE":         8,
	"NAME_BUILTIN":           9,
	"NAME_BUILTIN_PSEUDO":    10,
	"NAME_CLASS":             11,
	"NAME_CONSTANT":          12,
	"NAME_DECORATOR":         13,
	"NAME_ENTITY":            14,
	"NAME_EXCEPTION":         15,
	"NAME_FUNCTION":          16,
	"NAME_LABEL":             17,
	"NAME_NAMESPACE":         18,
	"NAME_OTHER":             19,
	"NAME_TAG":               20,
	"NAME_VARIABLE":          21,
	"NAME_VARIABLE_CLASS":    22,
	"NAME_VARIABLE_GLOBAL":   23,
	"NAME_VARIABLE_INSTANCE": 24,
	"LITERAL":                25,
	"LITERAL_DATE":           26,
	"STRING":                 27,
	"STRING_BACKTICK":        28,
	"STRING_CHAR":            29,
	"STRING_DOC":             30,
	"STRING_DOUBLE":          31,
	"STRING_ESCAPE":          32,
	"STRING_HEREDOC":         33,
	"STRING_INTERPOL":        34,
	"STRING_OTHER":           35,
	"STRING_REGEX":           36,
	"STRING_SINGLE":          37,
	"STRING_SYMBOL":          38,
	"NUMBER":                 39,
	"NUMBER_BIN":             40,
	"NUMBER_FLOAT":           41,
	"NUMBER_HEX":             42,
	"NUMBER_INTEGER":         43,
	"NUMBER_INTEGER_LONG":    44,
	"NUMBER_OCT":             45,
	"OPERATOR":               46,
	"OPERATOR_WORD":          47,
	"PUNCTUATION":            48,
	"COMMENT":                49,
	"COMMENT_HASHBANG":       50,
	"COMMENT_MULTILINE":      51,
	"COMMENT_PREPROC":        52,
	"COMMENT_SINGLE":         53,
	"COMMENT_SPECIAL":        54,
	"GENERIC":                55,
	"GENERIC_DELETED":        56,
	"GENERIC_EMPH":           57,
	"GENERIC_ERROR":          58,
	"GENERIC_HEADING":        59,
	"GENERIC_INSERTED":       60,
	"GENERIC_OUTPUT":         61,
	"GENERIC_PROMPT":         62,
	"GENERIC_STRONG":         63,
	"GENERIC_SUBHEADING":     64,
	"GENERIC_TRACEBACK":      65,
}

func (x Tok_TokType) String() string {
	return proto.EnumName(Tok_TokType_name, int32(x))
}
func (Tok_TokType) EnumDescriptor() ([]byte, []int) { return fileDescriptorLang, []int{10, 0} }

type Def struct {
	// ident is an opaque identifier for the def. It is not required to
	// be unique. External code that refers to this def should be able
	// to reconstruct this id.
	//
	// Examples:
	//
	//   "x" for `var x = 7`
	//
	//   "X.prototype.y" for y in `class X { y() {} }`
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// meta is a collection of key-value pairs that contain
	// information that can be used to resolve or narrow references to
	// this def.
	//
	// Examples:
	//
	//   {"go_package_import_path": "example.com/pkg"} to indicate
	//   that this def is defined in a Go package whose import path is
	//   "example.com/pkg".
	//
	//   {"javascript_module": "mod"} to indicate that this def is
	//   defined in a JavaScript (CommonJS-style) package named "mod".
	//
	// TODO(sqs): How to deal with re-exporting in JavaScript? E.g.,
	// react-router Link is exported by the react-router lib/index.js
	// file as well as by lib/Link.js. We want both to be the same
	// def.
	Meta map[string]string `protobuf:"bytes,2,rep,name=meta" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// title is the full human-readable declaration title (e.g., "var
	// x int" for `var x = 7`)
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// doc is the plain-text documentation.
	//
	// TODO(sqs): support multiple formats, HTML, etc.
	Doc string `protobuf:"bytes,4,opt,name=doc,proto3" json:"doc,omitempty"`
	// path is the path to the file or directory in which this def is
	// defined.
	//
	// It is unset when it can't be determined or when there is no
	// single path that includes all relevant files/directories that
	// define it, such as for a Ruby class that is defined (and
	// reopened) across many files in many directories.
	//
	// TODO(sqs): How to handle C-style decls and defns? How to handle
	// Ruby-style class reopening (defining a class across multiple
	// files)?
	Path string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	// span is the range containing the entire def and decl. (e.g.,
	// the entire statement `var foo = 3`). It is unset when it can't
	// be determined or when there is none, such as when the
	// definition is defined across multiple files (as in the case of
	// Go packages, for example).
	Span *Span `protobuf:"bytes,6,opt,name=span" json:"span,omitempty"`
	// name_span is the range containing only the def's name (e.g.,
	// just `foo` in `var foo = 3`)
	NameSpan *Span `protobuf:"bytes,7,opt,name=name_span" json:"name_span,omitempty"`
}

func (m *Def) Reset()                    { *m = Def{} }
func (m *Def) String() string            { return proto.CompactTextString(m) }
func (*Def) ProtoMessage()               {}
func (*Def) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{0} }

type Ref struct {
	Span   *Span   `protobuf:"bytes,1,opt,name=span" json:"span,omitempty"`
	Target *Target `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *Ref) Reset()                    { *m = Ref{} }
func (m *Ref) String() string            { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()               {}
func (*Ref) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{1} }

// Target contains information that can be used to determine which def
// a ref points to.
type Target struct {
	// id is the identifier of the def that this ref points to.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// constraints to narrow or resolve the target def. Each entry in
	// this map further constrains the match to only those defs
	// containing an identical meta entry.
	Constraints map[string]string `protobuf:"bytes,2,rep,name=constraints" json:"constraints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// For local/internal targets:
	Span *Span  `protobuf:"bytes,3,opt,name=span" json:"span,omitempty"`
	File string `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	// fuzzy is whether this target is a best-effort, inexact
	// references to a def. Applications may resolve fuzzy targets
	// different from exact targets, by presenting the user with a
	// disambiguation UI, for example.
	//
	// A target that refers to a specific file and span is not fuzzy.
	//
	// A target that uniquely identifies a definition is not fuzzy,
	// even if its file/span is not set. For example, {"id":
	// "NewRequest", "constraints": {"go_package_import_path":
	// "net/http"}} uniquely identifies Go's http.NewRequest even
	// though it does not specify a file and span.
	//
	// A target that merely refers to an id, or an id among the
	// current project's dependencies, is fuzzy.
	Fuzzy bool `protobuf:"varint,5,opt,name=fuzzy,proto3" json:"fuzzy,omitempty"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{2} }

// A Span describes a range in a file. Byte offsets start counting at
// 0. Line and column numbers start counting at 1. Column numbers
// refer to a character position (not a byte offset) in the line.
//
// It is useful to have both. Byte offsets are most useful for
// programmatic operations; line and column numbers are useful for
// display.
type Span struct {
	StartByte uint32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:"start_byte,omitempty"`
	ByteLen   uint32 `protobuf:"varint,2,opt,name=byte_len,proto3" json:"byte_len,omitempty"`
	StartLine uint32 `protobuf:"varint,3,opt,name=start_line,proto3" json:"start_line,omitempty"`
	StartCol  uint32 `protobuf:"varint,4,opt,name=start_col,proto3" json:"start_col,omitempty"`
	EndLine   uint32 `protobuf:"varint,5,opt,name=end_line,proto3" json:"end_line,omitempty"`
	EndCol    uint32 `protobuf:"varint,6,opt,name=end_col,proto3" json:"end_col,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (m *Span) String() string            { return proto.CompactTextString(m) }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{3} }

type DefsOp struct {
	Sources map[string][]byte `protobuf:"bytes,1,rep,name=sources" json:"sources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Origins []string          `protobuf:"bytes,2,rep,name=origins" json:"origins,omitempty"`
	// id specifies an identifier filter, so that only defs whose id
	// matches this value is returned.
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// constraints narrow the set of defs to return.
	Constraints map[string]string `protobuf:"bytes,4,rep,name=constraints" json:"constraints,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *DefsOp) Reset()                    { *m = DefsOp{} }
func (m *DefsOp) String() string            { return proto.CompactTextString(m) }
func (*DefsOp) ProtoMessage()               {}
func (*DefsOp) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{4} }

type DefsResult struct {
	Defs     []*Def   `protobuf:"bytes,1,rep,name=defs" json:"defs,omitempty"`
	Messages []string `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
	Complete bool     `protobuf:"varint,3,opt,name=complete,proto3" json:"complete,omitempty"`
}

func (m *DefsResult) Reset()                    { *m = DefsResult{} }
func (m *DefsResult) String() string            { return proto.CompactTextString(m) }
func (*DefsResult) ProtoMessage()               {}
func (*DefsResult) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{5} }

type RefsOp struct {
	Sources map[string][]byte  `protobuf:"bytes,1,rep,name=sources" json:"sources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Origins []*RefsOp_FileSpan `protobuf:"bytes,2,rep,name=origins" json:"origins,omitempty"`
}

func (m *RefsOp) Reset()                    { *m = RefsOp{} }
func (m *RefsOp) String() string            { return proto.CompactTextString(m) }
func (*RefsOp) ProtoMessage()               {}
func (*RefsOp) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{6} }

type RefsOp_FileSpan struct {
	File string `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Span *Span  `protobuf:"bytes,2,opt,name=span" json:"span,omitempty"`
}

func (m *RefsOp_FileSpan) Reset()                    { *m = RefsOp_FileSpan{} }
func (m *RefsOp_FileSpan) String() string            { return proto.CompactTextString(m) }
func (*RefsOp_FileSpan) ProtoMessage()               {}
func (*RefsOp_FileSpan) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{6, 1} }

type Refs struct {
	Refs []*Ref `protobuf:"bytes,1,rep,name=refs" json:"refs,omitempty"`
}

func (m *Refs) Reset()                    { *m = Refs{} }
func (m *Refs) String() string            { return proto.CompactTextString(m) }
func (*Refs) ProtoMessage()               {}
func (*Refs) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{7} }

type RefsResult struct {
	// Supports overlapping refs (e.g., Go embedded structs where the
	// field name and type name are overlapping refs).
	Files    map[string]*Refs `protobuf:"bytes,1,rep,name=files" json:"files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Messages []string         `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
	Complete bool             `protobuf:"varint,3,opt,name=complete,proto3" json:"complete,omitempty"`
}

func (m *RefsResult) Reset()                    { *m = RefsResult{} }
func (m *RefsResult) String() string            { return proto.CompactTextString(m) }
func (*RefsResult) ProtoMessage()               {}
func (*RefsResult) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{8} }

type ToksOp struct {
	// source is the input text to be tokenized.
	Source []byte `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *ToksOp) Reset()                    { *m = ToksOp{} }
func (m *ToksOp) String() string            { return proto.CompactTextString(m) }
func (*ToksOp) ProtoMessage()               {}
func (*ToksOp) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{9} }

// Tok represents a token in source code (i.e., the result of
// tokenization).
type Tok struct {
	StartByte uint32      `protobuf:"varint,1,opt,name=start_byte,proto3" json:"start_byte,omitempty"`
	ByteLen   uint32      `protobuf:"varint,2,opt,name=byte_len,proto3" json:"byte_len,omitempty"`
	Type      Tok_TokType `protobuf:"varint,3,opt,name=type,proto3,enum=lang.Tok_TokType" json:"type,omitempty"`
}

func (m *Tok) Reset()                    { *m = Tok{} }
func (m *Tok) String() string            { return proto.CompactTextString(m) }
func (*Tok) ProtoMessage()               {}
func (*Tok) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{10} }

type ToksResult struct {
	Toks     []*Tok   `protobuf:"bytes,1,rep,name=toks" json:"toks,omitempty"`
	Messages []string `protobuf:"bytes,2,rep,name=messages" json:"messages,omitempty"`
	Complete bool     `protobuf:"varint,3,opt,name=complete,proto3" json:"complete,omitempty"`
}

func (m *ToksResult) Reset()                    { *m = ToksResult{} }
func (m *ToksResult) String() string            { return proto.CompactTextString(m) }
func (*ToksResult) ProtoMessage()               {}
func (*ToksResult) Descriptor() ([]byte, []int) { return fileDescriptorLang, []int{11} }

func init() {
	proto.RegisterType((*Def)(nil), "lang.Def")
	proto.RegisterType((*Ref)(nil), "lang.Ref")
	proto.RegisterType((*Target)(nil), "lang.Target")
	proto.RegisterType((*Span)(nil), "lang.Span")
	proto.RegisterType((*DefsOp)(nil), "lang.DefsOp")
	proto.RegisterType((*DefsResult)(nil), "lang.DefsResult")
	proto.RegisterType((*RefsOp)(nil), "lang.RefsOp")
	proto.RegisterType((*RefsOp_FileSpan)(nil), "lang.RefsOp.FileSpan")
	proto.RegisterType((*Refs)(nil), "lang.Refs")
	proto.RegisterType((*RefsResult)(nil), "lang.RefsResult")
	proto.RegisterType((*ToksOp)(nil), "lang.ToksOp")
	proto.RegisterType((*Tok)(nil), "lang.Tok")
	proto.RegisterType((*ToksResult)(nil), "lang.ToksResult")
	proto.RegisterEnum("lang.Tok_TokType", Tok_TokType_name, Tok_TokType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Lang service

type LangClient interface {
	// Defs performs source code analysis and returns a list of
	// definitions found.
	Defs(ctx context.Context, in *DefsOp, opts ...grpc.CallOption) (*DefsResult, error)
	// Refs performs source code analysis and returns a list of refs
	// found at the given location.
	Refs(ctx context.Context, in *RefsOp, opts ...grpc.CallOption) (*RefsResult, error)
	// Toks tokenizes the specified source code and returns a list of
	// tokens.
	Toks(ctx context.Context, in *ToksOp, opts ...grpc.CallOption) (*ToksResult, error)
}

type langClient struct {
	cc *grpc.ClientConn
}

func NewLangClient(cc *grpc.ClientConn) LangClient {
	return &langClient{cc}
}

func (c *langClient) Defs(ctx context.Context, in *DefsOp, opts ...grpc.CallOption) (*DefsResult, error) {
	out := new(DefsResult)
	err := grpc.Invoke(ctx, "/lang.Lang/Defs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langClient) Refs(ctx context.Context, in *RefsOp, opts ...grpc.CallOption) (*RefsResult, error) {
	out := new(RefsResult)
	err := grpc.Invoke(ctx, "/lang.Lang/Refs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langClient) Toks(ctx context.Context, in *ToksOp, opts ...grpc.CallOption) (*ToksResult, error) {
	out := new(ToksResult)
	err := grpc.Invoke(ctx, "/lang.Lang/Toks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Lang service

type LangServer interface {
	// Defs performs source code analysis and returns a list of
	// definitions found.
	Defs(context.Context, *DefsOp) (*DefsResult, error)
	// Refs performs source code analysis and returns a list of refs
	// found at the given location.
	Refs(context.Context, *RefsOp) (*RefsResult, error)
	// Toks tokenizes the specified source code and returns a list of
	// tokens.
	Toks(context.Context, *ToksOp) (*ToksResult, error)
}

func RegisterLangServer(s *grpc.Server, srv LangServer) {
	s.RegisterService(&_Lang_serviceDesc, srv)
}

func _Lang_Defs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(DefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(LangServer).Defs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Lang_Refs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(RefsOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(LangServer).Refs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Lang_Toks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ToksOp)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(LangServer).Toks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Lang_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lang.Lang",
	HandlerType: (*LangServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Defs",
			Handler:    _Lang_Defs_Handler,
		},
		{
			MethodName: "Refs",
			Handler:    _Lang_Refs_Handler,
		},
		{
			MethodName: "Toks",
			Handler:    _Lang_Toks_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

var fileDescriptorLang = []byte{
	// 1326 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x56, 0xcb, 0x72, 0x1b, 0x45,
	0x17, 0x8e, 0xac, 0xb1, 0x2e, 0x47, 0x92, 0xdd, 0x6e, 0xe7, 0xa2, 0x28, 0x37, 0x47, 0xff, 0x8f,
	0x31, 0x09, 0x51, 0x40, 0xe1, 0x12, 0x02, 0x01, 0x46, 0xa3, 0x8e, 0x34, 0x95, 0xd1, 0xcc, 0x54,
	0x4f, 0x2b, 0xc4, 0x2b, 0xd5, 0xd8, 0x1e, 0x29, 0x2a, 0xcb, 0x1a, 0x95, 0x34, 0x4e, 0x95, 0xb3,
	0xe0, 0x31, 0x78, 0x11, 0x1e, 0x00, 0x16, 0x2c, 0x78, 0x0d, 0x96, 0xec, 0x78, 0x04, 0xea, 0xf4,
	0x5c, 0x34, 0xb2, 0x03, 0x04, 0x16, 0xaa, 0xea, 0xf3, 0x9d, 0xdb, 0x77, 0xbe, 0xee, 0x9e, 0x16,
	0xc0, 0xc4, 0x9d, 0x8e, 0x1a, 0xb3, 0xb9, 0x1f, 0xf8, 0x54, 0xc1, 0x75, 0xed, 0xc1, 0x68, 0x1c,
	0xbc, 0x3a, 0x3d, 0x68, 0x1c, 0xfa, 0x27, 0x0f, 0x47, 0xfe, 0xc8, 0x7f, 0x28, 0x9d, 0x07, 0xa7,
	0x43, 0x69, 0x49, 0x43, 0xae, 0xc2, 0xa4, 0xfa, 0x2f, 0x19, 0xc8, 0xb6, 0xbd, 0x21, 0x05, 0x58,
	0x1b, 0x1f, 0x55, 0x33, 0x3b, 0x99, 0xbd, 0x22, 0xbd, 0x0b, 0xca, 0x89, 0x17, 0xb8, 0xd5, 0xb5,
	0x9d, 0xec, 0x5e, 0xa9, 0xb9, 0xdd, 0x90, 0x3d, 0xda, 0xde, 0xb0, 0xd1, 0xf3, 0x02, 0x97, 0x4d,
	0x83, 0xf9, 0x19, 0xad, 0xc0, 0x7a, 0x30, 0x0e, 0x26, 0x5e, 0x35, 0x2b, 0x33, 0x4a, 0x90, 0x3d,
	0xf2, 0x0f, 0xab, 0x8a, 0x34, 0xca, 0xa0, 0xcc, 0xdc, 0xe0, 0x55, 0x75, 0x5d, 0x5a, 0x55, 0x50,
	0x16, 0x33, 0x77, 0x5a, 0xcd, 0xed, 0x64, 0xf6, 0x4a, 0x4d, 0x08, 0x8b, 0x39, 0x33, 0x77, 0x4a,
	0x6f, 0x41, 0x71, 0xea, 0x9e, 0x78, 0x03, 0xe9, 0xce, 0x9f, 0x77, 0xd7, 0xee, 0x43, 0x71, 0xd9,
	0xaf, 0x04, 0xd9, 0x63, 0xef, 0x2c, 0xe2, 0x57, 0x81, 0xf5, 0xd7, 0xee, 0xe4, 0xd4, 0xab, 0xae,
	0xa1, 0xf9, 0x64, 0xed, 0x71, 0xa6, 0xfe, 0x14, 0xb2, 0xdc, 0x1b, 0x26, 0xcd, 0x32, 0x17, 0x9a,
	0xdd, 0x84, 0x5c, 0xe0, 0xce, 0x47, 0x5e, 0x20, 0x93, 0x4a, 0xcd, 0x72, 0xe8, 0x13, 0x12, 0xab,
	0xff, 0x98, 0x81, 0x5c, 0xb8, 0x5c, 0x11, 0xa2, 0x09, 0xa5, 0x43, 0x7f, 0xba, 0x08, 0xe6, 0xee,
	0x78, 0x1a, 0x2c, 0x22, 0x3d, 0x6e, 0xa5, 0x33, 0x1b, 0xda, 0xd2, 0x1f, 0x32, 0x8d, 0x29, 0x64,
	0x2f, 0x50, 0x28, 0x83, 0x32, 0x1c, 0x4f, 0xbc, 0x48, 0xa5, 0x0a, 0xac, 0x0f, 0x4f, 0xdf, 0xbc,
	0x39, 0x93, 0x32, 0x15, 0x6a, 0x4d, 0x20, 0x17, 0x4a, 0xfd, 0xd3, 0xd0, 0xaf, 0x41, 0x91, 0x85,
	0x29, 0xc0, 0x22, 0x70, 0xe7, 0xc1, 0xe0, 0xe0, 0x2c, 0xf0, 0x64, 0x78, 0x85, 0x12, 0x28, 0xa0,
	0x35, 0x98, 0x78, 0x53, 0x99, 0x51, 0x59, 0x46, 0x4d, 0xc6, 0xd3, 0x70, 0xdf, 0x2a, 0x74, 0x0b,
	0x8a, 0x21, 0x76, 0xe8, 0x4f, 0x24, 0x2f, 0x99, 0xe8, 0x4d, 0x8f, 0xc2, 0xa0, 0x75, 0x89, 0x6c,
	0x42, 0x1e, 0x11, 0x0c, 0xc1, 0x4d, 0xac, 0xd4, 0x7f, 0xcf, 0x40, 0xae, 0xed, 0x0d, 0x17, 0xd6,
	0x8c, 0xde, 0x83, 0xfc, 0xc2, 0x3f, 0x9d, 0x1f, 0x7a, 0x8b, 0x6a, 0x46, 0xaa, 0x73, 0x3d, 0x39,
	0x2d, 0x0b, 0x6b, 0xd6, 0x70, 0x42, 0x5f, 0x38, 0xce, 0x26, 0xe4, 0xfd, 0xf9, 0x78, 0x34, 0x9e,
	0x86, 0x4a, 0x16, 0x23, 0xa9, 0xb3, 0x6f, 0x93, 0x5a, 0x49, 0x4b, 0x1d, 0x15, 0x3b, 0xaf, 0x4f,
	0xad, 0x01, 0xe5, 0x95, 0x06, 0x7f, 0xad, 0x57, 0x19, 0xf5, 0xfa, 0x4f, 0x1a, 0xeb, 0x00, 0xd8,
	0x9e, 0x7b, 0x8b, 0xd3, 0x49, 0x40, 0xaf, 0x81, 0x72, 0xe4, 0x0d, 0xe3, 0x59, 0x8b, 0x09, 0x3d,
	0x54, 0xed, 0xc4, 0x5b, 0x2c, 0xdc, 0x91, 0x17, 0x0f, 0x47, 0xa0, 0x70, 0xe8, 0x9f, 0xcc, 0x26,
	0x5e, 0x10, 0x8a, 0x5d, 0xa8, 0xff, 0x9c, 0x81, 0x1c, 0xff, 0x7b, 0xd9, 0xf8, 0x5b, 0x64, 0xdb,
	0x5d, 0x95, 0xad, 0xd4, 0xbc, 0xb2, 0x12, 0xfb, 0x6c, 0x3c, 0xf1, 0xe4, 0x7d, 0xf9, 0xf7, 0x6a,
	0x14, 0xe2, 0xdc, 0xe4, 0x68, 0x66, 0x56, 0xae, 0xec, 0xda, 0xf9, 0x23, 0x5c, 0xbf, 0x03, 0x0a,
	0xb6, 0x45, 0x1d, 0xe6, 0x17, 0x74, 0xe0, 0xde, 0xb0, 0xfe, 0x43, 0x06, 0x80, 0x2f, 0xf5, 0xba,
	0x07, 0xeb, 0x58, 0x37, 0x0e, 0xbc, 0xb1, 0x64, 0x1e, 0x06, 0x48, 0xf6, 0x11, 0xdf, 0x77, 0x90,
	0xb0, 0xf6, 0x18, 0x20, 0x95, 0xb1, 0x32, 0xe1, 0xf5, 0xf4, 0x84, 0x09, 0x6b, 0x6c, 0x25, 0xf7,
	0xb1, 0x0a, 0x39, 0xe1, 0x1f, 0xa3, 0xf6, 0x1b, 0x90, 0x0b, 0xb5, 0x97, 0x89, 0xe5, 0xfa, 0x4f,
	0x00, 0x59, 0xe1, 0x1f, 0xbf, 0xe3, 0x2d, 0xba, 0x03, 0x4a, 0x70, 0x36, 0x0b, 0xf9, 0x6c, 0x34,
	0xb7, 0xa2, 0x6f, 0x81, 0x7f, 0x8c, 0x3f, 0x71, 0x36, 0xf3, 0xea, 0x7f, 0x14, 0x21, 0x1f, 0xad,
	0x69, 0x09, 0xf2, 0xcf, 0xd9, 0xfe, 0x77, 0x16, 0x6f, 0x93, 0x4b, 0xf4, 0x32, 0x90, 0xc8, 0x18,
	0x68, 0x96, 0xe9, 0x08, 0xd5, 0x14, 0x24, 0x43, 0xaf, 0xc1, 0x76, 0x8c, 0xb6, 0x99, 0x66, 0xa8,
	0x5c, 0x15, 0xba, 0x65, 0x92, 0x35, 0x7a, 0x05, 0xb6, 0x62, 0x87, 0xa9, 0xf6, 0x98, 0x63, 0xab,
	0x1a, 0x23, 0x59, 0x4a, 0x61, 0x23, 0x86, 0x6d, 0x87, 0xf5, 0xdb, 0x16, 0x51, 0xd2, 0x95, 0x39,
	0x73, 0x18, 0x7f, 0xc1, 0xda, 0x64, 0x9d, 0x12, 0x28, 0xc7, 0xa8, 0xd8, 0xb7, 0x19, 0xc9, 0xd1,
	0x02, 0x28, 0x58, 0x8a, 0xe4, 0xb1, 0x0a, 0xae, 0x06, 0xaa, 0x10, 0x5c, 0x6f, 0xf5, 0x05, 0x23,
	0x05, 0x8c, 0x97, 0x58, 0xab, 0xaf, 0x1b, 0x42, 0x37, 0x49, 0x11, 0xb9, 0xa5, 0x91, 0xb8, 0x21,
	0xd0, 0x0d, 0x00, 0xe9, 0xd0, 0x0c, 0xd5, 0x71, 0x48, 0x89, 0x6e, 0x41, 0x25, 0xb4, 0xe3, 0xb9,
	0xca, 0x49, 0x87, 0x36, 0xd3, 0x2c, 0xae, 0x0a, 0x8b, 0x13, 0xfc, 0x90, 0x94, 0x24, 0xc6, 0x4c,
	0xa1, 0x8b, 0x7d, 0xb2, 0x91, 0x04, 0xb1, 0x97, 0x1a, 0xb3, 0xe5, 0xdc, 0x9b, 0x49, 0xad, 0x67,
	0x7d, 0x53, 0x93, 0x10, 0x49, 0xda, 0x19, 0x6a, 0x8b, 0x19, 0x64, 0x2b, 0x49, 0x5b, 0xea, 0x42,
	0x93, 0x18, 0x4b, 0x74, 0x19, 0x27, 0xdb, 0xb4, 0x0c, 0x05, 0x69, 0x0b, 0xb5, 0x43, 0x2e, 0x27,
	0x45, 0x5f, 0xa8, 0x5c, 0x57, 0x5b, 0x06, 0x23, 0x57, 0x92, 0xe1, 0x62, 0x28, 0x1a, 0xe6, 0x2a,
	0xad, 0xc2, 0xe5, 0x55, 0x47, 0xc7, 0xb0, 0x5a, 0xaa, 0x41, 0xae, 0xd1, 0x1a, 0x5c, 0x5d, 0xf5,
	0xe8, 0x72, 0x5c, 0x8d, 0x91, 0x2a, 0x6e, 0xb5, 0xa1, 0x0b, 0xc6, 0x55, 0x83, 0x5c, 0x47, 0x29,
	0x23, 0x63, 0xd0, 0x56, 0x05, 0x23, 0x35, 0x0a, 0x90, 0x73, 0x04, 0xd7, 0xcd, 0x0e, 0xb9, 0x41,
	0xb7, 0x61, 0x33, 0x5c, 0x0f, 0x5a, 0xaa, 0xf6, 0x5c, 0xe8, 0xda, 0x73, 0x72, 0x13, 0xb5, 0x89,
	0x40, 0xad, 0xab, 0x72, 0x72, 0x0b, 0x07, 0x8a, 0x80, 0xb6, 0xa5, 0x91, 0xdb, 0x38, 0x42, 0x62,
	0xf7, 0x71, 0x84, 0x3b, 0x29, 0x88, 0x39, 0x9a, 0x6a, 0x33, 0xb2, 0x83, 0xd2, 0x44, 0x50, 0x97,
	0x71, 0x86, 0x99, 0x77, 0x53, 0xfd, 0x74, 0x53, 0x30, 0x6e, 0x5b, 0x06, 0xa9, 0x23, 0xc5, 0x08,
	0x0c, 0x15, 0xfb, 0x5f, 0x0a, 0xe1, 0xac, 0xc3, 0x5e, 0x92, 0xff, 0xa7, 0xea, 0x3b, 0xba, 0xd9,
	0x31, 0x18, 0x79, 0x2f, 0x0d, 0xed, 0xf7, 0x5a, 0x96, 0x41, 0x76, 0x71, 0x34, 0xb3, 0xdf, 0x6b,
	0x31, 0x4e, 0xde, 0x97, 0xbb, 0x20, 0xd7, 0x83, 0x96, 0x6e, 0x92, 0x3d, 0x79, 0xa6, 0x42, 0xfb,
	0x99, 0x61, 0xa9, 0x82, 0x7c, 0x90, 0x8a, 0xe8, 0xb2, 0x97, 0xe4, 0x9e, 0xdc, 0xcb, 0xd0, 0x46,
	0x72, 0x1d, 0xc6, 0xc9, 0x7d, 0xb9, 0x35, 0x2b, 0xd8, 0xc0, 0xb0, 0xcc, 0x0e, 0xf9, 0x30, 0x95,
	0x6c, 0x69, 0x82, 0x3c, 0xc0, 0x4d, 0xb6, 0x6c, 0x16, 0x1e, 0xaf, 0x06, 0x72, 0x8b, 0xad, 0x81,
	0xbc, 0x73, 0x0f, 0x51, 0x55, 0x1b, 0xcf, 0x51, 0x3f, 0xbc, 0x55, 0x1f, 0xe1, 0x36, 0x69, 0x56,
	0xaf, 0xc7, 0x4c, 0x41, 0x3e, 0xc6, 0x7b, 0x13, 0x19, 0x83, 0xae, 0xea, 0x74, 0x5b, 0xaa, 0xd9,
	0x21, 0x4d, 0xbc, 0x78, 0x31, 0xda, 0xeb, 0x1b, 0x42, 0x37, 0x74, 0x93, 0x91, 0x47, 0xa8, 0x62,
	0x0c, 0xdb, 0x9c, 0xd9, 0xdc, 0xd2, 0xc8, 0x27, 0xc8, 0x3e, 0x06, 0x23, 0x89, 0x3e, 0x4d, 0x07,
	0x3a, 0x36, 0xd3, 0x74, 0xd5, 0x20, 0x9f, 0x61, 0xdf, 0x0e, 0x33, 0x19, 0xd7, 0x35, 0xf2, 0x39,
	0x46, 0x44, 0xc6, 0xa0, 0xcd, 0x0c, 0x26, 0x58, 0x9b, 0x3c, 0x46, 0xa9, 0x62, 0x90, 0xf5, 0xec,
	0x2e, 0xf9, 0x02, 0xe7, 0x49, 0x10, 0xce, 0x2d, 0x4e, 0x9e, 0xa4, 0x33, 0xbb, 0x4c, 0x6d, 0xe3,
	0x79, 0xfa, 0x12, 0xc7, 0x88, 0x41, 0xdd, 0x74, 0x18, 0xc7, 0x7a, 0x5f, 0x21, 0xb5, 0x18, 0xb5,
	0xfa, 0xc2, 0xee, 0x0b, 0xf2, 0x34, 0x8d, 0xd9, 0xdc, 0xea, 0xd9, 0x82, 0x7c, 0x9d, 0xc6, 0x1c,
	0xc1, 0x51, 0xe7, 0x6f, 0xe8, 0x55, 0xa0, 0x09, 0xd6, 0x6f, 0xc5, 0x9d, 0xbe, 0x45, 0x69, 0x62,
	0x5c, 0x70, 0x55, 0x63, 0x78, 0x7e, 0x89, 0x8a, 0x6f, 0x24, 0x7e, 0x5b, 0x97, 0x6f, 0x64, 0xe0,
	0x1f, 0x9f, 0x7b, 0x1b, 0xf0, 0x03, 0xfb, 0x0e, 0x1f, 0xf8, 0xe6, 0xf7, 0xa0, 0x18, 0xee, 0x74,
	0x44, 0x77, 0x41, 0xc1, 0x67, 0x97, 0x96, 0xd3, 0xff, 0x00, 0x6a, 0x64, 0x69, 0x45, 0xcd, 0x76,
	0xa3, 0x07, 0xa9, 0x9c, 0x7e, 0x13, 0xe3, 0x38, 0xbe, 0x12, 0x87, 0x14, 0xe3, 0xb8, 0xf0, 0x29,
	0x88, 0xe3, 0x96, 0xe4, 0x5b, 0xca, 0xaf, 0xbf, 0xdd, 0xbe, 0x74, 0x90, 0x93, 0xff, 0x8d, 0x1f,
	0xfd, 0x19, 0x00, 0x00, 0xff, 0xff, 0xe0, 0x98, 0x9f, 0xcc, 0x5e, 0x0b, 0x00, 0x00,
}
