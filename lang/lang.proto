syntax = "proto3";
package lang;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.goproto_getters_all) = false;

message Def {
	// ident is an opaque identifier for the def. It is not required to
	// be unique. External code that refers to this def should be able
	// to reconstruct this id.
	//
	// Examples:
	//
	//   "x" for `var x = 7`
	//
	//   "X.prototype.y" for y in `class X { y() {} }`
	string id = 1;

	// meta is a collection of key-value pairs that contain
	// information that can be used to resolve or narrow references to
	// this def.
	//
	// Examples:
	//
	//   {"go_package_import_path": "example.com/pkg"} to indicate
	//   that this def is defined in a Go package whose import path is
	//   "example.com/pkg".
	//
	//   {"javascript_module": "mod"} to indicate that this def is
	//   defined in a JavaScript (CommonJS-style) package named "mod".
	//
	// TODO(sqs): How to deal with re-exporting in JavaScript? E.g.,
	// react-router Link is exported by the react-router lib/index.js
	// file as well as by lib/Link.js. We want both to be the same
	// def.
	map<string, string> meta = 2;

	 // title is the full human-readable declaration title (e.g., "var
	 // x int" for `var x = 7`)
	string title = 3;

	// doc is the plain-text documentation.
	//
	// TODO(sqs): support multiple formats, HTML, etc.
	string doc = 4;

	// path is the path to the file or directory in which this def is
	// defined.
	//
	// It is unset when it can't be determined or when there is no
	// single path that includes all relevant files/directories that
	// define it, such as for a Ruby class that is defined (and
	// reopened) across many files in many directories.
	//
	// TODO(sqs): How to handle C-style decls and defns? How to handle
	// Ruby-style class reopening (defining a class across multiple
	// files)?
	string path = 5;
	
	// span is the range containing the entire def and decl. (e.g.,
	// the entire statement `var foo = 3`). It is unset when it can't
	// be determined or when there is none, such as when the
	// definition is defined across multiple files (as in the case of
	// Go packages, for example).
	Span span = 6;

	// name_span is the range containing only the def's name (e.g.,
	// just `foo` in `var foo = 3`)
	Span name_span = 7;
}

message Ref {
	Span span = 1; // span containing the ref
	Target target = 2; // where this ref points to
}

// Target contains information that can be used to determine which def
// a ref points to.
message Target {
	// id is the identifier of the def that this ref points to.
	string id = 1;

	// constraints to narrow or resolve the target def. Each entry in
	// this map further constrains the match to only those defs
	// containing an identical meta entry.
	map<string, string> constraints = 2;

	// For local/internal targets:
	Span span = 3; // span of range that contains the def that this ref points to
	string file = 4; // file containing the def that this ref points to (if span is set, blank means same file as ref)

	// fuzzy is whether this target is a best-effort, inexact
	// references to a def. Applications may resolve fuzzy targets
	// different from exact targets, by presenting the user with a
	// disambiguation UI, for example.
	//
	// A target that refers to a specific file and span is not fuzzy.
	//
	// A target that uniquely identifies a definition is not fuzzy,
	// even if its file/span is not set. For example, {"id":
	// "NewRequest", "constraints": {"go_package_import_path":
	// "net/http"}} uniquely identifies Go's http.NewRequest even
	// though it does not specify a file and span.
	//
	// A target that merely refers to an id, or an id among the
	// current project's dependencies, is fuzzy.
	bool fuzzy = 5;
}

// A Span describes a range in a file. Byte offsets start counting at
// 0. Line and column numbers start counting at 1. Column numbers
// refer to a character position (not a byte offset) in the line.
//
// It is useful to have both. Byte offsets are most useful for
// programmatic operations; line and column numbers are useful for
// display.
message Span {
	uint32 start_byte = 1;
	uint32 byte_len = 2;

	uint32 start_line = 3;
	uint32 start_col = 4;
	uint32 end_line = 5; // 0 means same as start line
	uint32 end_col = 6;
}

service Lang {
	// Defs performs source code analysis and returns a list of
	// definitions found.
	rpc Defs(DefsOp) returns (DefsResult);

	// Refs performs source code analysis and returns a list of refs
	// found at the given location.
	rpc Refs(RefsOp) returns (RefsResult);

	// Toks tokenizes the specified source code and returns a list of
	// tokens.
	rpc Toks(ToksOp) returns (ToksResult);

	// Sel returns information suitable for a tooltip for the given
	// position in a file (i.e., that the user has "Sel"ected).
	rpc Sel(SelOp) returns (SelResult);
}

message DefsOp {
	map<string, bytes> sources = 1; // source files used as input for the operation
	repeated string origins = 2; // only return defs from these files (file contents must also be present in sources map)

	// id specifies an identifier filter, so that only defs whose id
	// matches this value is returned.
	string id = 3;

	// constraints narrow the set of defs to return.
	map<string, string> constraints = 4;

	// config is (for now) free-form config key-value pairs that are
	// interpreted separately by each lang server.
	map<string, string> config = 5;
}

message DefsResult {
	repeated Def defs = 1;
	repeated string messages = 2; // log messages
	bool complete = 3; // whether the build/parsing/compilation was complete (if not, messages explain why; e.g., syntax errors)
}

message RefsOp {
	map<string, bytes> sources = 1; // source files used as input for the operation

	message FileSpan {
		string file = 1; // the file in which the span is located
		Span span = 2; // the point (0-length span) or range in the file
	}
	repeated FileSpan origins = 2; // only return refs from these files

	// config is (for now) free-form config key-value pairs that are
	// interpreted separately by each lang server.
	map<string, string> config = 3;
}

message Refs {
	repeated Ref refs = 1;
}

message RefsResult {
	// Supports overlapping refs (e.g., Go embedded structs where the
	// field name and type name are overlapping refs).
	map<string, Refs> files = 1;

	repeated string messages = 2; // log messages
	bool complete = 3; // whether the build/parsing/compilation was complete (if not, messages explain why; e.g., syntax errors)
}

message ToksOp {
	// source is the input text to be tokenized.
	bytes source = 1;

	// config is (for now) free-form config key-value pairs that are
	// interpreted separately by each lang server.
	map<string, string> config = 2;
}

// Tok represents a token in source code (i.e., the result of
// tokenization).
message Tok {
	uint32 start_byte = 1;
	uint32 byte_len = 2;
	enum TokType {
		// Token types are taken from http://pygments.org/docs/tokens.
		//
		// TODO(sqs): reorder these to make the most commonly used
		// ones earlier, so they require less varint storage.

		KEYWORD = 0;
		KEYWORD_CONSTANT = 1;
		KEYWORD_DECLARATION = 2;
		KEYWORD_NAMESPACE = 3;
		KEYWORD_PSEUDO = 4;
		KEYWORD_RESERVED = 5;
		KEYWORD_TYPE = 6;

		NAME = 7;
		NAME_ATTRIBUTE = 8;
		NAME_BUILTIN = 9;
		NAME_BUILTIN_PSEUDO = 10;
		NAME_CLASS = 11;
		NAME_CONSTANT = 12;
		NAME_DECORATOR = 13;
		NAME_ENTITY = 14;
		NAME_EXCEPTION = 15;
		NAME_FUNCTION = 16;
		NAME_LABEL = 17;
		NAME_NAMESPACE = 18;
		NAME_OTHER = 19;
		NAME_TAG = 20;
		NAME_VARIABLE = 21;
		NAME_VARIABLE_CLASS = 22;
		NAME_VARIABLE_GLOBAL = 23;
		NAME_VARIABLE_INSTANCE = 24;

		LITERAL = 25;
		LITERAL_DATE = 26;
		STRING = 27;
		STRING_BACKTICK = 28;
		STRING_CHAR = 29;
		STRING_DOC = 30;
		STRING_DOUBLE = 31;
		STRING_ESCAPE = 32;
		STRING_HEREDOC = 33;
		STRING_INTERPOL = 34;
		STRING_OTHER = 35;
		STRING_REGEX = 36;
		STRING_SINGLE = 37;
		STRING_SYMBOL = 38;
		NUMBER = 39;
		NUMBER_BIN = 40;
		NUMBER_FLOAT = 41;
		NUMBER_HEX = 42;
		NUMBER_INTEGER = 43;
		NUMBER_INTEGER_LONG = 44;
		NUMBER_OCT = 45;

		OPERATOR = 46;
		OPERATOR_WORD = 47;

		PUNCTUATION = 48;

		COMMENT = 49;
		COMMENT_HASHBANG = 50;
		COMMENT_MULTILINE = 51;
		COMMENT_PREPROC = 52;
		COMMENT_SINGLE = 53;
		COMMENT_SPECIAL = 54;

		GENERIC = 55;
		GENERIC_DELETED = 56;
		GENERIC_EMPH = 57;
		GENERIC_ERROR = 58;
		GENERIC_HEADING = 59;
		GENERIC_INSERTED = 60;
		GENERIC_OUTPUT = 61;
		GENERIC_PROMPT = 62;
		GENERIC_STRONG = 63;
		GENERIC_SUBHEADING = 64;
		GENERIC_TRACEBACK = 65;
	}
	TokType type = 3;
}

message ToksResult {
	repeated Tok toks = 1;

	repeated string messages = 2; // log messages
	bool complete = 3; // whether the tokenization was complete (if not, messages explain why; e.g., syntax errors)
}

message SelOp {
	map<string, bytes> sources = 1; // source files used as input for the operation

	string origin = 2; // the file in which the span is located
	Span span = 3; // the point (0-length span) or range in the file

	// config is (for now) free-form config key-value pairs that are
	// interpreted separately by each lang server.
	map<string, string> config = 4;	
}

message SelResult {
	// defs refer to the definition of the selected item. There can be
	// multiple defs for a given position (e.g., Go embedded struct
	// fields refer to both the field and the type name).
	repeated Target defs = 1;

	// type_string is a human-readable string describing the type of
	// the selection (e.g., variable). For example, in `var x = 7`,
	// x's type string might be "int".
	string type_string = 2;

	repeated string messages = 3; // log messages
	bool complete = 4; // whether the operation was complete (if not, messages explain why; e.g., syntax errors)
}

