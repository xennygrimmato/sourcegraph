/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Do not edit this file. It is machine generated.
{
	"app.plugin.json.activationEvents": "Aktivierungsereignisse für das Plugin",
	"app.plugin.json.contributes": "Beiträge dieses Plugins",
	"app.plugin.json.contributes.language": "Sprachbeiträge des Plugins",
	"app.plugin.json.contributes.language.aliases": "Aliasnamen für diese Sprache",
	"app.plugin.json.contributes.language.extensions": "Dieser Sprache zugeordnete Dateierweiterungen",
	"app.plugin.json.contributes.language.filenames": "Dieser Sprache zugeordnete Dateinamen",
	"app.plugin.json.contributes.language.id": "ID dieser Sprache",
	"app.plugin.json.dependencies": "Pluginabhängigkeiten",
	"app.plugin.json.mainModule": "Relativer Pfad zur JavaScript-Hauptdatei",
	"app.plugin.json.pluginId": "Die eindeutige Plugin-ID",
	"app.plugin.json.scripts": "Vom Plugin bereitgestellte Skripts",
	"app.plugin.json.scripts.compile": "Die Befehlszeile zum Kompilieren dieses Plugins",
	"bower.json.authors": "Eine Liste von Personen, die die Inhalte des Pakets erstellt haben.",
	"bower.json.dependencies": "Abhängigkeiten werden mit einem einfachen Hash des Paketnamens zum Semver-kompatiblen Bezeichner oder zur URL angegeben.",
	"bower.json.description": "Unterstützt Benutzer bei der Erkennung und Suche nach Ihrem Paket mit einer kurzen Beschreibung.",
	"bower.json.devDependencies": "Abhängigkeiten, die nur für die Entwicklung des Pakets erforderlich sind, z. B. Testframework oder Dokumentationserstellung.",
	"bower.json.exportsOverride": "Wird von der grunt-bower-Aufgabe zum Festlegen benutzerdefinierter Installationsspeicherorte verwendet.",
	"bower.json.homepage": "URL zu weiteren Informationen zum Paket. Weicht auf ein GitHub-Projekt zurück, falls nicht angegeben und ein GitHub-Endpunkt.",
	"bower.json.ignore": "Eine Liste von Dateien für Bower, die beim Installieren Ihres Pakets ignoriert werden sollen.",
	"bower.json.invalidPatternName": "Alle Eigenschaften, die mit \"_\" beginnen, sind gültig.",
	"bower.json.keywords": "Wird für die Suche nach einem Schlüsselwort verwendet. Damit kann Ihr Paket einfacher erkannt werden, ohne dass sein Name erforderlich ist.",
	"bower.json.license": "SPDX-Lizenzbezeichner, oder Pfad/URL zu einer Lizenz.",
	"bower.json.main": "Die primär wirkenden Dateien, die für die Verwendung Ihres Pakets erforderlich sind.",
	"bower.json.moduleType": "Die Modultypen, die dieses Paket bereitstellt.",
	"bower.json.packagename": "Der Name Ihres Pakets.",
	"bower.json.private": "Wenn Sie diesen Wert auf \"True\" festlegen, wird dieser die Veröffentlichung verweigern. Dadurch soll verhindert werden, dass private Repositorys versehentlich veröffentlicht werden.",
	"bower.json.repository": "Das Repository, das den Quellcode enthält.",
	"bower.json.resolutions": "Abhängigkeitsversionen, die automatisch aufgelöst werden, wenn Konflikte zwischen Paketen auftreten.",
	"bower.json.title": "JSON-Schema für Bower-Konfigurationsdateien",
	"bower.json.version": "Eine semantische Versionsnummer.",
	"global.json.projects": "Eine Liste der Projektordner relativ zu dieser Datei.",
	"global.json.sources": "Eine Liste der Quellordner relativ zu dieser Datei.",
	"global.json.title": "JSON-Schema für die globalen ASP.NET-Konfigurationsdateien",
	"jsconfig.json.compilerOptions": "Weist dem JavaScript-Sprachdienst an, wie JS-Dateien zu überprüfen sind.",
	"jsconfig.json.compilerOptions.charset": "Der Zeichensatz der Eingabedateien.",
	"jsconfig.json.compilerOptions.decorators": "Aktiviert die experimentelle Unterstützung für ES7-Decorator-Elemente.",
	"jsconfig.json.compilerOptions.diagnostics": "Diagnoseinformationen anzeigen",
	"jsconfig.json.compilerOptions.locale": "Das Gebietsschema zum Anzeigen von Fehlermeldungen, z. B. \"en-us\".",
	"jsconfig.json.compilerOptions.mapRoot": "Gibt den Speicherort an, an dem der Debugger Zuordnungsdateien finden sollte (anstatt generierte Speicherorte).",
	"jsconfig.json.compilerOptions.module": "Die Modulcodegenerierung, anhand der aufgelöst werden soll: \"commonjs\", \"amd\", \"system\" oder \"umd\".",
	"jsconfig.json.compilerOptions.noLib": "Die Standardbibliothekdatei (\"lib.d.ts\") nicht einschließen.",
	"jsconfig.json.compilerOptions.target": "ECMAScript-Zielversion angeben: \"ES3\" (Standard), \"ES5\" oder \"ES6\" (experimentell).",
	"jsconfig.json.exclude": "Auflisten der Dateien und Ordner, die nicht eingeschlossen werden sollen. Diese Eigenschaft wird nicht berücksichtigt, wenn die Eigenschaft \"files\" vorhanden ist.",
	"jsconfig.json.files": "Wenn keine Eigenschaft \"files\" in einer Datei \"jsconfig.json\" vorhanden ist, schließt der Sprachdienst standardmäßig alle Dateien in dem enthaltenen Verzeichnis und den Unterverzeichnissen ein. Wenn eine Eigenschaft \"files\" angegeben ist, werden nur diese Dateien eingeschlossen.",
	"jsconfig.json.title": "JSON-Schema für die JavaScript-Konfigurationsdatei",
	"json.schema.unabletoload": "Fehler beim Laden des Schemas für \"{0}\": {1}.",
	"package.json.bugs": "Die URL für die Problemverfolgung oder die E-Mail-Adresse, an die Problemberichte gesendet werden sollen.",
	"package.json.bugs.email": "Die E-Mail-Adresse, an die Probleme gemeldet werden sollen.",
	"package.json.bugs.url": "Die URL zur Problemnachverfolgung des Projekts.",
	"package.json.bundleDependencies": "Array der Paketnamen, die beim Veröffentlichen des Pakets gebündelt werden.",
	"package.json.bundledDependencies": "Array der Paketnamen, die beim Veröffentlichen des Pakets gebündelt werden.",
	"package.json.config": "Ein \"config\"-Hash kann verwendet werden, um Konfigurationsparameter festzulegen, die in aktualisierungsübergreifenden Paketskripts verwendet werden.",
	"package.json.contributors": "Eine Liste der Mitwirkenden dieses Pakets.",
	"package.json.dependency": "Abhängigkeiten werden mit einem einfachen Hash aus Paketnamen bis Versionsbereich angegeben. Der Versionsbereich ist eine Zeichenfolge mit mindestens einem durch Leerzeichen gentrennten Deskriptor. Abhängigkeiten können auch durch einen Tarball oder eine Git-URL identifiziert werden.",
	"package.json.descr": "So können Benutzer Ihr Paket gemäß der Auflistung in \"pm search\" erkennen.",
	"package.json.description": "NPM-Konfiguration für dieses Paket.",
	"package.json.directories.bin": "Wenn Sie ein Verzeichnis \"bin\" angeben, werden alle Dateien in diesem Ordner als \"bin\"-Hash verwendet.",
	"package.json.directories.doc": "Markdowndateien hier ablegen. Vielleicht werden sie eines Tages ansprechend angezeigt.",
	"package.json.directories.example": "Hier Beispielskripts ablegen. Vielleicht werden Sie eines Tages sinnvoll bereitgestellt.",
	"package.json.directories.lib": "Teilen Sie den Benutzern mit, wo sich der Großteil Ihrer Bibliothek befindet. Mit dem Ordner \"lib\" geschieht nichts Besonderes, aber er enthält nützliche Metadaten.",
	"package.json.directories.man": "Ein Ordner, der Manpages enthält. Generieren Sie ein man-Array durch Durchlaufen des Ordners.",
	"package.json.files": "Das Feld \"files\" ist ein Array aus Dateien, die in das Projekt eingeschlossen werden sollen. Wenn ein Ordner im Array benannt wird, werden auch die Dateien in diesem Ordner einbezogen.",
	"package.json.homepage": "Die URL zur Projektstartseite.",
	"package.json.keywords": "Auf diese Weise können Benutzer Ihr Paket gemäß der Auflistung in \"npm search\" erkennen.",
	"package.json.license": "Sie sollten eine Lizenz und sämtliche Einschränkungen für das Paket angeben, damit Benutzer wissen, wie sie es verwenden dürfen.",
	"package.json.licenses": "Sie sollten eine Lizenz und sämtliche Einschränkungen für das Paket angeben, damit Benutzer wissen, wie sie es verwenden dürfen.",
	"package.json.main": "Das Hauptfeld ist eine Modul-ID, die den primären Einstiegspunkt für das Programm darstellt.",
	"package.json.maintainers": "Eine Liste der Personen, die dieses Paket warten.",
	"package.json.man": "Geben Sie eine einzelne Datei oder ein Array aus Dateinamen für die Suche durch das \"man\"-Programm an.",
	"package.json.name": "Der Name des Pakets.",
	"package.json.person": "Eine Person, die am Erstellen oder Warten dieses Pakets beteiligt war",
	"package.json.preferGlobal": "Wenn das Paket hauptsächlich eine Befehlszeilenanwendung ist, die global installiert werden soll, legen Sie diesen Wert auf \"true\" fest, um eine Warnung bereitzustellen, falls es lokal installiert wird.",
	"package.json.private": "Wenn auf \"true\" festgelegt, wird dieses Paket nicht von NPM veröffentlicht.",
	"package.json.repository": "Geben Sie den Speicherort des Codes an. Dies ist nützlich für Personen, die einen Beitrag leisten möchten.",
	"package.json.scripts": "Das \"scripts\"-Element ist ein Objekthash mit Skriptbefehlen, die zu verschiedenen Zeitpunkten im Lebenszyklus des Pakets ausgeführt werden. Der Schlüssel ist das Lebenszyklusereignis, und der Wert ist der an diesem Punkt auszuführende Befehl.",
	"package.json.underscore": "Alle Eigenschaften, die mit \"_\" beginnen, sind gültig.",
	"package.json.version": "Die Version muss durch \"node-semver\" analysiert werden können (im Paket mit NPM als Abhängigkeit).",
	"project.json.authors": "Der Autor der Anwendung",
	"project.json.bundleExclude": "Liste der Dateien, die aus der Veröffentlichungsausgabe ausgeschlossen werden sollen (kpm-Paket).",
	"project.json.code": "Das Globmuster zum Festlegen aller Codedateien, die kompiliert werden müssen. (Datentyp: Zeichenfolge oder Array mit Globmuster(n). Beispiel: [ \"Ordner1*.cs\", \"Ordner2*.cs\" ]",
	"project.json.commands": "Für diese Anwendung verfügbare Befehle",
	"project.json.compilationOptions": "An Roslyn übergebene Kompilierungsoptionen",
	"project.json.configurations": "Konfigurationen sind benannte Gruppen mit Kompilierungseinstellungen. Es gibt zwei in die Laufzeit integrierte Standards, nämlich \"Debug\" und \"Release\".",
	"project.json.dependencies": "Die Abhängigkeiten der Anwendung. Jeder Eintrag gibt den Namen und die Version eines Nuget-Pakets an.",
	"project.json.dependency.name": "Die Version der Abhängigkeit",
	"project.json.dependency.type": "Der Typ der Abhängigkeit. Abhängigkeiten vom Typ \"Build\" sind nur zur Buildzeit vorhanden.",
	"project.json.description": "Die Beschreibung der Anwendung",
	"project.json.exclude": "Das Globmuster, das alle Codedateien angibt, die von der Kompilierung ausgeschlossen werden sollen. (Datentyp: Zeichenfolge oder Array mit Globmuster(n)).",
	"project.json.frameworks": "Zielframeworks, die erstellt werden, sowie für die Konfiguration spezifische Abhängigkeiten",
	"project.json.preprocess": "Das Globmuster, mit dem alle Codedateien angegeben werden, die vorverarbeitet werden (Datentyp: Zeichenfolge mit Globmuster).",
	"project.json.resources": "Das Globmuster, mit dem alle Dateien angegeben werden, die als Ressourcen kompiliert werden müssen.",
	"project.json.script": "Ein Befehlszeilenskript oder -Skripts.\r\rVerfügbare Variablen:\r%project:Directory% – Das Projektverzeichnis\r%project:Name% – Der Projektname\r%project:Version% -– Die Projektversion",
	"project.json.scripts": "Skripts, die im Laufe verschiedener Phasen ausgeführt werden.",
	"project.json.shared": "Das Globmuster, mit dem die Codedateien angegeben werden, die mit abhängigen Projekten gemeinsam verwendet werden. Beispiel: [ \"Ordner1*.cs\", \"Ordner2*.cs\" ]",
	"project.json.title": "JSON-Schema für ASP.NET project.json-Dateien",
	"project.json.version": "Die Anwendungsversion. Beispiel: 1.2.0.0",
	"project.json.webroot": "Beim Festlegen der Webstammeigenschaft in der project.json-Datei wird der Webserverstamm (öffentlicher Ordner) festgelegt. In Visual Studio wird dieser Ordner als Stamm für IIS verwendet. Statische Dateien sollten hier eingegeben werden.",
	"schema.json": "Beschreibt eine JSON-Datei mit einem Schema. Weitere Informationen finden Sie unter \"json-schema.org\".",
	"schema.json.$schema": "Das Schema zum Prüfen dieses Dokuments gegen",
	"schema.json.additionalItems": "Für Arrays, nur wenn \"items\" als Array festgelegt ist. Wenn es ein Schema ist, überprüft dieses Elemente nach den vom Elementarray angegebenen Elementen. Wenn es falsch ist, werden zusätzliche Elemente zu Validierungsfehlern führen.",
	"schema.json.additionalProperties": "Entweder ein Schema oder ein boolescher Wert. Wenn es ein Schema ist, wird es zur Überprüfung aller Eigenschaften verwendet, die nicht \"properties\" oder \"patternProperties\" entsprechen. Wenn falsch, führen alle mit beiden nicht übereinstimmenden Eigenschaften zu einem Schemafehler.",
	"schema.json.allOf": "Ein Array von Schemas, die alle übereinstimmen müssen.",
	"schema.json.anyOf": "Ein Array von Schemas, von denen mindestens eins übereinstimmen muss.",
	"schema.json.default": "Ein Standardwert. Von Vorschlägen verwendet.",
	"schema.json.definitions": "Nicht für Überprüfungen verwendet. Platzieren Sie hier Teilschemas, auf die Sie inline mit $ref verweisen möchten.",
	"schema.json.dependencies": "Eine Zuordnung von Eigenschaftennamen zu entweder einem Array von Eigenschaftennamen oder einem Schema. Ein Array von Eigenschaftennamen bedeutet, dass die Gültigkeit der im Schlüssel benannten Eigenschaften davon abhängt, ob die Eigenschaften im Array des Objekts vorhanden sind. Wenn der Wert ein Schema ist, wird dieses Schema nur dann auf das Objekt angewendet, wenn die Eigenschaft im Schlüssel im Objekt vorhanden ist.",
	"schema.json.description": "Eine lange Beschreibung des Elements. Verwendet in Menüs, die beim Zeigen darauf geöffnet werden, und bei Vorschlägen.",
	"schema.json.enum": "Satz der gültigen Literalwerte",
	"schema.json.exclusiveMaximum": "Macht die maximum-Eigenschaft exklusiv.",
	"schema.json.exclusiveMininum": "Macht die minimum-Eigenschaft exklusiv.",
	"schema.json.id": "Ein eindeutiger Bezeichner für das Schema.",
	"schema.json.items": "Für Arrays. Kann entweder ein Schema sein, anhand dessen jedes Element überprüft wird, oder ein Array von Schemas, anhand dessen jedes Element in der Reihenfolge überprüft wird (das erste Schema überprüft das erste Element, das zweite Schema überprüft das zweite Element usw.).",
	"schema.json.maxItems": "Die maximale Anzahl von Elementen, die sich innerhalb eines Arrays befinden können. Inklusiv.",
	"schema.json.maxLength": "Die maximale Länge einer Zeichenfolge.",
	"schema.json.maxProperties": "Die maximale Anzahl von Eigenschaften, die ein Objekt haben kann. Inklusiv.",
	"schema.json.maximum": "Der maximale numerische Wert, standardmäßig inklusiv.",
	"schema.json.minItems": "Die minimale Anzahl von Elementen, die sich innerhalb eines Arrays befinden können. Inklusiv.",
	"schema.json.minLength": "Die minimale Länge einer Zeichenfolge.",
	"schema.json.minProperties": "Die minimale Anzahl von Eigenschaften, die ein Objekt haben kann. Inklusiv.",
	"schema.json.minimum": "Der minimale numerische Wert, standardmäßig inklusiv.",
	"schema.json.multipleOf": "Eine Zahl, die den aktuellen Wert glatt teilen sollte (d. h. ohne Rest)",
	"schema.json.not": "Ein Schema, das nicht übereinstimmen darf.",
	"schema.json.oneOf": "Ein Array von Schemas, von denen genau eines übereinstimmen muss.",
	"schema.json.pattern": "Ein regulärer Ausdruck, mit dem die Zeichenfolge verglichen wird. Er ist nicht implizit verankert.",
	"schema.json.patternProperties": "Eine Zuordnung von regulären Ausdrücken bei Eigenschaftennamen zu Schemas zum Vergleichen von Eigenschaften.",
	"schema.json.properties": "Eine Zuordnung von Eigenschaftennamen zu Schemas für jede Eigenschaft.",
	"schema.json.required": "Ein Array von Zeichenfolgen, das die Namen aller für dieses Objekt erforderlichen Eigenschaften aufzählt.",
	"schema.json.title": "Ein beschreibender Titel des Elements.",
	"schema.json.type": "Entweder eine Zeichenfolge eines der grundlegenden Schematypen (number, integer, null, array, object, boolean, string) oder ein Array aus Zeichenfolgen, das einen Teilsatz dieser Typen bezeichnet.",
	"schema.json.uniqueItems": "Wenn alle Elemente im Array eindeutig sein müssen. Standardmäßig wird false verwendet.",
	"snippetSchema.json": "Benutzerkonfiguration des Codeausschnitts",
	"snippetSchema.json.body": "Der Inhalt des Codeausschnitts. Verwenden Sie \"${id}\", \"${id:label}\", \"${1:label}\" für Variablen und \"$0\", \"$1\" für die Cursorpositionen.",
	"snippetSchema.json.description": "Die Beschreibung des Codeausschnitts.",
	"snippetSchema.json.prefix": "Das Präfix, das beim Auswählen des Codeausschnitts in IntelliSense verwendet werden soll.",
	"tsconfig.json.compilerOptions": "Gibt dem TypeScript-Compiler Anweisungen zum Kompilieren von TS-Dateien",
	"tsconfig.json.compilerOptions.charset": "Der Zeichensatz der Eingabedateien.",
	"tsconfig.json.compilerOptions.declaration": "Generiert entsprechende \"d.ts\"-Dateien.",
	"tsconfig.json.compilerOptions.diagnostics": "Diagnoseinformationen anzeigen",
	"tsconfig.json.compilerOptions.emitBOM": "Ausgeben einer UTF-8-Bytereihenfolgemarkierung (BOM) am Anfang von Ausgabedateien.",
	"tsconfig.json.compilerOptions.inlineSourceMap": "Ausgeben einer Datei mit Quellzuordnungen anstelle separater Dateien.",
	"tsconfig.json.compilerOptions.inlineSources": "Ausgeben der Quelle zusammen mit den Quellzuordnungen in einer Datei (erfordert, dass \"-inlineSourceMap\" festgelegt ist).",
	"tsconfig.json.compilerOptions.listFiles": "Ausgeben von Namen des Dateiteils der Kompilierung.",
	"tsconfig.json.compilerOptions.locale": "Das Gebietsschema zum Anzeigen von Fehlermeldungen, z. B. \"en-us\".",
	"tsconfig.json.compilerOptions.mapRoot": "Gibt den Speicherort an, an dem der Debugger Zuordnungsdateien finden sollte (anstatt generierte Speicherorte)",
	"tsconfig.json.compilerOptions.module": "Modulcodegenerierung angeben: \"CommonJS\", \"Amd\", \"System\" oder \"UMD\".",
	"tsconfig.json.compilerOptions.newLine": "Gibt das Ende der Zeilensequenz an, die beim Ausgegeben von Dateien verwendet werden soll: \"CRLF\" (DOS) oder \"LF\" (Unix).",
	"tsconfig.json.compilerOptions.noEmit": "Keine Ausgabe vornehmen.",
	"tsconfig.json.compilerOptions.noEmitHelpers": "Keine Generierierung von benutzerdefinierten Hilfsfunktionen wie \"__extends\" in der kompilierten Ausgabe.",
	"tsconfig.json.compilerOptions.noEmitOnError": "Nicht ausgeben, wenn Typenprüffehler gemeldet wurden.",
	"tsconfig.json.compilerOptions.noImplicitAny": "Warnung bei Ausdrücken und Deklarationen mit einem impliziten \"any\"-Typ.",
	"tsconfig.json.compilerOptions.noLib": "Die Standardbibliothekdatei (\"lib.d.ts\") nicht einschließen.",
	"tsconfig.json.compilerOptions.out": "Verketten und Ausgeben in eine einzige Datei.",
	"tsconfig.json.compilerOptions.outDir": "Ausgabestruktur an das Verzeichnis umleiten.",
	"tsconfig.json.compilerOptions.preserveConstEnums": "Keine \"const\"-Enumerationsdeklarationen im generierten Code löschen.",
	"tsconfig.json.compilerOptions.removeComments": "Keine Kommentare an die Ausgabe übergeben.",
	"tsconfig.json.compilerOptions.rootDir": "Gibt das Stammverzeichnis der Eingabedateien an. Wird verwendet, um die Ausgabeverzeichnisstruktur mit \"--outDir\" zu steuern.",
	"tsconfig.json.compilerOptions.sourceMap": "Generiert entsprechende MAP-Datei.",
	"tsconfig.json.compilerOptions.sourceRoot": "Gibt den Speicherort an, an dem vom Debugger TypeScript-Dateien statt Quellspeicherorte gefunden werden sollen.",
	"tsconfig.json.compilerOptions.suppressImplicitAnyIndexErrors": "\"noImplicitAny\"-Fehler für Indizierungsobjekte ohne Indexsignaturen unterdrücken.",
	"tsconfig.json.compilerOptions.target": "ECMAScript-Zielversion angeben: \"ES3\" (Standard), \"ES5\" oder \"ES6\" (experimentell).",
	"tsconfig.json.files": "Wenn in \"tsconfig.json\" keine \"files\"-Eigenschaft vorhanden ist, schließt der Compiler standardmäßig alle Dateien in den enthaltenen Verzeichnissen und Unterverzeichnissen ein. Wenn eine \"files\"-Eigenschaft angegeben ist, werden nur diese Dateien eingeschlossen.",
	"tsconfig.json.title": "JSON-Schema für die Konfigurationsdatei des TypeScript-Compilers"
}